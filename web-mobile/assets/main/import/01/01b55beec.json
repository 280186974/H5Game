[1,["36Oua+zQlIp4UoN6u4sqea","c78h2VbFRF1qa44xYkVuOb@eb4a6","ba2gze+UFLqIVYrHdB7urq@73a7b","b9kR+6AGJAwYhLIhI5nU0U","a7YStUNeNCOKGpSntUY1g5","04m2osSjJJRK4YJ+bZZbU9","1brw/JvvpFnIvdrxpFCgMZ","1bAIRc2bNLCZOtX9UZfbos","59S2kx/y5BG7EvpeIogEDI@2bee3","1eOJJcNlZH3KziQzs03sMi@a1a8d","f6SJZOjTJB/JrJeh5xTdF7","56Lvl1YohIxJFOI6mTw5wR","a3zQCfCrBCDZJ4uf2rk5u8","9escnbg4RKyZBd82YvmKWV@6c48a","73UcnIEchIeL2Xxnj3XBWl@c2696","a5Bfxvf5FFTo5gteiHZxZB@c2696","71iOtH9HdGgp3lH791OO9H@6c48a","12Y9dMgWdJKJGmTiZyQR9H@a804a","c78h2VbFRF1qa44xYkVuOb@18d6f","5bLKXo4IxGPYzuWJh9Bgu9@18d6f","7ayu1dPXVIT4u5qKa4YZTN","b3GYwa181MKKvwwO1DzFh2","dfdjM6MFFFe7m9Je9Boums","ba2gze+UFLqIVYrHdB7urq@c2696","73UcnIEchIeL2Xxnj3XBWl@d90a4","b86OaabQxCMIS/Cw7bj9G7","ca0lYz6JtOI4wvbkQOU5LV","1eOJJcNlZH3KziQzs03sMi@c2696","1eOJJcNlZH3KziQzs03sMi@73b7f","b2SlrtsY5NBZZej+itb2te@6c48a","63PNgcPOlC6pTzrjv5DoF4@6c48a","59S2kx/y5BG7EvpeIogEDI@18d6f","5bLKXo4IxGPYzuWJh9Bgu9@ee8bc","5bLKXo4IxGPYzuWJh9Bgu9@73b7f","d4bYdrCiBCdZdy/asDWZeh@925ad","c78h2VbFRF1qa44xYkVuOb@73b7f","16G+7kQBRAiKgIYypsqMls","a07E/ncgFGSJyd5KVHwteu","7aW9PGmX1HmKe22ACw2TRs","7dNzI1gb5PS6/OeovFz1Kx@6c48a","877zbuaXNDuKAch1GsdlJU","e5mM1Ip85KNpL/PZPq2Rvn","8bLTRYgNFNG7s8KEndCQEt","38xlOJV4RN/5iXDJ6OJtyK","ddwKMAMj1Ic7Xj+QpsrXub","e0KXmwsfVBOrCLc2QtBbe/","d3uD8fW35Er6JlZ3d9dq0C@014f5","07z09hFqZERLw1e+V6oMc/","a6P6e3Nz1L4J8iGDC9QMvX","1cvX08guFHl4mhERcVSo13","12Y9dMgWdJKJGmTiZyQR9H@2e76e","c78h2VbFRF1qa44xYkVuOb@dd320","59S2kx/y5BG7EvpeIogEDI@b0753","0aPkhYTbZC56o9NPQSEK8O","9em+bo+pxPR7FwztFG2DOC","5bLKXo4IxGPYzuWJh9Bgu9@e70a9","20gc/zsAZEEKvzPQIl8oKP","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","c6WUxTCf1Le5BqcCE9o6Yu","44gybTe9lIp5oRLEDiguO5","23iXFuy3ZIfIUd37gPzYcZ@f4113","10IZ7kIpVKiqX1WAnSPcdF@1a9b0","ebBWXPbW9HJ5p0dhqWcPqh@e4391","66hjPUc/tGi4zg7KmiBVQa@6c48a","cfXTyKIRpKnZaBJdPOcAZ8@6c48a","1eOJJcNlZH3KziQzs03sMi@36763","1eOJJcNlZH3KziQzs03sMi@2b030","1eOJJcNlZH3KziQzs03sMi@fadb5","1eOJJcNlZH3KziQzs03sMi@438fe","8e9lB1bq5DZJ9C+f3CVvYx@6c48a","e0ELOPrJ5Pup8P7RErRYFg@6c48a","a5Bfxvf5FFTo5gteiHZxZB@69569","a20z5nzCdD95h5jHek3Vrl@ab850","a3P7OIbj5DRI3HradnmJP+","59S2kx/y5BG7EvpeIogEDI@6496c","59S2kx/y5BG7EvpeIogEDI@ec61f","59S2kx/y5BG7EvpeIogEDI@6213e","59S2kx/y5BG7EvpeIogEDI@438fe","5bLKXo4IxGPYzuWJh9Bgu9@fbe45","5bLKXo4IxGPYzuWJh9Bgu9@6cf10","5bLKXo4IxGPYzuWJh9Bgu9@d1998","5bLKXo4IxGPYzuWJh9Bgu9@438fe","584YzAHBxJRqwts+pbxEXa@f4113","79dRESy19LnIq7pyX/XXSw@1a9b0","0cpcBvfIpF5q/HvcyJh8w1@e4391","73UcnIEchIeL2Xxnj3XBWl@0cd4e","73UcnIEchIeL2Xxnj3XBWl@438fe","73UcnIEchIeL2Xxnj3XBWl@1da29","20BRwAYphF67p5JPRYwkOr@6c48a","63bdj4m0pESqSAHm4C22pc@6c48a","73UcnIEchIeL2Xxnj3XBWl@7361a","c1UlpPBAxHgIrY9U9Jr567","b9AWCsMfdKrrRKDRNBdEVo@6c48a","a20z5nzCdD95h5jHek3Vrl@db4d2","a20z5nzCdD95h5jHek3Vrl@8796e","a20z5nzCdD95h5jHek3Vrl@6b9e5","a5Bfxvf5FFTo5gteiHZxZB@db4d2","a5Bfxvf5FFTo5gteiHZxZB@c733d","a5Bfxvf5FFTo5gteiHZxZB@438fe","a5Bfxvf5FFTo5gteiHZxZB@6b9e5","b0eua7hnxK8KB8CQ3qOdCB@6c48a","e0+gcl0bFGQaDgOQFugNO4@6c48a","ba2gze+UFLqIVYrHdB7urq@7b309","ba2gze+UFLqIVYrHdB7urq@788cd","ba2gze+UFLqIVYrHdB7urq@438fe","3679JGmvBMAImSDkg4HP9U@4a541","87JeoHPW1NOIHoOJrOhYFZ@925ad","c78h2VbFRF1qa44xYkVuOb@78c2f","c78h2VbFRF1qa44xYkVuOb@6cd99","c78h2VbFRF1qa44xYkVuOb@25e1c","c78h2VbFRF1qa44xYkVuOb@438fe","8bMI+V7HVB54Bfzn3DYBjq@6c48a","f6joGTsphLyKDAaRACqGzS@6c48a","d3uD8fW35Er6JlZ3d9dq0C@7a3ca","d3uD8fW35Er6JlZ3d9dq0C@8c3a2","d3uD8fW35Er6JlZ3d9dq0C@aa825","d3uD8fW35Er6JlZ3d9dq0C@68c38","1eOJJcNlZH3KziQzs03sMi@76086","899lqtP6hKY44ePlU2HAUd","13no4JQMhAdJkchKDeKqEU","d1NGQ2rJZCcbhjH0/erZWw","ba2gze+UFLqIVYrHdB7urq@04546","59NE0NwndGj4H0F3DszR/F","73AB75lu5DY4VIQ3syBC7J"],["_parent","value","target","root","targetInfo","source","_effectAsset","node","asset","to","from","mainTexture","data","clip","_mesh","_skeleton","_defaultClip","_anyState","_exitState","_entryState","graph","_particleSystem","_mainTexture","ani","body","normalMap","TargetNode","LastNode","CanMergeNode","CanSetNode","_cameraComponent","audio","scene","rootNode","plane","touchUI","mainCam","merge","button","_envmapHDR","_envmapLDR","Eff","JumpEff","baseColorMap"],[["cc.Node",["_name","_id","_objFlags","__editorExtras__","_active","_layer","_prefab","_parent","_lpos","_children","_lrot","_euler","_components","_lscale"],-3,4,1,5,2,5,5,9,5],"cc.ImageAsset",["cc.Node",["_name","_layer","_id","_lpos","_parent","_components","_prefab","_lrot","_euler","_children","_lscale"],0,5,1,2,4,5,5,9,5],["cc.CurveRange",["mode","constantMax","constantMin","constant","multiplier","spline"],-2,4],["cc.RealKeyframeValue",["rightTangentWeight","leftTangentWeight","value","interpolationMode","rightTangent","leftTangent"],-3],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots","targetOverrides"],2,1,1,2,9],["LevelData",["level","kind"],1],["cc.ColorKey",["time","color"],2,5],["cc.MeshRenderer",["_name","_shadowCastingMode","node","_materials","lightmapSettings","_mesh","__prefab"],1,1,3,4,6,4],["cc.Material",["_states","_defines","_techIdx","_name","_props"],-1,12],["cc.ShapeModule",["_enable","emitFrom","radius","_angle","_shapeType","arcSpeed","_position"],-2,4,5],"cc.TextureCube",["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_id","_parent","_components","_lpos","_children"],0,1,12,5,2],["cc.Node",["_objFlags","_name","_prefab","_parent","__editorExtras__","_children","_components"],1,4,4,11,12,9],["cc.Node",["_name","_children","_components","_prefab","_lpos","_lrot","_euler"],2,2,2,4,5,5,5],["cc.BoxCollider",["_size","node","__prefab","_center"],3,5,1,4,5],["WarUnitConfig",["kind","allBody"],2,3],["cc.TargetOverrideInfo",["propertyPath","source","target","targetInfo","sourceInfo"],2,1,1,4,4],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.PrefabInstance",["fileId","prefabRootNode","mountedComponents","propertyOverrides","removedComponents","mountedChildren"],2,1,9,9,9,9],["cc.UITransform",["node","_contentSize"],3,1,5],["cc.Widget",["_alignFlags","_left","_right","_top","_bottom","_originalWidth","_originalHeight","node"],-4,1],["cc.Camera",["_clearFlags","_visibility","_projection","_priority","_orthoHeight","_far","_fov","node","_color"],-4,1,5],["cc.animation.AnimationTransition",["duration","exitConditionEnabled","from","to","conditions"],1,1,1,9],["cc.animation.UnaryCondition",["operator","operand"],2,4],["cc.animation.Motion",["name","speed","motion"],1,4],["cc.GradientRange",["_mode","gradient"],2,4],["cc.AlphaKey",["alpha","time"],1],["cc.ForceOvertimeModule",["_enable","x","y","z"],2,4,4,4],["22feaQg5fVElaoTC+L5gsUj",["node","__prefab","CanSetNode","CanMergeNode","LastNode","TargetNode"],3,1,4,1,1,1,1],["cc.CompPrefabInfo",["fileId"],2],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.ModelLightmapSettings",[],3],["cc.Material",["_name","_props","_states","_defines"],-1],["cc.SceneAsset",["_name"],2],["cc.TargetInfo",["localID"],2],["186e1Qc4AJCAZ2d5TxY8FmU",["allBlock","allWarUnit"],2,9],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_enabled","_distance","_maxReceived","_shadowColor","_size"],0,5,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["6c1f0WJza9Bx48khtOPacw5",["node","audio","merge","button"],3,1,1,6,6],["cc.DirectionalLight",["_colorTemperature","_illuminanceHDR","node","_staticSettings"],1,1,4],["cc.StaticLightSettings",["_castShadow"],2],["cc.AudioSource",["_playOnAwake","node"],2,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.animation.AnimationGraph",["_layers","_variables"],3,9,11],["cc.animation.Layer",["_stateMachine"],3,4],["cc.animation.StateMachine",["_states","_transitions","_entryState","_exitState","_anyState"],3,2,9,1,1,1],["cc.animation.Transition",["from","to"],3,1,1],["cc.animation.TriggerCondition",["trigger"],2],["cc.animation.BindableBoolean",["variable"],2],["cc.animation.TriggerVariable",["_flags"],2],["cc.animation.PlainVariable",["_type","_value"],1],["cc.animation.ClipMotion",["clip"],3,6],["cc.animation.State",["name"],2],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.SkeletalAnimation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.SkinnedMeshRenderer",["node","__prefab","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],3,1,4,3,4,1,6,6],["f8b3aFja0hAPZ1Z9WVKLVnQ",["node","__prefab","levelData","body","ani"],3,1,4,4,1,1],["cc.MountedChildrenInfo",["targetInfo","nodes"],3,4,2],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,2],["cc.animation.AnimationController",["node","__prefab"],3,1,4],["cc.ParticleSystem",["duration","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.ParticleSystem",["duration","loop","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer"],1,1,4,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4],["cc.Burst",["count"],3,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.VelocityOvertimeModule",["_enable","x","y","z","speedModifier"],2,4,4,4,4],["cc.LimitVelocityOvertimeModule",["limitX","limitY","limitZ","limit"],3,4,4,4,4],["cc.RotationOvertimeModule",["_enable","x","y","z"],2,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","frameOverTime","startFrame"],0,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.ParticleSystemRenderer",["_mainTexture"],3,6],["cc.AudioClip",["_name","_native","_duration"],0]],[[5,0,1,2,2],[36,0,2],[0,0,7,9,6,8,10,11,2],[49,0,1,2,2],[2,0,4,9,6,3,7,8,2],[3,1],[0,0,7,6,8,2],[46,0,1,2,2],[18,0,1,4,2,3,2],[31,0,2],[48,0,1,2,2],[47,0,1,2,3],[32,0,1,2,3,2],[3,3,2],[45,0,1,2,3],[0,2,3,7,6,3],[0,0,7,9,6,8,10,13,11,2],[9,0,1,4,3],[18,0,1,2,3,2],[65,0,1],[19,0,2,2],[33,1],[56,0,1,2,3],[24,0,1,2,3,4,3],[26,0,2,2],[66,0,2],[34,0,1,2,3,5],[0,0,9,6,8,10,11,2],[2,0,4,9,6,3,7,10,8,2],[12,1],[0,0,7,6,2],[0,0,7,6,8,10,11,2],[27,1],[3,0,2,1,4],[0,0,7,9,6,8,2],[0,0,7,9,6,2],[0,0,7,6,8,10,13,11,2],[24,0,2,3,2],[62,0,2],[12,0,2],[50,0,1,2,2],[68,0,1,2,3,4],[69,0,1,2,3,1],[70,0,1,2,3,4,5,6,1],[9,2,0,1,4,4],[3,0,5,2],[28,0,1,3],[81,0,1,2],[4,3,2,3],[0,2,3,6,3],[0,0,9,12,6,2],[0,0,9,6,8,2],[0,0,7,12,6,2],[2,0,4,9,6,3,2],[9,3,0,1,4,4],[19,0,1,2,3],[67,0,1,2,4],[57,0,1,1],[58,0,1],[59,0,1,2,3,4,1],[60,0,1,1],[61,0,2],[25,1,1],[25,0,1,2],[63,0,2],[64,0,1,3],[26,0,1,2,3],[71,0,1,2,3,4,1],[73,0,1,1],[74,0,1,1],[0,0,9,12,6,8,2],[0,0,4,7,12,6,8,13,3],[8,0,2,6,3,4,5,2],[8,2,6,3,4,5,1],[20,0,1,2,3,4,2],[27,0,1,2],[3,0,1,3],[77,0,1],[78,0,1,2],[79,0,1,1],[7,0,2],[7,0,1,2],[28,0,2],[80,0,1,2,3,4,2],[82,0,1,2,3,4,2],[83,0,1,2,3,1],[84,0,1,2,3,2],[85,0,1,2,3,4,4],[86,0,1,2,3,4,1],[87,0,1],[0,0,1,7,9,3],[0,0,7,9,2],[0,0,7,6,10,11,2],[0,0,9,6,8,10,13,11,2],[0,0,7,12,6,10,11,2],[0,0,9,6,2],[0,0,7,9,6,10,11,2],[0,0,7,12,6,10,13,11,2],[14,1,5,6,2,2],[15,0,1,2,3,4,2],[5,0,1,2,3,2],[5,0,1,2,4,3,2],[21,0,1,1],[76,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[7,1,1],[4,2,4,0,5,1,6],[4,4,0,5,1,5],[29,1,2,3,1],[88,0,1,2,4],[0,0,1,9,8,3],[0,0,5,7,12,3],[0,0,1,7,12,8,10,11,3],[0,0,1,7,3],[0,0,1,7,12,8,13,3],[0,0,2],[0,0,7,12,6,8,13,2],[13,0,1,2,3,6,4,5,4],[13,0,1,2,3,4,5,4],[2,0,4,5,3,2],[2,0,5,3,7,8,2],[2,0,1,2,4,5,4],[2,0,5,6,3,7,8,2],[2,0,4,5,6,3,2],[14,0,3,2,4,2],[15,0,1,2,3,4,5,6,2],[30,0,1,2,3,4,5,1],[16,1,2,3,0,1],[16,0,1],[5,0,4,3,2],[8,0,1,2,3,4,5,3],[35,0,2],[37,0,1,2],[17,1,1],[17,0,1,2],[38,0,1,2,3,2],[39,0,1,2,3,4,1],[40,0,1,2,3,4,2],[41,0,1,2,3,4,4],[42,0,1,2,2],[43,1],[44,1],[20,0,1,5,2,3,4,2],[21,0,1],[51,0,1,1],[22,0,1,2,3,4,7,6],[22,0,5,6,7,4],[52,0,1,2,3,1],[53,0,1,2,3,3],[54,0,2],[55,0,1,2],[23,2,3,4,5,0,1,7,8,7],[23,6,0,1,4],[6,0,2],[6,1],[6,1,2],[6,1,0,3],[72,0,1,1],[75,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,3],[3,0,2,1,4,5],[7,1],[10,0,4,1,2,3,5,6,6],[10,0,4,1,2,3,5,6],[10,0,1,2,3,5,5],[4,3,2,0,1,5],[4,3,0,1,4],[29,0,1,2,3,2]],[[[[39,"Block"],[70,"Block",[-8,-9,-10,-11],[[125,-6,[9,"407DSalc1F6r0bAkZPlzAB"],-5,-4,-3,-2],[126,-7,[9,"b0Hr0msjRMPbZ9wi2B2JKD"],[1,0,0.15,0],[1,3.22,0.3,3.25]]],[0,"3dTvlTLJ1JrIW7pRkl1Lk4",-1,0],[1,6.4,0,3.15]],[71,"CanSet",false,1,[[72,"Cube<ModelComponent>",-12,[9,"79TpAw/qBN0YQ/J8D6MQcf"],[0],[21],1]],[0,"a0pLyVXJFNdrwp7zS7fDff",1,0],[1,0,0.15,0],[1,3,0.3,3]],[71,"Last",false,1,[[72,"Cube<ModelComponent>",-13,[9,"0cccS/v91Ky40qVfwMtLpY"],[2],[21],3]],[0,"98E5a6amJHAJTSW+lj3o0H",1,0],[1,0,0.15,0],[1,3,0.3,3]],[71,"Merge",false,1,[[72,"Cube<ModelComponent>",-14,[9,"c4TODomsVKX74WxJz5D24m"],[4],[21],5]],[0,"88tMSeD+9CGpWImq9OA5eO",1,0],[1,0,0.15,0],[1,3,0.3,3]],[30,"TargetNode",1,[0,"265nLb8WdJ4I6Xy8ecgRn/",1,0]]],0,[0,3,1,0,26,5,0,27,3,0,28,4,0,29,2,0,7,1,0,7,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,7,2,0,7,3,0,7,4,0,12,1,14],[0,0,0,0,0,0],[-1,14,-1,14,-1,14],[36,17,37,17,38,17]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{},{},{}],[[{},[{},"mainColor",8,[4,4283193752]],{},{}],0,11,0,0]]],0,0,[0],[6],[4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[39,4]],[[[130,"game"],[1,["16LbTcbhZSi5dTD4Ixcaby"]],[131,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],[[132,[2,3]],[133,1,[4,5]]]],[109,"Player","e4Xup4YLdCDoYEp35ff8KR",[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15],[1,0,0,-4.75]],[134,"game",[-134,-135,-136,-137,-138,-139,3,-140,-141,-142,-143,-144],[128,"0d1ff909-70c7-4f97-869a-16810d32502d",[[8,["SelectNode"],-36,[1,["407DSalc1F6r0bAkZPlzAB"]],-35,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-38,[1,["407DSalc1F6r0bAkZPlzAB"]],-37,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-40,[1,["407DSalc1F6r0bAkZPlzAB"]],-39,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-42,[1,["407DSalc1F6r0bAkZPlzAB"]],-41,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-44,[1,["407DSalc1F6r0bAkZPlzAB"]],-43,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-46,[1,["407DSalc1F6r0bAkZPlzAB"]],-45,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-48,[1,["407DSalc1F6r0bAkZPlzAB"]],-47,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-50,[1,["407DSalc1F6r0bAkZPlzAB"]],-49,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-52,[1,["407DSalc1F6r0bAkZPlzAB"]],-51,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-54,[1,["407DSalc1F6r0bAkZPlzAB"]],-53,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-56,[1,["407DSalc1F6r0bAkZPlzAB"]],-55,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-58,[1,["407DSalc1F6r0bAkZPlzAB"]],-57,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-60,[1,["407DSalc1F6r0bAkZPlzAB"]],-59,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-62,[1,["407DSalc1F6r0bAkZPlzAB"]],-61,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-64,[1,["407DSalc1F6r0bAkZPlzAB"]],-63,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-66,[1,["407DSalc1F6r0bAkZPlzAB"]],-65,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-68,[1,["407DSalc1F6r0bAkZPlzAB"]],-67,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-70,[1,["407DSalc1F6r0bAkZPlzAB"]],-69,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-72,[1,["407DSalc1F6r0bAkZPlzAB"]],-71,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-74,[1,["407DSalc1F6r0bAkZPlzAB"]],-73,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-76,[1,["407DSalc1F6r0bAkZPlzAB"]],-75,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-78,[1,["407DSalc1F6r0bAkZPlzAB"]],-77,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-80,[1,["407DSalc1F6r0bAkZPlzAB"]],-79,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-82,[1,["407DSalc1F6r0bAkZPlzAB"]],-81,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-84,[1,["407DSalc1F6r0bAkZPlzAB"]],-83,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-86,[1,["407DSalc1F6r0bAkZPlzAB"]],-85,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-88,[1,["407DSalc1F6r0bAkZPlzAB"]],-87,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-90,[1,["407DSalc1F6r0bAkZPlzAB"]],-89,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-92,[1,["407DSalc1F6r0bAkZPlzAB"]],-91,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-94,[1,["407DSalc1F6r0bAkZPlzAB"]],-93,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-96,[1,["407DSalc1F6r0bAkZPlzAB"]],-95,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-98,[1,["407DSalc1F6r0bAkZPlzAB"]],-97,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-100,[1,["407DSalc1F6r0bAkZPlzAB"]],-99,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-102,[1,["407DSalc1F6r0bAkZPlzAB"]],-101,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-104,[1,["407DSalc1F6r0bAkZPlzAB"]],-103,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-106,[1,["407DSalc1F6r0bAkZPlzAB"]],-105,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-108,[1,["407DSalc1F6r0bAkZPlzAB"]],-107,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-110,[1,["407DSalc1F6r0bAkZPlzAB"]],-109,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-112,[1,["407DSalc1F6r0bAkZPlzAB"]],-111,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[8,["SelectNode"],-114,[1,["407DSalc1F6r0bAkZPlzAB"]],-113,[1,["a0pLyVXJFNdrwp7zS7fDff"]]],[8,["LastNode"],-116,[1,["407DSalc1F6r0bAkZPlzAB"]],-115,[1,["98E5a6amJHAJTSW+lj3o0H"]]],[8,["TargetNode"],-118,[1,["407DSalc1F6r0bAkZPlzAB"]],-117,[1,["265nLb8WdJ4I6Xy8ecgRn/"]]],[18,["allBlock","0"],2,-119,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","1"],2,-120,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","2"],2,-121,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","3"],2,-122,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","4"],2,-123,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","5"],2,-124,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","6"],2,-125,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","7"],2,-126,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","8"],2,-127,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","9"],2,-128,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","10"],2,-129,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","11"],2,-130,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","12"],2,-131,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","13"],2,-132,[1,["407DSalc1F6r0bAkZPlzAB"]]],[18,["allBlock","14"],2,-133,[1,["407DSalc1F6r0bAkZPlzAB"]]]],[-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34]],[135,[136,0.5208,[2,0.242613,0.362617,0.798746,0.520833125],[2,0.241814,0.361945,0.798799,0],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[137,true,-0.4,200,[4,4288256409],[0,2048,2048]],[138,true,82,83],[139],[140]]],[1,["3dQrqPV2dWh7oAsEfxjxn2"]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-145,[55,"9aYRk+xQhDNpLmTC4QIqtC",null,[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,3.2,0,3.15]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],12]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-146,[55,"72vDNwq25IgK3o5TC/9YPX",null,[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,3.15]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],13]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-147,[20,"19tZ+ZsB5LVJ/N9/YIe3Qd",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-3.2,0,3.15]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],14]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-148,[20,"11yxrPL91ODZSLms/v1858",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-6.4,0,3.15]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],15]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-149,[20,"2aq6pvTJVAYaEmToEDDRbP",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,6.4,0,-0.1]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],16]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-150,[55,"29mxCJmrNG+L/2A9fTUEbZ",null,[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,3.2,0,-0.1]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],17]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-151,[20,"a2EkH/DrtLT6nkJ27/7APO",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,-0.1]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],18]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-152,[20,"1a/3V/3qdE363LHTLEf1Eh",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-3.2,0,-0.1]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],19]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-153,[20,"6a4YbJm91AkoEzjajmanqQ",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-6.4,0,-0.1]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],20]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-154,[20,"ecGH1sZOdKO54xUjYX0HrF",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,6.4,0,-3.25]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],21]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-155,[20,"48+yABtnFAULMt1DbEFn11",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,3.2,0,-3.25]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],22]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-156,[20,"8dO7stUzJH3KRD9aLhorVw",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,-3.25]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],23]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-157,[20,"b2knN3h6JFELnVNWTxqplB",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-3.2,0,-3.25]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],24]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-158,[20,"f5szHyVEFDXZcsXxr3uhTp",[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,-6.4,0,-3.25]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],25]],[116,"Canvas",33554432,"fcb53/2YFFYI1eUaZJZr4C",4,[-163,-164],[[[102,-159,[5,1080,1920]],[143,-161,-160],[144,45,5.684341886080802e-14,5.684341886080802e-14,-1.1368683772161603e-13,-1.1368683772161603e-13,-162],2],4,4,4,1],[1,540,959.9999999999999,0]],[1,["310J1oB4VW0I65S53AgmVB"]],[1,["7cmiDpNgFdRp2JHBmSvbvO"]],[1,["f1kQPBbV1UU4I52O3hjZk9"]],[1,["57eOudXfRV/Z0AvZX5sF0e"]],[117,"AudioManager",33554432,"57wcyQyC9KkLtni3cgjPNF",4,[[[142,-165],[146,-167,-166,0,1],-168],4,4,1],[1,540,960,0]],[110,"Touch",33554432,20,[[102,-169,[5,1080,1920]],[145,45,100,100,-170]]],[15,0,null,3,[12,"3dTvlTLJ1JrIW7pRkl1Lk4",-171,[55,"5fyTLBrgRK2I4Iwu3gU4nN",null,[[14,"Block",["_name"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]]],[7,["_lpos"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,6.4,0,3.15]],[7,["_lrot"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[3,0,0,0,1]],[7,["_euler"],[1,["3dTvlTLJ1JrIW7pRkl1Lk4"]],[1,0,0,0]]]],11]],[15,0,null,4,[12,"7cmiDpNgFdRp2JHBmSvbvO",-177,[20,"33H7Pk6tRD34ccZRjb+0yw",[[11,"dr5_Idle (15)",["_name"],22],[10,["_lpos"],22,[1,-6,0,7]],[10,["_lrot"],22,[3,0,1,0,6.123233995736766e-17]],[10,["_euler"],22,[1,0,180,0]],[11,1,["_clips","length"],-172],[3,["_clips","0"],-173,27],[3,["_defaultClip"],-174,28],[11,true,["playOnLoad"],-175],[10,["_lscale"],22,[1,1.413,1.413,1.413]],[11,1,["_shadowCastingMode"],1],[40,["_skinningRoot"],1,-176],[3,["_materials","0"],1,29],[3,["_materials","1"],1,30],[3,["_materials","2"],1,31],[3,["_materials","3"],1,32],[3,["_materials","4"],1,33],[3,["_materials","5"],1,34],[3,["_materials","6"],1,35],[3,["_materials","7"],1,36],[3,["_materials","8"],1,37],[3,["_materials","9"],1,38],[3,["_materials","10"],1,39],[3,["_materials","11"],1,40],[3,["_materials","12"],1,41],[3,["_materials","13"],1,42],[3,["_materials","14"],1,43],[3,["_materials","15"],1,44],[3,["_materials","16"],1,45],[3,["_materials","17"],1,46],[3,["_materials","18"],1,47],[3,["_materials","19"],1,48],[3,["_materials","20"],1,49],[3,["_materials","21"],1,50],[3,["_materials","22"],1,51],[3,["_materials","23"],1,52],[3,["_materials","24"],1,53],[3,["_materials","25"],1,54],[3,["_materials","26"],1,55],[3,["_materials","27"],1,56],[3,["_materials","28"],1,57],[3,["_materials","29"],1,58],[3,["_materials","30"],1,59],[3,["_materials","31"],1,60],[3,["_materials","32"],1,61],[3,["_materials","33"],1,62],[3,["_materials","34"],1,63],[3,["_materials","35"],1,64]]],26]],[1,["9fNk+mxD1XY4S4KXztmcSm"]],[15,0,null,4,[12,"f1kQPBbV1UU4I52O3hjZk9",-179,[20,"46mwu5dARAFIgr10+zVIg9",[[11,"dr2_Idle (12)",["_name"],23],[10,["_lpos"],23,[1,6,0,7]],[10,["_lrot"],23,[3,0,1,0,6.123233995736766e-17]],[10,["_euler"],23,[1,0,180,0]],[10,["_lscale"],23,[1,353.23,353.23,353.23]],[14,true,["playOnLoad"],[1,["c31C+m02Rfb6Hla5hcsbWk"]]],[11,1,["_shadowCastingMode"],5],[40,["_skinningRoot"],5,-178],[3,["_materials","0"],5,66],[3,["_materials","1"],5,67],[3,["_materials","2"],5,68],[3,["_materials","3"],5,69],[3,["_materials","4"],5,70],[3,["_materials","5"],5,71],[3,["_materials","6"],5,72],[3,["_materials","7"],5,73],[3,["_materials","8"],5,74]]],65]],[15,0,null,4,[12,"57eOudXfRV/Z0AvZX5sF0e",-185,[20,"45xbLNafdN4LfVDo/TVwxa",[[11,"Angry",["_name"],24],[10,["_lpos"],24,[1,0,0,4.507]],[10,["_lrot"],24,[3,0,1,0,6.123233995736766e-17]],[10,["_euler"],24,[1,0,180,0]],[11,1,["_clips","length"],-180],[3,["_clips","0"],-181,76],[3,["_defaultClip"],-182,77],[11,true,["playOnLoad"],-183],[10,["_lscale"],24,[1,1.413,1.413,1.413]],[11,1,["_shadowCastingMode"],21],[40,["_skinningRoot"],21,-184],[3,["_materials","0"],21,78],[3,["_materials","1"],21,79],[3,["_materials","2"],21,80],[3,["_materials","3"],21,81]]],75]],[1,["9duOpALmRaaIxsSHSN3rRV"]],[49,0,null,[12,"d3HR+wTY9d3ajwI/RUknzU",-192,[55,"1fbTeF5+JOuYmwFPSda5NF",null,[[14,"base02",["_name"],[1,["d3HR+wTY9d3ajwI/RUknzU"]]],[7,["_lpos"],[1,["d3HR+wTY9d3ajwI/RUknzU"]],[1,0,0,0]],[7,["_lrot"],[1,["d3HR+wTY9d3ajwI/RUknzU"]],[3,0,0,0,1]],[7,["_euler"],[1,["d3HR+wTY9d3ajwI/RUknzU"]],[1,0,0,0]],[14,"scene_5_water",["_name"],[1,["f1mlFV+TxaK61a2VYDsNZx"]]],[7,["_lpos"],[1,["f1mlFV+TxaK61a2VYDsNZx"]],[1,0,0.39543023705482483,0]],[10,["_lscale"],-186,[1,43.68426513671875,42.35599136352539,61.73048782348633]],[3,["_materials","0"],-187,7],[3,["_materials","0"],-188,8],[11,1,["_shadowCastingMode"],-189],[11,1,["_shadowCastingMode"],-190],[11,true,["_active"],-191],[14,true,["_active"],[1,["ecmbjnlWNU7Kez1hbjkPDz"]]]]],6]],[111,"Main Light","c0y6F5f+pAvI805TdmxIjx",4,[[147,8407,80000,-193,[148,true]]],[1,0,50,0],[3,-0.16107121228906487,-0.7318134431404912,-0.6357073716043089,0.18542191536744265],[1,-81.96,-151.564,0]],[149,false,25],[118,"Camera",20,[-194],[1,0,0,1000]],[150,0,1073741824,960,2000,6,41943040,36,[4,4278190080]],[151,90,14,1822425087],[119,"Main Camera",[38],[1,0,16.846,-15.657],[3,-2.5898727647784768e-17,0.9061491375088953,0.42295832015919155,5.548563204002017e-17],[1,-50.043,180,0]],[90,"CamNode","b2ycwXR/VLCr0VfdWlaDaC",4,[39]],[127,[1,50,0.2,50]],[120,"rayPlane",2,"e1/QkUqQZBzIwPzmrAUE6q",4,[41]],[112,"RootNode","c1lsxdsCFPKJmWshAbo2+5",4],[90,"Map","f3WiVAu/lGz4P3S3LUZsEy",4,[-195]],[91,"Map_1",44,[-196]],[91,"mesh",45,[33]],[1,["f1mlFV+TxaK61a2VYDsNZx"]],[1,["3fiVjDW+ZZSJGoux7vnjVa"]],[1,["37XU08uu5ZmaWtIyZ24F7M"]],[113,"Floor_Player","56bjXq1KNG+7NfQP5fd0AA",4,[[129,"Plane<ModelComponent>",1,-197,[9],[21],10]],[1,0,0.28,-4.75],[1,1.678,1.678,1.678]]],0,[0,-1,27,0,-2,6,0,-3,7,0,-4,8,0,-5,9,0,-6,10,0,-7,11,0,-8,12,0,-9,13,0,-10,14,0,-11,15,0,-12,16,0,-13,17,0,-14,18,0,-15,19,0,-1,33,0,-2,27,0,-3,6,0,-4,7,0,-5,8,0,-6,9,0,-7,10,0,-8,11,0,-9,12,0,-10,13,0,-11,14,0,-12,15,0,-13,16,0,-14,17,0,-15,18,0,-16,19,0,-17,28,0,-18,30,0,-19,31,0,2,6,0,5,6,0,2,6,0,5,6,0,2,6,0,5,6,0,2,7,0,5,7,0,2,7,0,5,7,0,2,7,0,5,7,0,2,8,0,5,8,0,2,8,0,5,8,0,2,8,0,5,8,0,2,9,0,5,9,0,2,9,0,5,9,0,2,9,0,5,9,0,2,10,0,5,10,0,2,10,0,5,10,0,2,10,0,5,10,0,2,11,0,5,11,0,2,11,0,5,11,0,2,11,0,5,11,0,2,12,0,5,12,0,2,12,0,5,12,0,2,12,0,5,12,0,2,13,0,5,13,0,2,13,0,5,13,0,2,13,0,5,13,0,2,14,0,5,14,0,2,14,0,5,14,0,2,14,0,5,14,0,2,15,0,5,15,0,2,15,0,5,15,0,2,15,0,5,15,0,2,16,0,5,16,0,2,16,0,5,16,0,2,16,0,5,16,0,2,17,0,5,17,0,2,17,0,5,17,0,2,17,0,5,17,0,2,18,0,5,18,0,2,18,0,5,18,0,2,18,0,5,18,0,2,19,0,5,19,0,2,19,0,5,19,0,2,19,0,5,19,0,2,27,0,2,6,0,2,7,0,2,8,0,2,9,0,2,10,0,2,11,0,2,12,0,2,13,0,2,14,0,2,15,0,2,16,0,2,17,0,2,18,0,2,19,0,-1,34,0,-2,25,0,-3,20,0,-4,44,0,-5,40,0,-6,50,0,-8,42,0,-9,43,0,-10,28,0,-11,30,0,-12,31,0,3,6,0,3,7,0,3,8,0,3,9,0,3,10,0,3,11,0,3,12,0,3,13,0,3,14,0,3,15,0,3,16,0,3,17,0,3,18,0,3,19,0,7,20,0,30,37,0,7,20,0,7,20,0,-1,36,0,-2,26,0,7,25,0,31,35,0,7,25,0,-3,35,0,7,26,0,7,26,0,3,27,0,4,29,0,4,29,0,4,29,0,4,29,0,1,28,0,3,28,0,1,30,0,3,30,0,4,32,0,4,32,0,4,32,0,4,32,0,1,31,0,3,31,0,4,47,0,4,48,0,4,49,0,4,49,0,4,48,0,4,47,0,3,33,0,7,34,0,-1,37,0,-1,45,0,-1,46,0,7,50,0,32,4,2,33,43,2,34,41,2,35,26,2,36,38,2,7,20,3,0,4,33,0,46,38,7,39,39,0,40,41,7,42,197],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],[37,38,-1,-2,-1,-2,8,1,1,-1,14,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,8,1,1,1,1,1,1,1,1,1,8,1,1,1,1,1,1,39,40,41,42],[40,41,42,43,44,45,46,47,48,49,50,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,51,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,52,53,7,7,7,7,7,7,7,54,55,19,19,20,20,56,20,57,58,59,60]],[[[22,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[22,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[57,[[58,[59,[-16,-17,-18,-19,-20,-21,-22],[[60,-5,-4],[23,0,false,-7,-6,[[61,"Victory"]]],[37,0.1,-9,-8],[23,0.1,false,-11,-10,[[62,[38,"Fail"]]]],[23,0.1,false,-13,-12,[[63,1,[38,"Fail"]]]],[37,0,-15,-14]],-3,-2,-1]]],[{},"Victory",4,[64,2],"Fail",4,[65,1,false]]],[24,"Idle",[19,0]],[25,"Entry"],[24,"Jump",[19,1]],[66,"Fail",2,[19,2]],[24,"Victory",[19,3]],[25,"Exit"],[25,"Any"]],0,[0,17,7,0,18,6,0,19,2,0,9,1,0,10,2,0,9,5,0,10,1,0,9,1,0,10,5,0,9,4,0,10,1,0,9,3,0,10,4,0,9,1,0,10,3,0,-1,2,0,-2,6,0,-3,7,0,-4,1,0,-5,3,0,-6,4,0,-7,5,22],[0,0,0,0],[13,13,13,13],[27,61,62,63]],[[[44,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,3053416448]]],11]]],0,0,[0],[6],[12]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[64,4]],[[[56,"builtin-standard",[{"hash":4079105024,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":["HAS_SECOND_UV"]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":7,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out lowp vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out mediump vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 6) in mediump vec2 v_uv1;\n#endif\nlayout(location = 4) in mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 7) in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 2) in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 8) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout mediump vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying mediump vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(normalBias > EPSILON_LOWP)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > EPSILON) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > EPSILON) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\nfloat CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n{\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n  }else {\n    return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n  }\n}\nfloat CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n{\n  float realtimeShadow = 1.0;\n  vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n  float pcf = cc_shadowWHPBInfo.z;\n  if (pcf > 1.9) {\n    realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n  }else if (pcf > 0.9) {\n    realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n  }else {\n    realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n  }\n  return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n}\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse / PI;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > EPSILON_LOWP) {\n      finalColor = diffuse * s.lightmap.rgb * shadow;\n    }\n  #endif\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = lightColor.xyz * v_luv.z;\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":223,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":3928335406,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":["HAS_SECOND_UV"]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) out vec2 v_uv1;\n#endif\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\n#if HAS_SECOND_UV\n  layout(location = 1) in vec2 v_uv1;\n#endif\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":184,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":75}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[44,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainColor",8,[4,4285558896],"mainTexture",6,0]],11]]],0,0,[0,0],[11,6],[65,12]],[[[26,"Naruto:nr2_eye_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[26,"Naruto:nr2_tex01_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[41,"Skin-0",869035308,["Hips/LeftUpLeg","Hips/LeftUpLeg/LeftLeg","Hips/RightUpLeg","Hips/RightUpLeg/RightLeg","Hips","Hips/RightUpLeg/RightLeg/RightFoot","Hips/RightUpLeg/RightLeg/RightFoot/RightToeBase","Hips/LeftUpLeg/LeftLeg/LeftFoot","Hips/LeftUpLeg/LeftLeg/LeftFoot/LeftToeBase","Hips/Spine/Spine1/Spine2","Hips/Spine/Spine1/Spine2/Neck","Hips/Spine/Spine1/Spine2/Neck/Head","Hips/Spine/Spine1","Hips/Spine","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm","Hips/Spine/Spine1/Spine2/LeftShoulder","Hips/Spine/Spine1/Spine2/RightShoulder","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandThumb1","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandMiddle1","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandRing1","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandMiddle1","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandPinky1","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandIndex1","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2/mixamorig:LeftHandMiddle3","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2/mixamorig:LeftHandPinky3","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandThumb1","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandRing1","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandIndex1","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandPinky1","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2/mixamorig:RightHandMiddle3","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2/mixamorig:RightHandRing3","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2","Hips/Spine/Spine1/Spine2/RightShoulder/RightArm/RightForeArm/RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2/mixamorig:RightHandPinky3","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3","Hips/Spine/Spine1/Spine2/LeftShoulder/LeftArm/LeftForeArm/LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2/mixamorig:LeftHandRing3"],[[[7,-1,1.2243259065074973e-16,2.805237256890631e-18,0,-1.2246468525851679e-16,-0.9997379779815674,-0.022906500846147537,0,-2.0053276082875734e-33,-0.022906500846147537,0.9997379779815674,0,0.0014123499859124422,0.009094909764826298,0.0005292959976941347,1],[7,-0.9933650493621826,-0.11417999863624573,0.013763700611889362,0,0.1149764284491539,-0.9887080192565918,0.09610959887504578,0,0.0026344857178628445,0.09705435484647751,0.9952759742736816,0,0.0007892551948316395,0.005487539805471897,-0.0001283590099774301,1],[7,-1,1.2243419207241563e-16,2.734109650378421e-18,0,-1.2246468525851679e-16,-0.9997509717941284,-0.022325700148940086,0,-7.70371794083902e-34,-0.022325700148940086,0.9997509717941284,0,-0.0014124000445008278,0.009095369838178158,0.0005174609832465649,1],[7,-0.9933670163154602,0.11423999816179276,-0.013062500394880772,0,-0.11495566368103027,-0.9892269968986511,0.09063909947872162,0,-0.002567166229709983,0.09153955429792404,0.9957979917526245,0,-0.0007893688743934035,0.005487360060214996,-0.00010660400585038587,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,2.5033999762058556e-8,-0.009572059847414494,0.0001900450006360188,1],[7,-0.9856969714164734,-0.010900569148361683,-0.16817200183868408,0,-0.12435759603977203,-0.6264291405677795,0.7694940567016602,0,-0.11373578011989594,0.7794018983840942,0.6161139011383057,0,-0.0007725273026153445,0.0006893652025610209,-0.0010049401316791773,1],[7,-0.9992300271987915,-0.03163430094718933,-0.023220699280500412,0,-0.02256104163825512,-0.021052401512861252,0.9995239973068237,0,-0.032108087092638016,0.9992780089378357,0.020322483032941818,0,-0.0008974270313046873,-0.0013351800153031945,-0.00010178497905144468,1],[7,-0.9854569435119629,0.01093978714197874,0.16957199573516846,0,0.12509429454803467,-0.6286800503730774,0.767536997795105,0,0.11500318348407745,0.7775869369506836,0.6181689500808716,0,0.0007697096443735063,0.0006800670525990427,-0.0010133800096809864,1],[7,-0.9992600083351135,0.031233999878168106,0.022446496412158012,0,0.021803218871355057,-0.020786000415682793,0.9995459914207458,0,0.03168639540672302,0.9992960095405579,0.020089613273739815,0,0.0008977639954537153,-0.0013421999756246805,-0.00010089988063555211,1],[7,1,0,0,0,0,0.9996950030326843,-0.024691900238394737,0,0,0.024691900238394737,0.9996950030326843,0,2.5033999762058556e-8,-0.012510010041296482,0.0004263400041963905,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,2.5033999762058556e-8,-0.013778720051050186,0.00008614319813204929,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,2.5033999762058556e-8,-0.0145982401445508,0.000054944801377132535,1],[7,1,0,0,0,0,0.9996950030326843,-0.024691900238394737,0,0,0.024691900238394737,0.9996950030326843,0,2.5033999762058556e-8,-0.011387890204787254,0.0004263400041963905,1],[7,1,0,0,0,0,0.9996950030326843,-0.024691900238394737,0,0,0.024691900238394737,0.9996950030326843,0,2.5033999762058556e-8,-0.010406039655208588,0.0004263400041963905,1],[7,0.031336355954408646,0.9995070099830627,0.0017633407842367887,0,0.016141099855303764,0.0012579259928315878,-0.9998689889907837,0,-0.9993789792060852,0.0313606895506382,-0.016093723475933075,0,-0.00034894709824584424,-0.0015938002616167068,0.013157131150364876,1],[7,0.009041469544172287,0.9326688647270203,-0.36062130331993103,0,0.024772273376584053,-0.36073431372642517,-0.9323399066925049,0,-0.9996520280838013,-0.0005036871298216283,-0.02636590041220188,0,-0.00042733963346108794,0.004408114589750767,0.012840178795158863,1],[7,0.010123028419911861,-0.9326689839363098,0.36059221625328064,0,-0.02477705106139183,-0.3607339560985565,-0.9323399066925049,0,0.999642014503479,0.0005036908551119268,-0.02676049992442131,0,0.0004273997328709811,0.004408159758895636,0.012840159237384796,1],[7,0.037015534937381744,-0.9993129968643188,-0.0017906238790601492,0,-0.014363734051585197,0.0012596212327480316,-0.9998959898948669,0,0.9992110133171082,0.03703742101788521,-0.014307248406112194,0,0.00033280334901064634,-0.0015931384405121207,0.013157617300748825,1],[7,0.012957976199686527,-0.9981220364570618,-0.05987312272191048,0,-0.014329243451356888,0.05968666449189186,-0.9981140494346619,0,0.9998130202293396,0.01379148568958044,-0.013528915122151375,0,0.00025499818730168045,-0.003995266743004322,0.012947394512593746,1],[7,0.01961352489888668,0.9980059862136841,0.05999288335442543,0,0.016125217080116272,0.05968087166547775,-0.9980869889259338,0,-0.9996780157089233,0.020543398335576057,-0.01492250245064497,0,-0.00031105030211620033,-0.003994378261268139,0.012946460396051407,1],[7,-0.04143322631716728,0.9990879893302917,-0.010291062295436859,0,-0.08347813785076141,-0.01372544839978218,-0.9964150190353394,0,-0.9956479668617249,-0.04042559489607811,0.08397070318460464,0,0.0014012906467542052,-0.0060830493457615376,0.0133623406291008,1],[7,0.6707639694213867,0.692435085773468,-0.26572325825691223,0,-0.06915771216154099,-0.29832175374031067,-0.9519563317298889,0,-0.7384390830993652,0.6569150686264038,-0.15221628546714783,0,-0.0032450335565954447,-0.0007249468471854925,0.014377688989043236,1],[7,0.033884014934301376,0.9993370175361633,0.0133074214681983,0,-0.08427438139915466,0.016124587506055832,-0.9963120222091675,0,-0.9958660006523132,0.0326375849545002,0.08476490527391434,0,0.0009813676588237286,-0.0072861323133111,0.013203918002545834,1],[7,0.06455573439598083,0.9977160096168518,-0.019905345514416695,0,-0.08446195721626282,-0.014412575401365757,-0.996321976184845,0,-0.994333028793335,0.06599961966276169,0.08333858102560043,0,0.0005294239381328225,-0.007044956088066101,0.01344395149499178,1],[7,-0.02210858091711998,-0.99965900182724,0.013919880613684654,0,0.08173703402280807,-0.01568402722477913,-0.9965310096740723,0,0.996408998966217,-0.020894106477499008,0.08205589652061462,0,-0.0012471990194171667,-0.006061270833015442,0.013387490063905716,1],[7,-0.02413352206349373,-0.9988610148429871,0.04114896431565285,0,0.08170506358146667,-0.04299395531415939,-0.9957290291786194,0,0.9963639974594116,-0.020668361335992813,0.08264968544244766,0,-0.001376938889734447,-0.0065032001584768295,0.01359193492680788,1],[7,0.06455577909946442,0.9978989958763123,0.005485921166837215,0,-0.08446196466684341,0.01094148587435484,-0.9963669776916504,0,-0.994333028793335,0.06385789066553116,0.08499090373516083,0,0.000529238663148135,-0.0076652709394693375,0.013253219425678253,1],[7,0.008816016837954521,0.9989890456199646,-0.04408395662903786,0,-0.08406230062246323,-0.04318922385573387,-0.9955240488052368,0,-0.9964219927787781,0.012482351623475552,0.08359650522470474,0,0.0007625507423654199,-0.00668801786378026,0.01358642615377903,1],[7,0.053654834628105164,0.9976119995117188,-0.043483566492795944,0,-0.08440440893173218,-0.03885948285460472,-0.9956740140914917,0,-0.9949859976768494,0.05709288269281387,0.08211791515350342,0,0.0010349799413233995,-0.006554362829774618,0.013579288497567177,1],[7,0.05365476757287979,0.997963011264801,-0.034508999437093735,0,-0.08440440893173218,-0.029902571812272072,-0.9959830045700073,0,-0.9949859976768494,0.056351929903030396,0.08262808620929718,0,0.0010349403601139784,-0.006995724979788065,0.01351691223680973,1],[7,0.008815971203148365,0.9990659952163696,-0.042298682034015656,0,-0.08406229317188263,-0.04141011834144592,-0.9955999851226807,0,-0.9964219927787781,0.01233289297670126,0.08361870050430298,0,0.0007624168647453189,-0.006916601210832596,0.013574089854955673,1],[7,0.033884063363075256,0.9991059899330139,-0.025269996374845505,0,-0.08427443355321884,-0.022338174283504486,-0.9961920380592346,0,-0.9958660006523132,0.03588465601205826,0.08344221860170364,0,0.0009813469368964434,-0.007133597042411566,0.01348927617073059,1],[7,0.033883992582559586,0.9954189658164978,0.08940804749727249,0,-0.08427437394857407,0.09198655933141708,-0.9921879768371582,0,-0.9958660006523132,0.026084495708346367,0.08700519800186157,0,0.0009812497301027179,-0.008979720994830132,0.012542729265987873,1],[7,0.6707644462585449,0.7159050703048706,-0.19379112124443054,0,-0.06915771961212158,-0.19977864623069763,-0.9773969650268555,0,-0.738438606262207,0.6690060496330261,-0.08449400961399078,0,-0.0032294366974383593,-0.0024608951061964035,0.014200860634446144,1],[7,0.6707645654678345,0.7416679859161377,-0.0018106080824509263,0,-0.06915795803070068,0.0601155124604702,-0.9957929849624634,0,-0.7384384870529175,0.668067991733551,0.09161563962697983,0,-0.003215504577383399,-0.00635279156267643,0.012999249622225761,1],[7,0.00881598424166441,0.9721410870552063,0.2342311441898346,0,-0.08406232297420502,0.2341315895318985,-0.968563973903656,0,-0.9964219927787781,-0.011151164770126343,0.08378449827432632,0,0.0007623692508786917,-0.010545264929533005,0.011101008392870426,1],[7,0.7238226532936096,-0.6426010727882385,0.25128546357154846,0,0.06665932387113571,-0.297359824180603,-0.9524352550506592,0,0.6867583394050598,0.7061450481414795,-0.17240040004253387,0,0.0036328965798020363,-0.0004155526403337717,0.014292409643530846,1],[7,0.7238222360610962,-0.6686059832572937,0.17043174803256989,0,0.06665964424610138,-0.17809012532234192,-0.9817540645599365,0,0.6867586970329285,0.7219759821891785,-0.08433662354946136,0,0.003628149861469865,-0.002439258387312293,0.014099539257586002,1],[7,0.7238224148750305,-0.6886669993400574,0.042649563401937485,0,0.06665948778390884,0.008271617814898491,-0.9977409839630127,0,0.6867585778236389,0.7250310182571411,0.051893338561058044,0,0.003640363458544016,-0.005340760573744774,0.01333709992468357,1],[7,0.061531323939561844,-0.9979410171508789,-0.01808173581957817,0,0.08276207000017166,0.023154962807893753,-0.9962999820709229,0,0.9946680068969727,0.05980717018246651,0.08401641994714737,0,-0.000531195430085063,-0.007529094815254211,0.013157747685909271,1],[7,0.021692480891942978,-0.9982979893684387,0.05413610488176346,0,0.08234549313783646,-0.052180785685777664,-0.9952369928359985,0,0.9963679909706116,0.02604701556265354,0.08107339590787888,0,-0.001245170016773045,-0.006424997467547655,0.013649041764438152,1],[7,0.021692495793104172,-0.9996089935302734,0.01766974851489067,0,0.08234559744596481,-0.015827443450689316,-0.9964780211448669,0,0.9963679909706116,0.023071128875017166,0.08196999132633209,0,-0.0012451413786038756,-0.007219955325126648,0.01339449267834425,1],[7,0.021692462265491486,-0.9985549449920654,0.04915933310985565,0,0.08234553784132004,-0.04721926152706146,-0.9954849481582642,0,0.9963679909706116,0.025642545893788338,0.08120228350162506,0,-0.0012452307855710387,-0.007076042238622904,0.013624223880469799,1],[7,-0.024133548140525818,-0.9995759725570679,-0.01631169021129608,0,0.08170510083436966,0.014289716258645058,-0.9965540170669556,0,0.9963639974594116,-0.025383150205016136,0.08132558315992355,0,-0.0013767896452918649,-0.007640487980097532,0.013174695894122124,1],[7,0.02129792980849743,-0.9991129636764526,0.03633259981870651,0,0.0823407992720604,-0.03446446731686592,-0.9960079789161682,0,0.9963769912719727,0.024204563349485397,0.08153367787599564,0,-0.0006456444971263409,-0.006805559620261192,0.013535954989492893,1],[7,-0.024133533239364624,-0.9996830224990845,0.00720601063221693,0,0.08170513808727264,-0.009156359359622002,-0.9966139793395996,0,0.9963639974594116,-0.023463072255253792,0.08190017938613892,0,-0.0013769299257546663,-0.007671041879802942,0.013358843512833118,1],[7,0.06153128668665886,-0.9981030225753784,0.00205004820600152,0,0.08276200294494629,0.0030552425887435675,-0.9965649843215942,0,0.9946680068969727,0.061489563435316086,0.08279302716255188,0,-0.0005313128349371254,-0.007543885614722967,0.013312616385519505,1],[7,0.06153126806020737,-0.9969779849052429,0.04742133617401123,0,0.08276209980249405,-0.04225139692425728,-0.9956730008125305,0,0.9946680068969727,0.06518972665071487,0.07991218566894531,0,-0.0005313262809067965,-0.007200345862656832,0.013654051348567009,1],[7,0.021297989413142204,-0.9997109770774841,0.01114631537348032,0,0.08234082907438278,-0.009356989525258541,-0.9965599775314331,0,0.9963769912719727,0.022142518311738968,0.08211769163608551,0,-0.0006453325040638447,-0.007350467145442963,0.013354991562664509,1],[7,0.021297961473464966,-0.9630520343780518,-0.26847052574157715,0,0.08234081417322159,0.26930877566337585,-0.9595271348953247,0,0.9963769912719727,-0.0016701101558282971,0.08503419905900955,0,-0.0006451745284721255,-0.010946777649223804,0.010724714957177639,1],[7,0.053654786199331284,0.9980430006980896,0.03211278095841408,0,-0.08440443873405457,0.036576904356479645,-0.9957600235939026,0,-0.9949859976768494,0.0507168248295784,0.08620178699493408,0,0.0010349205695092678,-0.008186656050384045,0.012999952770769596,1],[7,0.06455574929714203,0.9726019501686096,0.22333507239818573,0,-0.08446191996335983,0.22832413017749786,-0.969914972782135,0,-0.994333028793335,0.04375028610229492,0.09688750654459,0,0.0005291012930683792,-0.010634911246597767,0.011200618930161,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[29],[50,"dy9_Idle (8)",[-3,-4],[[42,-2,[9,"621cm+QdtYmLkzM73OiANB"],[10,11],12]],[0,"83yUSPz3FcdI0CjesUc20L",-1,0]],[27,"LeftHand",[-5,-6,-7,-8,-9],[0,"cfEENEQd9ZUaHmIjYSRFJi",1,0],[1,3.4498712480485194e-12,0.0030633655842393637,-1.859687967856183e-12],[3,0.03564692752109307,-0.049090967834716344,-0.031717744533773684,0.9976539270293316],[1,3.908579124913924,-5.503378140977815,-3.829437830855725]],[27,"RightHand",[-10,-11,-12,-13,-14],[0,"b5L8YUfBNeVpJz9AFs31n5",1,0],[1,1.4263819075530093e-12,0.003063010284677148,-3.211120171847659e-12],[3,0.03708251572959194,0.04765525469578787,0.01861389916311313,0.9980016966343241],[1,4.146251732876961,5.383248542719535,2.33188059324421]],[34,"Hips",1,[-15,-16,-17],[0,"07E6MYBzJQ1K2NvAVaRbA1",1,0],[1,-2.5033950024067053e-8,0.009572057984769344,-0.00019004542264156044]],[51,"Spine2",[-18,-19,-20],[0,"20OYB854heK4QtIXzxWCTH",1,0],[1,0,0.0011221182066947222,1.432975239119491e-13]],[35,"Naruto:Mesh",1,[-21],[0,"38304+2r1S+73oY83J8Cxt",1,0]],[52,"polySurface5",6,[[43,-22,[9,"25MrXno3JXhbNggrPkHUh1"],[0,1,2,3,4,5,6,7],[21],1,8,9]],[0,"7d1JEXfrRVr59tvUa49V0g",1,0]],[2,"Spine",4,[-23],[0,"27aCdgBONd1aaMKOghRk1X",1,0],[1,0,0.0008413320756517351,0.00002078045145026408],[3,0.01234689272328505,0,0,0.9999237742148547],[1,1.4148856367289173,0,0]],[34,"Spine1",8,[5],[0,"f44bBRzEpYo5Yi8yjSHt5L",1,0],[1,0,0.0009818542748689651,1.1485723396681413e-12]],[2,"Neck",5,[-24],[0,"8drWOhzctXY5Hp+X8UUhRE",1,0],[1,0,0.0012623833026736975,-1.4180351337600428e-11],[3,-0.012346910415716564,0,0,0.9999237739963912],[1,-1.41488766428678,0,0]],[53,"Head",10,[[6,"HeadTop_End",-25,[0,"3dAAk8jkxYUJhBgT+qZt63",1,0],[1,0,0.002414785558357835,0.00009192890138365328]]],[0,"9fNtI/B19QY5xF4eGqFtiH",1,0],[1,0,0.0008195185801014304,0.00003119839311693795]],[2,"LeftShoulder",5,[-26],[0,"f399ffR9NdMbuQcZ68HODu",1,0],[1,0.0005230149836279452,0.0010558745125308633,0.000004814936801267322],[3,0.585878423006517,0.3980134963876021,-0.5805725964221546,0.4015808641262069],[1,111.139268306653,89.4819569336938,0.004660970378202287]],[2,"LeftArm",12,[-27],[0,"a2PpZpWEdcFoXSDiwwD8fy",1,0],[1,-6.833749603522843e-13,0.00113412004429847,2.5666541808577747e-11],[3,-0.18436988008460567,-0.0022041926065864167,0.011749454971761844,0.9827842281805338],[1,-21.25033064289411,-1.4376419040294734e-8,1.3699082531791638]],[2,"LeftForeArm",13,[2],[0,"c4hsXSHGBebYuypNGDl240",1,0],[1,-1.1923526402335405e-12,0.0016358766006305814,5.94280213147419e-14],[3,-0.029133472705542316,0.00017082205225444982,-0.005860847909566034,0.9995583334902085],[1,-3.3389799061902976,-2.8275101334802186e-8,-0.6718927544792016]],[2,"mixamorig:LeftHandThumb1",2,[-28],[0,"e6VLp+LMReRavXjlGx1ngd",1,0],[1,-0.00024108450452331454,0.00021748174913227558,0.00011924008867936209],[3,0.16230224057180634,0.06640551977865032,0.3728095885473115,0.9111867538191516],[1,20.19941002268103,-2.4503921098814045e-7,44.50358144983923]],[2,"mixamorig:LeftHandThumb2",15,[-29],[0,"9d8jweE2hS/7puta/F4J6W",1,0],[1,-0.000015598567188135348,0.00027627049712464213,-3.63832054761648e-12],[3,-0.05100944245585786,-1.8838637242405e-9,5.5839266323514e-10,0.9986981710108128],[1,-5.847789363614592,-2.1232990340272593e-7,7.491544291348862e-8]],[4,"mixamorig:LeftHandThumb3",16,[[6,"mixamorig:LeftHandThumb4",-30,[0,"59TlhbjSRYjKIj2PFIL99H",1,0],[1,0.00002953562216134742,0.000259942578850314,-1.396838238609463e-13]]],[0,"f3jgwcRT9YyIyjdfkj1kkg",1,0],[1,-0.000013937009498476982,0.00030930599314160645,1.6903878470586609e-12],[3,-0.13058480695563696,-1.9538144548155056e-9,2.0821543220663267e-10,0.9914371428347634],[1,-15.00677473890672,-2.1885778245099432e-7,5.289214010283084e-8]],[2,"mixamorig:LeftHandIndex1",2,[-31],[0,"f0VwLHjpFZN7MrMhgCc7qC",1,0],[1,-0.0002941371640190482,0.000789203739259392,0.000008483104465994984],[3,0.016607553006364933,0.0007905366478901909,0.047540814370242775,0.9987309123101993],[1,1.9053280568564375,-3.691709333416885e-7,5.450584221547244]],[2,"mixamorig:LeftHandIndex2",18,[-32],[0,"68msoRAkdTH4C39rPfVgQm",1,0],[1,3.951938509771935e-8,0.0003195037425030023,-3.995847977587147e-13],[3,-0.004497470885809337,-3.192380865178262e-9,6.557430418563072e-11,0.9999898863266724],[1,-0.5153739379220655,-3.657824053896615e-7,9.15945010315489e-9]],[4,"mixamorig:LeftHandIndex3",19,[[6,"mixamorig:LeftHandIndex4",-33,[0,"3d0miOCnpQpo1VNwOQHhfX",1,0],[1,-6.437134913994669e-8,0.00026087541482411325,1.2097278474093587e-12]]],[0,"42Z2VRnulYLqdmd+Epgtko",1,0],[1,2.4848350932415997e-8,0.0003058624279219657,2.0339952595468946e-13],[3,-0.03335892862494627,-3.192574948540489e-9,-5.5315666583889076e-11,0.9994434360587876],[1,-3.8233609798491153,-3.658499786409698e-7,5.868921282462494e-9]],[2,"mixamorig:LeftHandMiddle1",2,[-34],[0,"b6MCm92m1e2YOMBrul5HuH",1,0],[1,-0.00010209199535893276,0.0007956533809192479,-0.000009926237908075564],[3,-0.011797546735384657,-0.00044462481812106565,0.037658234237150964,0.9992209353260856],[1,-1.3528904337975514,-4.192476140507137e-7,4.316637362190032]],[2,"mixamorig:LeftHandMiddle2",21,[-35],[0,"08d1JVyc1eLI00E/SjTX06",1,0],[1,2.035252144594324e-8,0.0003627414698712528,1.7324142608746845e-13],[3,0.019300287524141237,-3.662776514134589e-9,-4.203287356721776e-11,0.999813732102878],[1,2.2117873670772283,-4.195521281416368e-7,-1.2916495145304992e-8]],[4,"mixamorig:LeftHandMiddle3",22,[[6,"mixamorig:LeftHandMiddle4",-36,[0,"09jEDaJBdUdY2OU8ZDIMs1",1,0],[1,-1.1730184468206062e-7,0.00031374464742839336,-2.777200669955293e-13]]],[0,"71o+FV8LBXBZ6E/3o7AomD",1,0],[1,9.694686298189481e-8,0.00034938298631459475,-4.990230234244719e-13],[3,-0.0574018358359357,-3.6585114884961755e-9,-1.8163716338214039e-10,0.9983511552768717],[1,-6.581383483652303,-4.1973804926291716e-7,3.285065431638298e-9]],[2,"mixamorig:LeftHandRing1",2,[-37],[0,"8eDhmNFLhSnbjQLWd1hlXG",1,0],[1,0.00011543375148903579,0.0009947671787813306,-0.000013108773600833956],[3,0.0048108560874709225,0.00025533532065433553,0.053000240393118854,0.9985828783760772],[1,0.5520615913084844,-3.514423474302211e-7,6.076297734485173]],[2,"mixamorig:LeftHandRing2",24,[-38],[0,"6daKU1yJ5elZaCyYQ0bex2",1,0],[1,1.8555819281118602e-7,0.00028063205536454916,-5.2045034812852817e-14],[3,-0.012722333101214137,-3.0556268961174e-9,-3.567673279247213e-11,0.9999190678452241],[1,-1.4579113153652612,-3.5017272362051526e-7,3.667912864194796e-10]],[4,"mixamorig:LeftHandRing3",25,[[6,"mixamorig:LeftHandRing4",-39,[0,"90HzxWwXtWHI/ZKiCyHRjl",1,0],[1,-3.224206750473968e-7,0.0002145707985619083,1.1753087652416339e-12]]],[0,"62iQMFqftaZag5Mbie3yA+",1,0],[1,1.3686349120689556e-7,0.00026614146190695465,-7.873701826166882e-14],[3,-0.10988569296968796,-3.0282338961572493e-9,-4.097897590746347e-10,0.9939442310716288],[1,-12.617452628592163,-3.5006869214826897e-7,-8.54263878815349e-9]],[2,"mixamorig:LeftHandPinky1",2,[-40],[0,"85aKn/uTdZObyZF1l+Lro2",1,0],[1,0.0002807954151649028,0.001013055327348411,0.000009745387615112122],[3,0.016898331772241888,0.00042477365530516347,0.025125648244325394,0.9995413787087353],[1,1.9371101369663999,-3.092104608406329e-7,2.879901781376042]],[2,"mixamorig:LeftHandPinky2",27,[-41],[0,"48oHQXJFpaQL4CJ3GZbeU1",1,0],[1,1.3420375921668892e-7,0.000204318537726067,-1.4958923043404543e-13],[3,-0.0008937757388657763,-2.70133742413393e-9,6.269022218668136e-11,0.9999996005823845],[1,-0.1024191689723986,-3.0954392256771726e-7,7.460436124002452e-9]],[4,"mixamorig:LeftHandPinky3",28,[[6,"mixamorig:LeftHandPinky4",-42,[0,"42/jfHcThYwb5APIlr4VYO",1,0],[1,-1.8197889062321337e-7,0.00013350651715882123,5.701972097607588e-13]]],[0,"2c8ugNT/Ba1qAUdyUmMirQ",1,0],[1,4.7774737055306105e-8,0.0001671285426709801,2.176170349607251e-13],[3,-0.13892419341185108,-2.6835706419943867e-9,-3.15597430369718e-10,0.9903030185174974],[1,-15.971197495473316,-3.0955674667598155e-7,6.907097775668516e-9]],[2,"RightShoulder",5,[-43],[0,"6cRzFpTVBXG7GdrsYSkFw3",1,0],[1,-0.0005230149836279452,0.0010558887152001262,0.000005385998974816175],[3,0.5861880140026661,-0.39780541961325117,0.5802493648688738,0.4018023580508255],[1,111.1377506358946,-89.4199823144924,-0.004951022368533307]],[2,"RightArm",30,[-44],[0,"e8FwcKZT9Y4I1DA11bL4NU",1,0],[1,6.858613611944453e-13,0.00113412004429847,2.5666474154362184e-11],[3,-0.1843982891152373,0.0026594364849601626,-0.014173399320355785,0.9827458029015751],[1,-21.254342557852613,-6.2127905318257e-8,-1.6525527905158324]],[2,"RightForeArm",31,[3],[0,"39MGus0oBfoq8QPx3jYMYw",1,0],[1,2.399892784499258e-12,0.0016361946472898126,5.0079938704013574e-14],[3,-0.029056642238495616,-0.0003496510038980768,0.012027475065644179,0.9995053422216137],[1,-3.3303558076332935,-7.214973037458392e-10,1.3788626649173608]],[2,"mixamorig:RightHandThumb1",3,[-45],[0,"2e/o5n3GVTBpSwXlV/nQPI",1,0],[1,0.00024059943098109215,0.0002113492228090763,0.00011781712964875624],[3,0.16044035306260765,-0.07083581278647583,-0.3976344404826669,0.9006264666764249],[1,20.20176924823191,3.8045146041552964e-7,-47.64375321384744]],[2,"mixamorig:RightHandThumb2",33,[-46],[0,"59+gRzX/pX/rOrzdc6wBxu",1,0],[1,0.0000047364510464831255,0.00027294238680042326,9.079736745451483e-13],[3,-0.06154722455337948,5.92817805205932e-9,-1.9909232388443004e-9,0.9981041724939216],[1,-7.05725275718923,6.639897248930576e-7,-2.6952068727210684e-7]],[4,"mixamorig:RightHandThumb3",34,[[6,"mixamorig:RightHandThumb4",-47,[0,"58kVdIJx9SJafIGX2tCnPe",1,0],[1,0.000007478370662283851,0.0002821593952830881,-1.304072409953616e-12]]],[0,"5bWuvZqapVS5+DOJjfeiaP",1,0],[1,-0.000012214837624924257,0.00031844835029914975,-5.982436768192656e-13],[3,-0.09373173935579755,6.164945935059051e-9,-1.0490534078615362e-9,0.9955974894691814],[1,-10.756656211662367,6.920728668428529e-7,-1.859002870501186e-7]],[2,"mixamorig:RightHandIndex1",3,[-48],[0,"c2nEvvjdtVq5hkElT8+Ub2",1,0],[1,0.0003019777941517532,0.0008465509745292366,0.00000805259060143726],[3,0.020119563270397274,-0.0004407734783429816,-0.02189822738422411,0.9995576404239919],[1,2.3062410301816096,4.90164994394894e-7,-2.510061010842388]],[2,"mixamorig:RightHandIndex2",36,[-49],[0,"d6TMqo+X5dKoG+JBt0Vikx",1,0],[1,-2.9316813865420954e-8,0.0003013548266608268,4.3850033738628003e-13],[3,-0.018249310604950383,4.273530874667867e-9,-3.0044442019735303e-10,0.9998334674646794],[1,-2.0913330463277062,4.890007182675349e-7,-4.335954127917444e-8]],[4,"mixamorig:RightHandIndex3",37,[[6,"mixamorig:RightHandIndex4",-50,[0,"35QIvioh5bPJpNBNHRYJNN",1,0],[1,-6.481425884885539e-8,0.00024275541363749653,5.951039899580735e-13]]],[0,"e7UIpBqLddJb31627Xw6Pf",1,0],[1,9.413211188302739e-8,0.0002818843931891024,-4.731726078663345e-13],[3,0.015757178957440974,4.274266737251489e-9,-2.8979174743744314e-10,0.9998758479487857],[1,1.805714430922797,4.902573395598235e-7,-2.5485779608945366e-8]],[2,"mixamorig:RightHandMiddle1",3,[-51],[0,"6f7NKrpxxYrZL5m6CqMEQp",1,0],[1,0.00011581379658309743,0.0008125975728034973,-0.000022222900952328928],[3,0.013623987557052412,0.000013801012081763965,0.0010127588348081734,0.9999066761913932],[1,1.561243075320924,2.1891101060655474e-7,0.11606440866792889]],[2,"mixamorig:RightHandMiddle2",39,[-52],[0,"12OWVhs4NQhasbpiSH7yf7",1,0],[1,-1.4721483410085057e-7,0.00036767913843505085,1.3347767444278624e-13],[3,-0.02874095217377584,1.90977369794475e-9,-2.0349965039587294e-10,0.9995868935055844],[1,-3.293924110463155,2.1808331948063175e-7,-2.9599492197691925e-8]],[4,"mixamorig:RightHandMiddle3",40,[[6,"mixamorig:RightHandMiddle4",-53,[0,"5b0J4J9qVclJ1EVJ3Stj1Y",1,0],[1,7.16508408160621e-9,0.0003007815685123205,1.7697621796861074e-13]]],[0,"4bxvnxIDFUdY8lGLuSpzzr",1,0],[1,1.400503606419079e-7,0.0003426666371524334,6.911338363592423e-13],[3,0.011762529847388185,1.912954055761965e-9,-1.7103988013509872e-10,0.999930819052793],[1,1.347917716855504,2.194237649194947e-7,-1.701992539079738e-8]],[2,"mixamorig:RightHandRing1",3,[-54],[0,"6bNeUU/Mlc9quJ87jZjY1F",1,0],[1,-0.00012408658221829683,0.0009728784207254648,-0.000004863964022661094],[3,-0.016017023514514603,0.0006706182047001883,-0.04182675118899251,0.9989962603102843],[1,-1.8371023970188143,5.774150678840005e-7,-4.795007822215307]],[2,"mixamorig:RightHandRing2",42,[-55],[0,"b0H/kNWQRexL0jSaSXqHhe",1,0],[1,1.180527107180751e-7,0.00028176206978969276,1.5431877780844316e-13],[3,0.010085351606910443,5.104222742094763e-9,-9.420795245970542e-11,0.9999491415481916],[1,1.1557157566673717,5.849799702514496e-7,-4.895956462800389e-9]],[4,"mixamorig:RightHandRing3",43,[[6,"mixamorig:RightHandRing4",-56,[0,"5bKzU4y0dRVrSrIZLQIhaQ",1,0],[1,-1.2970289731129014e-7,0.00023313619021791965,6.104583527045959e-13]]],[0,"42aqpvTRBfeq8KMJBHwZhf",1,0],[1,1.1651379416832697e-8,0.00026972388150170445,5.019984468802689e-14],[3,0.022735346653198926,5.098381838915008e-9,-2.6166214266961347e-10,0.9997415185999624],[1,2.605503313240457,5.847622132875993e-7,-1.6693816278856042e-8]],[2,"mixamorig:RightHandPinky1",3,[-57],[0,"677hk+LNNW2ojWjJynL/xI",1,0],[1,-0.00029370503034442663,0.001011383137665689,0.0000075426814873935655],[3,0.011209396744342324,-0.00024335540580172916,-0.02170401830752104,0.9997015683653202],[1,1.2848318709685782,7.078464625132083e-7,-2.4874489701295417]],[2,"mixamorig:RightHandPinky2",45,[-58],[0,"3fkImsG7JSLJ9pdz8keXWB",1,0],[1,-3.1296792712964816e-7,0.00020606488396879286,5.237210404934745e-13],[3,-0.012599283140802225,6.166091312016912e-9,-2.669499117685828e-10,0.9999206258820436],[1,-1.4438096982925106,7.061405175434507e-7,-3.949020538940225e-8]],[4,"mixamorig:RightHandPinky3",46,[[6,"mixamorig:RightHandPinky4",-59,[0,"d1x4ODHBNTVahvvdfo6tZV",1,0],[1,4.7019852900120895e-7,0.0001242536527570337,6.414311356367497e-12]]],[0,"e2M6ppRchZ2L6ZUP5Ec2Qu",1,0],[1,-1.5723084345609095e-7,0.00016589868755545467,-1.7206236977741762e-13],[3,-0.1410369909767695,6.133992140723092e-9,6.82703411592337e-10,0.9900043268472208],[1,-16.21571375763294,7.069113392804476e-7,-2.1685359659986937e-8]],[2,"LeftUpLeg",4,[-60],[0,"32Q2W13wRQ16TvDYRNf39n",1,0],[1,0.0014123771106824279,-0.0004674071096815169,-0.0001307783677475527],[3,-7.013566363122058e-19,-0.011454023709845362,0.9999344005187811,6.122832738525991e-17],[1,178.68743686468707,-180,7.016709784050289e-15]],[2,"LeftLeg",48,[-61],[0,"9ey4kzx0pTHaw9eNCQgmAZ",1,0],[1,0,0.003758469596505165,1.0450075050086327e-12],[3,0.05984669329257359,-0.0034528498940676446,-0.05749554331678598,0.9965443861806966],[1,6.873451283679826,-3.6554500791758805e-9,-6.604029094655113]],[2,"LeftFoot",49,[-62],[0,"90d7KGZz1UKKR2zHZYGzFQ",1,0],[1,1.9531482334245176e-11,0.0042865099385380745,1.2368989513178441e-11],[3,0.38937583128381925,-0.0520720476024052,0.022054478278409083,0.9193413750388888],[1,45.908988910953276,-6.483607047973803,-2.790991120469289e-7]],[4,"LeftToeBase",50,[[6,"LeftToe_End",-63,[0,"43hrhG8YNRpKdV5gxP8e6x",1,0],[1,3.052777486096253e-13,0.000632571114692837,7.58223372325853e-14]]],[0,"47vQwdOeBel55Sy0zm4RwO",1,0],[1,4.0190989642266417e-13,0.001679202076047659,-4.888413979164952e-11],[3,0.32296933920628945,0.063119022468544,-0.021593557133680455,0.9440553549583747],[1,37.772504412583785,7.650143228117103,-4.889207059281057e-7]],[2,"RightUpLeg",4,[-64],[0,"c575orl5dcWqxHBaud0Csz",1,0],[1,-0.0014123771106824279,-0.0004674071096815169,-0.00012422617874108255],[3,-6.835710274709833e-19,-0.01116356222756394,0.9999376854976472,6.122852267056471e-17],[1,178.72072342745312,180,7.016709112435797e-15]],[2,"RightLeg",52,[-65],[0,"4fzndC/EtTE4Huc/KdRGda",1,0],[1,0,0.003758420469239354,4.931775474115163e-12],[3,0.05679870694179518,0.003276357616690789,0.05749465821555878,0.9967234002706987],[1,6.522994048252719,7.095203011426624e-9,6.602744196968278]],[2,"RightFoot",53,[-66],[0,"9a7DWrk2VUzYKQ+bl5UaPT",1,0],[1,3.731666017858792e-12,0.004284261260181665,-5.101487808578664e-12],[3,0.3932229776738785,0.051395385153296655,-0.022021281905480646,0.9177413945973408],[1,46.387184341143545,6.410664041505134,5.067144960119074e-7]],[4,"RightToeBase",54,[[6,"RightToe_End",-67,[0,"892LXrCqBb9YN9+Rnd7Dq4",1,0],[1,7.113495990168639e-13,0.0006245662807486951,1.2396904520723534e-13]]],[0,"80N9z+S5hX/YIILw4w64Ga",1,0],[1,-1.0649450939148597e-11,0.0016852356493473053,-1.3362562792385013e-11],[3,0.3215081484850141,-0.06209310320188798,0.021133553835753112,0.9446323781740541],[1,37.592287518184676,-7.521575852784309,6.589117324744192e-8]]],0,[0,3,1,0,7,1,0,-1,6,0,-2,4,0,-1,15,0,-2,18,0,-3,21,0,-4,24,0,-5,27,0,-1,33,0,-2,36,0,-3,39,0,-4,42,0,-5,45,0,-1,8,0,-2,48,0,-3,52,0,-1,10,0,-2,12,0,-3,30,0,-1,7,0,7,7,0,-1,9,0,-1,11,0,0,11,0,-1,13,0,-1,14,0,-1,16,0,-1,17,0,0,17,0,-1,19,0,-1,20,0,0,20,0,-1,22,0,-1,23,0,0,23,0,-1,25,0,-1,26,0,0,26,0,-1,28,0,-1,29,0,0,29,0,-1,31,0,-1,32,0,-1,34,0,-1,35,0,0,35,0,-1,37,0,-1,38,0,0,38,0,-1,40,0,-1,41,0,0,41,0,-1,43,0,-1,44,0,0,44,0,-1,46,0,-1,47,0,0,47,0,-1,49,0,-1,50,0,-1,51,0,0,51,0,-1,53,0,-1,54,0,-1,55,0,0,55,0,12,1,2,0,14,3,0,32,5,0,9,67],[0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,14,15,-1,-2,16],[66,9,9,9,9,9,9,67,68,69,28,27,28]],[[[26,"Naruto:nr2_tex02_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[22,".bin",2870649457,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":105984,"length":20232,"count":5058,"stride":4}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":165240,"length":2700,"count":1350,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":178164,"length":684,"count":342,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":241488,"length":4752,"count":2376,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":275400,"length":2568,"count":1284,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":299280,"length":2148,"count":1074,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[6],"indexView":{"offset":307260,"length":480,"count":240,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[7],"indexView":{"offset":311052,"length":720,"count":180,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":105984,"count":1472,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":126216,"length":39024,"count":542,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":167940,"length":10224,"count":142,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":178848,"length":62640,"count":870,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":246240,"length":29160,"count":405,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":277968,"length":21312,"count":296,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":301428,"length":5832,"count":81,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":307740,"length":3312,"count":46,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,24],[0,1,2,3,4,5,6,7,8,9,10,11,12,19,20,21,22,23,26,27,28,29,31,33,34],[0,18,19,20,21,22,23,24,25,27,28,30,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48],[0,1,2,3,4,9,10,11,12,20,22,23,24,26,27,28,29,31,32,39,44,46,48,49,50,51],[0,1,3,5,6,7,8,18,19,20,21,22,23,24,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40],[0,18,20,22,24,25,28,29,31,32,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]]},"minPosition",8,[1,-0.008109640330076218,0.00001888999941002112,-0.002359919948503375],"maxPosition",8,[1,0.008109590038657188,0.017242999747395515,0.001954670064151287]]],-1],0,0,[],[],[]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[70,4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[71,4]],[[[39,"WarUnit_Far_1"],[70,"WarUnit_Far_1",[-7],[[67,-6,[9,"b5a/nXzP9L8YmZHtTAoxpP"],[152,1],-5,-4]],[100,"21DQ7fLQZIxZrqzxIqcSL9",-3,0,[-1,-2]],[1,-3.306,0,-5.089]],[49,0,{},[12,"767tFETGRSvriw5QNcll/G",-21,[141,"0eM3qVHJVHCLQUXDCir5ef",1,[[156,[1,["04ZTgOx/BdtLZun8hjPnDn"]],[-20]]],[[68,[1,["767tFETGRSvriw5QNcll/G"]],[-19]]],[[11,"Wolf@Idle",["_name"],-8],[10,["_lpos"],-9,[1,0,0,0]],[10,["_lrot"],-10,[3,0,0,0,1]],[10,["_euler"],-11,[1,0,0,0]],[10,["_lscale"],-12,[1,2.5,2.5,2.5]],[3,["_materials","0"],-13,3],[40,["_skinningRoot"],-15,-14],[11,1,["_materials","length"],-16],[3,["_materials","1"],-17,4],[11,1,["_shadowCastingMode"],-18]],[[1,["85e1IBJo1fLb2LdwvVS3cA"]]]],0]],[1,["767tFETGRSvriw5QNcll/G"]],[1,["be1OI3ev9S64fnypq2RHZx"]],[1,["47LaGKdYVfZYy4WPAi7QAg"]],[35,"body",1,[2],[0,"80zfl/DNNAMqLoHFQBA+F1",1,0]],[123,0,[114,"New Node"],[12,"47LaGKdYVfZYy4WPAi7QAg",-24,[20,"656s+Dq2JCbo26zAseANf0",[[11,"w09",["_name"],5],[10,["_lpos"],5,[1,0,0,0]],[10,["_lrot"],5,[3,0,-0.7071067811865475,0,0.7071067811865476]],[10,["_euler"],5,[1,0,-90,0]],[3,["_materials","0"],-22,2],[11,1,["_shadowCastingMode"],-23]]],1],[{},"mountedRoot",1,2]],[1,["d1ppO1bKtTcrHfbSH6Zv07"]],[69,2,[9,"f7qQkaxt5FX6AmSBQJpMiQ"]]],0,[0,-1,2,0,-2,7,0,3,1,0,23,9,0,24,6,0,7,1,0,-1,6,0,4,3,0,4,3,0,4,3,0,4,3,0,4,3,0,4,4,0,1,2,0,4,4,0,4,4,0,4,4,0,4,4,0,-1,9,0,-1,7,0,3,2,0,4,8,0,4,8,0,3,7,0,12,1,2,0,6,24],[0,0,0,0,0,9],[8,8,1,1,1,20],[72,73,21,21,21,74]],[[[39,"smokeing"],[121,"smokeing",[-2],[0,"f84oEVDONL1b6uF4wcb6EY",-1,0],[1,0,0.565,-1.7110000000000003],[3,0.7071067811865475,0,0,0.7071067811865477],[1,89.99999999999999,0,0]],[157,1,false,1,[9,"efrXS6mKhHc7immhegOmbv"],[[0,null],6,0],[32],[33,3,2,4],[5],[5],[13,15],[5],[5],[76,3,6.283185307179586],[5],[33,3,0.3,0.5],[5],[5],[5],[[77,[13,16]]],[78,true,[75,1,[79,[[159],[80,0.6696428571428571],[80,1]],[[82,255],[46,144,0.45089285714285715],[46,0,1]]]]],[160,true,1,0,0.1,1.3962634015954636,[13,1],[1,0,0,-0.5]],[83,true,[45,1,[47,[0,1],[[105,1,-1,1,-1,1],[106,-1,1,-1,1]]]],[5],[5],[5]],[84,true,[5],[5],[5],[13,0.3]],[107,[13,10],[13,10],[13,10]],[85,[5],[5],[5],[5]],[86,true,[5],[5],[33,3,-3.141592653589793,3.141592653589793]],[87,true,2,2,[45,1,[47,[0,1],[[48,2,1],[48,2,1]]]],[5]],[88,[13,1],[5],[32],[32],-3],[89,1]]],0,[0,3,1,0,-1,2,0,21,2,0,12,1,3],[0,0],[-1,22],[22,13]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[29,4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[30,4]],[[[26,"Sasuke_CurseForm:sa2_tex02_sa2_tex02_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[41,"Skin-0",2650008573,["mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2/mixamorig:LeftHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2/mixamorig:LeftHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2/mixamorig:RightHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2/mixamorig:RightHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2/mixamorig:RightHandRing3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2/mixamorig:LeftHandRing3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3","mixamorig:Hips/mixamorig:Spine","mixamorig:Hips","mixamorig:Hips/mixamorig:RightUpLeg","mixamorig:Hips/mixamorig:LeftUpLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1"],[[[7,1,0,0,0,0,1,-7.703719777548943e-34,0,0,7.703719777548943e-34,1,0,-5.066394859198908e-9,-0.0135525893419981,0.00023294340644497424,1],[7,1,0,0,0,0,1,-7.703719777548943e-34,0,0,7.703719777548943e-34,1,0,-5.066394859198908e-9,-0.014717242680490017,0.0008560396963730454,1],[7,1,0,0,0,0,0.9996440410614014,0.026678845286369324,0,0,-0.026678845286369324,0.9996440410614014,0,-5.066394859198908e-9,-0.012306003831326962,-0.00012870693171862513,1],[7,-0.0035435291938483715,-0.9995792508125305,0.02878803014755249,0,0.02670879289507866,-0.028872545808553696,-0.9992262125015259,0,0.9996369481086731,-0.002771893749013543,0.026799866929650307,0,-0.00012907684140373021,-0.00018088521028403193,0.0135471997782588,1],[7,0.002000910695642233,0.9995792508125305,-0.028937023133039474,0,-0.026697710156440735,-0.028873369097709656,-0.9992265105247498,0,-0.9996415376663208,0.0027719151694327593,0.026628704741597176,0,0.0001289395586354658,-0.00017959278193302453,0.01354716345667839,1],[7,0.022893188521265984,-0.999732494354248,0.003289148909971118,0,0.0274630319327116,-0.0026598917320370674,-0.9996193051338196,0,0.9993606209754944,0.022974802181124687,0.027394792065024376,0,-0.00009388567559653893,-0.0016770032234489918,0.013508819974958897,1],[7,0.026245521381497383,-0.9995211958885193,-0.016385886818170547,0,0.027471795678138733,0.01710650511085987,-0.9994761943817139,0,0.9992779493331909,0.025781624019145966,0.027907613664865494,0,-0.00008036538929445669,-0.0042970855720341206,0.01342684868723154,1],[7,0.018750987946987152,0.9998191595077515,-0.0031712588388472795,0,-0.027177805081009865,-0.002660946687683463,-0.9996270537376404,0,-0.9994547367095947,0.018830182030797005,0.027122994884848595,0,0.00010667349124560133,-0.0016783130122348666,0.013508398085832596,1],[7,0.02805045060813427,0.9994729161262512,0.016341259703040123,0,-0.02720138058066368,0.017104847356677055,-0.9994836449623108,0,-0.9992363452911377,0.027591461315751076,0.027666842564940453,0,0.00006915585254319012,-0.004296538420021534,0.013427088968455791,1],[7,0.011431225575506687,0.9943908452987671,-0.1051483079791069,0,-0.05147460475564003,-0.10443056374788284,-0.9931991696357727,0,-0.9986088871955872,0.016765952110290527,0.04999210685491562,0,0.00016747591143939644,-0.005836384370923042,0.014274234883487225,1],[7,0.011431225575506687,0.9976999163627625,-0.06681495159864426,0,-0.05147460475564003,-0.06614357978105545,-0.9964814782142639,0,-0.9986088871955872,0.014830278232693672,0.05060010403394699,0,0.00016766694898251444,-0.0066848755814135075,0.014027443714439869,1],[7,0.011431225575506687,0.9997034072875977,0.021505113691091537,0,-0.05147460475564003,0.022066324949264526,-0.9984304904937744,0,-0.9986088871955872,0.01030631735920906,0.05171158164739609,0,0.00016771907394286245,-0.00814782828092575,0.01336043979972601,1],[7,-0.027505535632371902,0.9979578256607056,0.057650376111269,0,-0.053703632205724716,0.05611366033554077,-0.9969789981842041,0,-0.9981780052185059,-0.03051847778260708,0.052050523459911346,0,0.000790933205280453,-0.007281590718775988,0.013126189820468426,1],[7,-0.047935087233781815,0.9987879395484924,-0.011174415238201618,0,-0.05484141781926155,-0.013802089728415012,-0.9983996748924255,0,-0.9973437786102295,-0.04724555462598801,0.055436551570892334,0,0.0010764059843495488,-0.007574376650154591,0.013667510822415352,1],[7,-0.047935087233781815,0.9978325366973877,-0.045082300901412964,0,-0.05484141781926155,-0.04769527539610863,-0.9973552823066711,0,-0.9973437786102295,-0.045335933566093445,0.05700882896780968,0,0.0010762946913018823,-0.007441374007612467,0.013928217813372612,1],[7,-0.047935087233781815,0.9965069890022278,-0.06838192790746689,0,-0.05484141781926155,-0.07098304480314255,-0.995968759059906,0,-0.9973437786102295,-0.04399168863892555,0.058052435517311096,0,0.0010762697784230113,-0.006431389134377241,0.014079035259783268,1],[7,0.02903229370713234,0.9992735385894775,-0.024688441306352615,0,-0.0504409596323967,-0.023202799260616302,-0.9984574913978577,0,-0.9983049631118774,0.03023282065987587,0.049730684608221054,0,0.0002094452065648511,-0.006988817825913429,0.013770636171102524,1],[7,0.02903229370713234,0.9993630051612854,-0.020753227174282074,0,-0.0504409596323967,-0.01927080936729908,-0.9985411167144775,0,-0.9983049631118774,0.03003675304353237,0.04984935373067856,0,0.0002096572279697284,-0.007407211698591709,0.013741573318839073,1],[7,-0.0319160558283329,0.9966327548027039,-0.07552824914455414,0,-0.053951118141412735,-0.07717444002628326,-0.9955568313598633,0,-0.9980334043502808,-0.027699412778019905,0.05623255670070648,0,0.0011410576989874244,-0.006382087245583534,0.014102542772889137,1],[7,-0.044429961591959,-0.998736560344696,0.023480040952563286,0,0.06293568015098572,-0.026254786178469658,-0.9976722002029419,0,0.997028112411499,-0.04284880310297012,0.06402266025543213,0,-0.0011599779827520251,-0.007375816348940134,0.01375806238502264,1],[7,-0.044429961591959,-0.9989844560623169,0.007487925700843334,0,0.06293568015098572,-0.010279354639351368,-0.99796462059021,0,0.997028112411499,-0.04386826977133751,0.06332847476005554,0,-0.0011600097641348839,-0.007941054180264473,0.013632678426802158,1],[7,-0.044429961591959,-0.9984269738197327,-0.034199509769678116,0,0.06293568015098572,0.031367961317300797,-0.9975244998931885,0,0.997028112411499,-0.04647234454751015,0.06144299730658531,0,-0.0011599960271269083,-0.007798338308930397,0.013309447094798088,1],[7,-0.018464449793100357,-0.9987832903862,-0.04572752118110657,0,0.06179921329021454,0.04450777918100357,-0.9970957636833191,0,0.9979177713394165,-0.02123674936592579,0.06090221181511879,0,-0.000837273895740509,-0.007128869649022818,0.013206936419010162,1],[7,-0.0011411345330998302,-0.9964086413383484,0.08466682583093643,0,0.06101807951927185,-0.0845784991979599,-0.9945467710494995,0,0.9981359839439392,0.0040312958881258965,0.06089545786380768,0,-0.0005813639145344496,-0.006223762407898903,0.01417213212698698,1],[7,-0.0011411345330998302,-0.9998228549957275,-0.018788082525134087,0,0.06101807951927185,0.01868346892297268,-0.9979617595672607,0,0.9981359839439392,-0.0022852213587611914,0.06098594889044762,0,-0.0005814058240503073,-0.0079910047352314,0.013417965732514858,1],[7,0.013537706807255745,-0.99613356590271,0.08680222183465958,0,0.06034184247255325,-0.08583807945251465,-0.9944801330566406,0,0.9980859756469727,0.01870078593492508,0.058946482837200165,0,-0.0002743088989518583,-0.006218684371560812,0.014155813492834568,1],[7,0.013537706807255745,-0.9989492297172546,0.043785542249679565,0,0.06034184247255325,-0.04289356246590614,-0.9972557425498962,0,0.9980859756469727,0.016142655164003372,0.05969775468111038,0,-0.0002742167853284627,-0.0070752231404185295,0.013863736763596535,1],[7,0.013537706807255745,-0.9988560080528259,0.04586348682641983,0,0.06034184247255325,-0.04496798664331436,-0.9971643686294556,0,0.9980859756469727,0.016266806051135063,0.0596640445291996,0,-0.00027422106359153986,-0.007257203105837107,0.01387886330485344,1],[7,-0.022949444130063057,-0.9995665550231934,0.018440017476677895,0,0.061998460441827774,-0.019832337275147438,-0.9978792071342468,0,0.9978123903274536,-0.021757518872618675,0.06242673099040985,0,-0.0011805224930867553,-0.007179218344390392,0.013692275620996952,1],[7,0.6510246992111206,-0.7414376139640808,0.16259479522705078,0,0.016495464369654655,-0.2003364861011505,-0.9795882701873779,0,0.7588772773742676,0.640418291091919,-0.11819364875555038,0,0.004063001833856106,-0.0024103084579110146,0.014309107325971127,1],[7,-0.022949444130063057,-0.9994925260543823,0.022090792655944824,0,0.061998460441827774,-0.023476939648389816,-0.9978001117706299,0,0.9978123903274536,-0.021529361605644226,0.06250578165054321,0,-0.001180707709863782,-0.007418137975037098,0.013719461858272552,1],[7,0.6510246992111206,-0.7565398216247559,0.061760395765304565,0,0.016495464369654655,-0.06724461168050766,-0.9976001381874084,0,0.7588772773742676,0.650481104850769,-0.031298428773880005,0,0.0040097362361848354,-0.004893448669463396,0.013798733241856098,1],[7,0.6510246992111206,-0.7508538365364075,0.11128935217857361,0,0.016495464369654655,-0.13258585333824158,-0.9910342693328857,0,0.7588772773742676,0.6470235586166382,-0.07393098622560501,0,0.004017223138362169,-0.0036718754563480616,0.014090195298194885,1],[7,-0.0011411345330998302,-0.9995090365409851,0.03131028264760971,0,0.06101807951927185,-0.031321559101343155,-0.9976450800895691,0,0.9981359839439392,0.0007720461580902338,0.06102386489510536,0,-0.0005813650204800069,-0.007625863887369633,0.013817237690091133,1],[7,0.6821696758270264,0.7157386541366577,-0.14954160153865814,0,0.0012722156243398786,-0.2056785523891449,-0.9786188006401062,0,-0.7311927676200867,0.6673938035964966,-0.14121824502944946,0,-0.0045148893259465694,-0.0021668944973498583,0.01420854963362217,1],[7,0.6821696758270264,0.7259207963943481,-0.08765578269958496,0,0.0012722156243398786,-0.12105853110551834,-0.9926445484161377,0,-0.7311927676200867,0.6770405173301697,-0.08350598812103271,0,-0.004480586387217045,-0.003658417845144868,0.013946343213319778,1],[7,0.6821696758270264,0.7275718450546265,-0.07268940657377243,0,0.0012722156243398786,-0.10059283673763275,-0.9949268698692322,0,-0.7311927676200867,0.678616464138031,-0.06954701244831085,0,-0.004484906792640686,-0.0042535699903965,0.013861694373190403,1],[7,0.02903229370713234,0.9957606792449951,0.08727985620498657,0,-0.0504409596323967,0.08866485208272934,-0.9947835206985474,0,-0.9983049631118774,0.02447836846113205,0.05280127003788948,0,0.00020983531430829316,-0.00918964110314846,0.012824255041778088,1],[7,-0.022949444130063057,-0.9806607961654663,0.1943647861480713,0,0.061998460441827774,-0.19543783366680145,-0.978754460811615,0,0.9978123903274536,-0.010411552153527737,0.06528465449810028,0,-0.0011806640541180968,-0.00520843593403697,0.014841916039586067,1],[7,-0.0319160558283329,0.9993283152580261,-0.018009331077337265,0,-0.053951118141412735,-0.01971474662423134,-0.9983489513397217,0,-0.9980334043502808,-0.03089173696935177,0.05454409494996071,0,0.0011412460589781404,-0.0074758208356797695,0.013694755733013153,1],[7,-0.0319160558283329,0.9994871020317078,-0.002627995330840349,0,-0.053951118141412735,-0.004348279908299446,-0.998534083366394,0,-0.9980334043502808,-0.03172748535871506,0.05406222492456436,0,0.0011411845916882157,-0.00795772485435009,0.013573898002505302,1],[7,1,0,0,0,0,0.9996440410614014,0.02667882852256298,0,0,-0.02667882852256298,0.9996440410614014,0,-5.066394859198908e-9,-0.010226042941212654,-0.00012870674254372716,1],[7,1,0,0,0,0,1,0,0,0,0,1,0,-5.066394859198908e-9,-0.009394148364663124,0.00012196157331345603,1],[7,-0.9999955296516418,-0.002995903603732586,2.678064204859193e-13,0,0.0029958810191601515,-0.9999879002571106,-0.0038962478283792734,0,0.000011672783330141101,-0.0038962303660809994,0.9999924302101135,0,-0.0008483428391627967,0.008928295224905014,0.00004637179881683551,1],[7,-0.9999955296516418,0.0029959119856357574,-3.024456160234494e-14,0,-0.0029958977829664946,-0.9999907612800598,-0.0030883208382874727,0,-0.000009252337804355193,-0.003088307101279497,0.999995231628418,0,0.0008483529672957957,0.008928261697292328,0.00006111757102189586,1],[7,-0.9999703168869019,-0.00769937876611948,-0.0003164882946293801,0,0.007705822121351957,-0.998958945274353,-0.04496243596076965,0,0.00003002402081619948,-0.044963542371988297,0.9989886283874512,0,-0.0008720468613319099,0.005024468991905451,0.0002529452322050929,1],[7,-0.9999703168869019,0.007702365517616272,0.0002483809366822243,0,-0.007706332486122847,-0.9993464946746826,-0.035316210240125656,0,-0.000023799742848495953,-0.0353170745074749,0.9993761777877808,0,0.0008720593177713454,0.005026012193411589,0.00022322495351545513,1],[7,-0.9999562501907349,0.0004014010773971677,-0.009342929348349571,0,-0.007510142866522074,-0.6297774314880371,0.7767393589019775,0,-0.00557218212634325,0.7767755389213562,0.6297528743743896,0,0.0008708065724931657,0.000858389656059444,-0.0007598812226206064,1],[7,-0.999971866607666,0.0050328578799963,0.005560000892728567,0,0.005564332474023104,0.0008470481261610985,0.9999841451644897,0,0.005028069019317627,0.9999869465827942,-0.0008750287815928459,0,0.0008578935521654785,-0.0011819987557828426,-0.00003767567250179127,1],[7,-0.9999573826789856,-0.000396935356548056,0.009222027845680714,0,0.00746254762634635,-0.6227702498435974,0.7823691368103027,0,0.0054326546378433704,0.7824046611785889,0.6227467060089111,0,-0.0008706661756150424,0.0008662421023473144,-0.0007559051737189293,1],[7,-0.9999713897705078,-0.0050178705714643,-0.005656335037201643,0,-0.005660641472786665,0.0008444869890809059,0.9999836087226868,0,-0.005013011861592531,0.9999870657920837,-0.0008728671818971634,0,-0.0008578654378652573,-0.001188375405035913,-0.00003775592631427571,1],[7,1,0,0,0,0,0.9996440410614014,0.026678845286369324,0,0,-0.026678845286369324,0.9996440410614014,0,-5.066394859198908e-9,-0.011196691542863846,-0.00012870693171862513,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[22,".bin",1391067996,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":17280,"length":960,"count":240,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":111048,"length":2580,"count":1290,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[2],"indexView":{"offset":155748,"length":1170,"count":585,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":220422,"length":1764,"count":882,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[4],"indexView":{"offset":276402,"length":1506,"count":753,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":539916,"length":7320,"count":3660,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[6],"indexView":{"offset":562356,"length":420,"count":210,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[7],"indexView":{"offset":567528,"length":132,"count":66,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[8],"indexView":{"offset":775020,"length":11520,"count":2880,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":17280,"count":240,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":18240,"length":92808,"count":1289,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":113628,"length":42120,"count":585,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":156918,"length":63504,"count":882,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":222186,"length":54216,"count":753,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":277908,"length":262008,"count":3639,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":547236,"length":15120,"count":210,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":562776,"length":4752,"count":66,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":567660,"length":207360,"count":2880,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],[0,1,2,3,4,5,6,7,8,9,12,16,21,22,23,29,34,41,42,43,44,45,46,47,48,49,50,51],[0,1,2,3,4,5,6,7,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33],[0,1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,21,22,23,25,28,29,31,32,34,35,36,39],[0,1,2,6,8,9,10,12,15,16,17,18,19,21,22,23,24,25,26,28,30,33,34,37,38,39,40],[0,1,2,3,4,5,6,7,8,19,21,22,23,28,29,31,32,41,42,43,44,45,46,47,48,49,50]]},"minPosition",8,[1,-0.008472450077533722,0.0000023999998575163772,-0.003666290082037449],"maxPosition",8,[1,0.008472460322082043,0.01808737963438034,0.002015199977904558]]],-1],0,0,[],[],[]],[[[26,"Sasuke_CurseForm:sa2_eye_001_sa2_eye_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[29],[50,"dr2_Idle (12)",[-3,-4],[[42,-2,[9,"c31C+m02Rfb6Hla5hcsbWk"],[11],12]],[0,"f1kQPBbV1UU4I52O3hjZk9",-1,0]],[27,"mixamorig:LeftHand",[-5,-6,-7,-8,-9],[0,"92pihJenFcAoeM+glODsdZ",1,0],[1,7.934771546411201e-13,0.0024601242039352655,-1.8121992621800143e-12],[3,-0.020670240512387077,-0.012229518827292092,-0.02824762059259154,0.9993123895745863],[1,-2.4110799129933724,-1.4698076819995713,-3.2074208176608026]],[27,"mixamorig:RightHand",[-10,-11,-12,-13,-14],[0,"d8xPYnff1WKIGIg+up/ylU",1,0],[1,-3.3056942599918315e-12,0.0024600049946457148,1.365196801092483e-12],[3,-0.014739996759459004,0.016478557146148234,0.022874832162361587,0.9994938377516172],[1,-1.7334579169657596,1.928323193061926,2.5929873419700114]],[34,"mixamorig:Hips",1,[-15,-16,-17],[0,"19cQ7/oNtVdKU9VoeWg2HZ",1,0],[1,5.066394859198908e-9,0.009394148364663124,-0.00012196157331345603]],[51,"mixamorig:Spine2",[-18,-19,-20],[0,"abc2hqxvhdD42Rhe/sGiGw",1,0],[1,0,0.0011093118228018284,6.89839244755186e-13]],[35,"Sasuke_CurseForm:Mesh",1,[-21],[0,"5eriUGUulfaI73GgJSj0Cn",1,0]],[35,"polySurface11",6,[-22],[0,"b2Hzm37zNW+Z/sFXObVPpL",1,0]],[52,"polySurface20",7,[[43,-23,[9,"3dQrqPV2dWh7oAsEfxjxn2"],[0,1,2,3,4,5,6,7,8],[21],1,9,10]],[0,"02equCDYlRBbW1IxQY3SuS",1,0]],[2,"mixamorig:Spine",4,[-24],[0,"ee52uCVZdQr6rrC4BRYlHF",1,0],[1,0,0.0008316886378452182,-0.00002219636007794179],[3,-0.013340601696873572,0,0,0.9999110102135916],[1,-1.5287656952384436,0,0]],[34,"mixamorig:Spine1",9,[5],[0,"fdSHG2tZ9d1oGrZ5L3o9WQ",1,0],[1,0,0.0009706483106128871,9.189693277178446e-13]],[2,"mixamorig:Neck",5,[-25],[0,"96H5HnD3BTYKIvD/gDWx7l",1,0],[1,0,0.0012479765573516488,1.599840225574578e-11],[3,0.013340610077285,0,0,0.999911010101782],[1,1.528766655648321,0,0]],[53,"mixamorig:Head",11,[[6,"mixamorig:HeadTop_End",-26,[0,"87PX0N4YJRXq8qW5kw4Msk",1,0],[1,0,0.0026434720493853092,-0.001414272584952414]]],[0,"13tZndZ/VQPaCND7m9c5oA",1,0],[1,0,0.0011646533384919167,-0.0006230962462723255]],[2,"mixamorig:LeftShoulder",5,[-27],[0,"1dm1YVqdVUDYeKzIVx4lk/",1,0],[1,0.0005712687852792442,0.001230292720720172,0.0000011197741969226627],[3,0.5076851870767658,0.49221465243453294,-0.5066796567142593,0.49321010961202083],[1,91.65820216009409,89.88535549183072,-0.0010818730115909345]],[2,"mixamorig:LeftArm",13,[-28],[0,"3fgSlF3ChUgZaUpFxX9g+7",1,0],[1,7.284440655926441e-14,0.0011480571702122688,-9.757572354274213e-13],[3,-0.012886357448795809,-0.00010797913963533809,0.008378302649271469,0.9998818601099455],[1,-1.476760505220448,-6.649982328670302e-8,0.9601737292441408]],[2,"mixamorig:LeftForeArm",14,[2],[0,"af6ZV//UBWNbZWJ+cwzZd8",1,0],[1,2.4291413065063994e-12,0.002354496158659458,-4.1265436705704983e-13],[3,-0.00976020586436616,-0.000045395148098013746,0.00465080665228644,0.9999415514510079],[1,-1.1184670625352562,3.845219695767072e-8,0.5329704930713004]],[2,"mixamorig:LeftHandThumb1",2,[-29],[0,"99qoVdj+xWqrmqKAs5i4ZB",1,0],[1,-0.0002691411937121302,0.00021117241703905165,0.00009939794836100191],[3,0.13131092463183502,0.05396341894484582,0.376262604457236,0.9155718666359148],[1,16.323360444284617,-3.6781815362809287e-7,44.68131660264131]],[2,"mixamorig:LeftHandThumb2",16,[-30],[0,"33a8AIDtNfKYuLG+LymNzo",1,0],[1,-0.00003430289143580012,0.00028292418573983014,8.693490128079337e-14],[3,-0.04288729541008047,-3.466254606211077e-17,-1.4879519892297726e-18,0.9990799166695368],[1,-4.916029854999421,-3.975693162555032e-15,-1.1089791399016598e-23]],[4,"mixamorig:LeftHandThumb3",17,[[6,"mixamorig:LeftHandThumb4",-31,[0,"2e3gKZcbBWtKZc2zvIXrFD",1,0],[1,0.000029982433261466213,0.000253345409873873,-1.7929124981538869e-12]]],[0,"d2QuV5jKpaCqkdl0Cm9JPd",1,0],[1,0.000004320462267060066,0.0003088171361014247,2.429356629057855e-12],[3,-0.010296290537778963,3.755042565081185e-18,-2.7718381721173882e-17,0.9999469917956458],[1,-1.1798888329135702,3.9756934132798683e-16,-3.1805546600502654e-15]],[2,"mixamorig:LeftHandIndex1",2,[-32],[0,"3dOPHLpEpSUaE6sSDbAJYf",1,0],[1,-0.00031386889168061316,0.0009238142520189285,-0.000002615285893625696],[3,0.06662576469443186,-0.0001472377004751001,-0.0022050018304927955,0.9977755878787921],[1,7.640428678247599,-2.8652783077559742e-8,-0.25323749253787053]],[2,"mixamorig:LeftHandIndex2",19,[-33],[0,"6aDQ/vuLta9IaOZXE3hIBM",1,0],[1,-1.8834280979262985e-7,0.0002926804299931973,1.6463408327588303e-12],[3,-0.028805697260122793,1.0304082156848376e-17,3.767826705304563e-18,0.9995850298025466],[1,-3.3013464239667485,1.1927080387095464e-15,3.9756932904145895e-16]],[4,"mixamorig:LeftHandIndex3",20,[[6,"mixamorig:LeftHandIndex4",-34,[0,"2bMSdcKlFfdItQKcfD5EGf",1,0],[1,1.2687081607509754e-7,0.00022875764989294112,1.2762680452402253e-13]]],[0,"c0yYdFtYRYRKDPDkM4JPpq",1,0],[1,6.147146791590785e-8,0.00027206592494621873,-5.763833556488365e-14],[3,-0.007694998417898461,-2.66973888062657e-20,3.4693442322506933e-18,0.9999703930613889],[1,-0.8817905678011017,0,3.975693351829396e-16]],[2,"mixamorig:LeftHandMiddle1",2,[-35],[0,"89Txq4WkBXBKjjAtvHh+dM",1,0],[1,-0.00011815803009085357,0.0008918724488466978,-0.00003087736331508495],[3,0.06308628556105685,-0.0006459815130718301,-0.010218705880551817,0.9979555507797531],[1,7.234339353795542,-7.328821138421245e-8,-1.173335344055843]],[2,"mixamorig:LeftHandMiddle2",22,[-36],[0,"bchQfHi+lfsZNka1HkidBS",1,0],[1,-1.3620763184007956e-7,0.00034746064920909703,-2.288480548725408e-13],[3,-0.02865943210453624,3.4680218214934964e-18,9.943237935980481e-20,0.999589234111415],[1,-3.284578748949616,3.9756933518293945e-16,0]],[4,"mixamorig:LeftHandMiddle3",23,[[6,"mixamorig:LeftHandMiddle4",-37,[0,"73lXQ+bU9eYJsue9fB7oBN",1,0],[1,2.491687389749586e-8,0.0002782336960081011,-1.2190825605939981e-12]]],[0,"38yrgGoHlQ+omTwx7pSq7q",1,0],[1,1.1128643251367976e-7,0.0003356453380547464,8.754330810614719e-14],[3,0.016980189996774902,-6.937893497072021e-18,1.1782373685580787e-19,0.9998558261807917],[1,1.9458799601716394,-7.951386703658794e-16,0]],[2,"mixamorig:LeftHandRing1",2,[-38],[0,"91mC0+5FFfTItw1DRBLhtb",1,0],[1,0.00012336605868767947,0.0007921938085928559,-0.00002243058042949997],[3,0.041175862058331826,0.0011664018126940554,0.028291984317840843,0.9987505952508482],[1,4.721634905458567,-2.684484557010843e-7,3.24521040195902]],[2,"mixamorig:LeftHandRing2",25,[-39],[0,"72AFWvA5FZ3r0hMZVnBlDg",1,0],[1,-2.1201617528276984e-7,0.00036422384437173605,5.282530055744639e-13],[3,-0.0019689454328442944,-3.472855862506593e-18,1.7278890489434609e-18,0.9999980616250626],[1,-0.22562467256882993,-3.9756934201315054e-16,1.9878467760210078e-16]],[4,"mixamorig:LeftHandRing3",26,[[6,"mixamorig:LeftHandRing4",-40,[0,"a5OFOiMDpUcKwMKQG8AsAy",1,0],[1,3.9011027297419787e-7,0.0002982528822030872,-3.14197778038261e-12]]],[0,"b7XEegYMlYFpieuzms8XY5",1,0],[1,-1.780932308292904e-7,0.00034392790985293686,-9.565037564079892e-13],[3,-0.05406935511359154,-6.741152654093539e-18,-3.839553199429745e-18,0.998537182501283],[1,-6.198914619804899,-7.951386519785032e-16,-3.975693243127427e-16]],[2,"mixamorig:LeftHandPinky1",2,[-41],[0,"87HKfmqAxXOJMQLcLS5lVx",1,0],[1,0.00030866084853187203,0.0007816432043910027,-0.000011424293916206807],[3,0.08141230052512594,0.0015879594732141813,0.019436687244823794,0.9964897043606948],[1,9.341279244641537,-1.8026187674469445e-8,2.2348428587323137]],[2,"mixamorig:LeftHandPinky2",28,[-42],[0,"48dvIuVilSAbYqHyNJGyEs",1,0],[1,-1.9103103454654047e-7,0.0003038885479327291,6.887446342418446e-13],[3,-0.019239214826194517,3.4688047891623714e-18,6.674943523672135e-20,0.9998149091771295],[1,-2.204787651705085,3.975693351829396e-16,0]],[4,"mixamorig:LeftHandPinky3",29,[[6,"mixamorig:LeftHandPinky4",-43,[0,"0f8QQMoV9YjqltvmWTnkix",1,0],[1,2.431578138839541e-7,0.0002020119718508795,-7.282441251595106e-13]]],[0,"abtFfqIUJW1bb+4B5mGiTR",1,0],[1,-5.212676867927257e-8,0.0002519304398447275,3.8800741591037136e-13],[3,-0.04417427936958466,3.831507972838823e-20,-8.665150542210281e-19,0.9990238400769913],[1,-5.063647292250841,0,-9.93923337957349e-17]],[2,"mixamorig:RightShoulder",5,[-44],[0,"373awKEIFRV7659kaXp/cs",1,0],[1,-0.0005712687852792442,0.0012303775874897838,-0.0000020613849756045965],[3,0.5062392406713733,-0.493615006578843,0.5080511622867635,0.4918842068858366],[1,91.64967627285583,-90.20302896171734,0.0017253941477023355]],[2,"mixamorig:RightArm",31,[-45],[0,"40kajF2xxXPaZrSGROHQs6",1,0],[1,1.248556108762039e-13,0.0011480571702122688,-9.704815076561069e-13],[3,-0.012753309930597543,0.00016867027772138004,-0.013223383833426432,0.9998312191345824],[1,-1.4615891051969523,-1.1801673175244242e-8,-1.5154556082568689]],[2,"mixamorig:RightForeArm",32,[3],[0,"a1FabltF5bl5e8P5vzs2nw",1,0],[1,-2.913898235114981e-13,0.0023547003511339426,6.252776040807564e-15],[3,-0.009841104958919515,0.000016499961912552014,-0.0016766007738989238,0.9999501694538503],[1,-1.1277273484671846,-5.322575297092872e-8,-0.19213369011099257]],[2,"mixamorig:RightHandThumb1",3,[-46],[0,"04n8TQJqJe2Z9tOCz7yuFL",1,0],[1,0.00027099825092591345,0.00021787566947750747,0.00009719987428979948],[3,0.12861490487870544,-0.04902259351221864,-0.35277319607918795,0.9255301527753985],[1,15.822712923119099,3.984043693439018e-7,-41.72948793682699]],[2,"mixamorig:RightHandThumb2",34,[-47],[0,"afwyamqHxYyZ825tjrjlBV",1,0],[1,0.00004577874642563984,0.0002851900353562087,9.76903020283304e-13],[3,-0.03436001471277744,-1.1703207181300893e-17,1.3845751760198856e-16,0.9994095203613671],[1,-3.9381428156655796,-7.951387196342262e-16,1.590277404328017e-14]],[4,"mixamorig:RightHandThumb3",35,[[6,"mixamorig:RightHandThumb4",-48,[0,"87+2AeuptWno8Rk5lXH0rW",1,0],[1,-0.000053265568567439914,0.0002398724900558591,1.2418088475921185e-12]]],[0,"38KTHyFuVY2JCRq1iDY4tl",1,0],[1,0.000007486824870284181,0.0003052172251045704,-7.569678391050605e-13],[3,-0.032839622236125764,-1.0402726745431367e-17,-3.4180599473600103e-19,0.9994606341479332],[1,-3.763820226237835,-1.192707981913259e-15,-2.2584621885947954e-24]],[2,"mixamorig:RightHandIndex1",3,[-49],[0,"6aRm70o5dSk7Z3/ZK4Spng",1,0],[1,0.00030711886938661337,0.000919238431379199,0.0000034693648558459245],[3,0.03209513125428754,0.0000720654805088748,0.002244171038414189,0.9994822965178958],[1,3.6784721165838596,1.3841925584097183e-7,0.2572958332414626]],[2,"mixamorig:RightHandIndex2",37,[-50],[0,"6612jF0qpTO7RJIIoUUZ19",1,0],[1,1.8532638534907164e-7,0.00028897999436594546,2.1930235947521803e-13],[3,0.001826243593952678,-3.463105169653086e-18,3.4757773698593e-18,0.9999983324157775],[1,0.2092722169189454,-3.9756934192500746e-16,3.9756935215657585e-16]],[4,"mixamorig:RightHandIndex3",38,[[6,"mixamorig:RightHandIndex4",-51,[0,"27ufsTe1Ja3IGaszSLJkys",1,0],[1,-1.4158507610773086e-7,0.00022320658899843693,-2.3770718466514795e-12]]],[0,"54togpX3xc/Ya7BAuPIa2Y",1,0],[1,-4.374053474975881e-8,0.0002751474967226386,-2.597189228004809e-13],[3,0.08667293359594236,-5.409245977822002e-18,1.7883368913025672e-17,0.9962368205310791],[1,9.944463986031954,-7.951386883314413e-16,1.9878467457111655e-15]],[2,"mixamorig:RightHandMiddle1",3,[-52],[0,"eeyWTgoYBWGq4hoJS9+lNQ",1,0],[1,0.00011556326353456825,0.0008501270785927773,-0.000011564569831534754],[3,0.00577383673883986,0.00007508556144422248,0.013002579082477192,0.999898789932599],[1,0.6616925649864962,3.6604022373133574e-7,1.4900526412089434]],[2,"mixamorig:RightHandMiddle2",40,[-53],[0,"9cvahg5ZVcea83bzlMcqjL",1,0],[1,-1.806518312719163e-8,0.00035920762456953526,2.201827695863523e-12],[3,0.028868700240485906,3.0047525278160305e-19,1.0404003406938218e-17,0.9995832122171846],[1,3.3085690374406607,-4.27296891267723e-24,1.1927080765459934e-15]],[4,"mixamorig:RightHandMiddle3",41,[[6,"mixamorig:RightHandMiddle4",-54,[0,"24yIqIXqBdr71K/6Y8TXlR",1,0],[1,-1.3738190141054929e-8,0.0003108302771579474,4.684541600116776e-13]]],[0,"022qYcN2tTTryiZDpKZtT9",1,0],[1,3.180701213523207e-8,0.0003459697763901204,8.126299654888369e-13],[3,-0.008004923570330304,0,0,0.9999679600860385],[1,-0.917306468637145,0,0]],[2,"mixamorig:RightHandRing1",3,[-55],[0,"26yid6ipBabYmxi4mLILcr",1,0],[1,-0.00011700035247486085,0.0008750602719374001,-0.000034696855436777696],[3,0.06520717497930653,-0.000565443412708085,-0.008652688811837613,0.9978340721689607],[1,7.477778787275913,-1.501018349958383e-7,-0.9936524387164839]],[2,"mixamorig:RightHandRing2",43,[-56],[0,"62CgGJdUdQr5qWql9KbZPu",1,0],[1,4.1907554759745835e-8,0.0003373823710717261,-1.1067347125554017e-12],[3,-0.051755647526689506,-6.8622580248408815e-18,-1.6584258686647126e-18,0.9986597783775478],[1,-5.9334112707622255,-7.951386794252209e-16,-1.4908850022410098e-16]],[4,"mixamorig:RightHandRing3",44,[[6,"mixamorig:RightHandRing4",-57,[0,"0fXH3RKXJbarWoMrSD6Uhz",1,0],[1,-1.1000427235785537e-9,0.0002745992678683251,-4.333533586229482e-13]]],[0,"7c8nkyOJdQhrx0PfE9PdUr",1,0],[1,-4.08075173652378e-8,0.00031730675254948437,-1.4353629233538473e-13],[3,0.025049690801584527,1.6295358320094447e-20,6.503172134047256e-19,0.9996862072624313],[1,2.8707834053536425,-1.8763097731258627e-26,7.454425479090936e-17]],[2,"mixamorig:RightHandPinky1",3,[-58],[0,"95Z8n4VIFRyIl3UhBiyxY7",1,0],[1,-0.00030568178044632077,0.00089476682478562,-0.0000018865629272113438],[3,0.06627648210414713,-0.0010617468324496087,-0.01598265367231633,0.9976727195805011],[1,7.601273124156309,-2.0519507111699372e-7,-1.8355925021150277]],[2,"mixamorig:RightHandPinky2",46,[-59],[0,"ccNuGb8W1Zk5ifRKqLKHey",1,0],[1,-9.213380280925776e-8,0.00025239953538402915,1.0432011157690546e-12],[3,-0.021556341459605412,-3.431246421193364e-18,-1.809108886247682e-18,0.9997676350747092],[1,-2.4703661198670726,-3.975693279420132e-16,-1.9878465811845898e-16]],[4,"mixamorig:RightHandPinky3",47,[[6,"mixamorig:RightHandPinky4",-60,[0,"0egGCpTpxVjLOdwQl4Z6cN",1,0],[1,8.785855953874488e-8,0.00017147728067357093,2.740918657404695e-13]]],[0,"f40AjCoUNSz4A0M78TfJ78",1,0],[1,4.275765519423658e-9,0.00021083522005937994,-1.2460654253212966e-12],[3,0.0010401128046228702,6.938890150538297e-18,-7.217232399373484e-21,0.9999994590825305],[1,0.11918816933513304,7.951386703658791e-16,0]],[2,"mixamorig:LeftUpLeg",4,[-61],[0,"bcM4pymaZd9IA1vORMKCbH",1,0],[1,0.0008215957786887884,-0.00046323894639499485,0.00008842535316944122],[3,-0.000002313089932168625,-0.0015441605516553654,0.9999976858428152,-0.0014979558920172275],[1,179.8230511720561,179.9994698777057,-0.17165255126612483]],[2,"mixamorig:LeftLeg",49,[-62],[0,"a4ytzxHttTmprf1p+44y9f",1,0],[1,-8.5252361810631e-14,0.0038936142809689045,-4.1768080964385557e-13],[3,-0.016117351339226375,-0.00003796069408301784,0.0023549564954636636,0.9998673330620909],[1,-1.8469975117931086,3.749486791235015e-10,0.2698934431923125]],[2,"mixamorig:LeftFoot",50,[-63],[0,"f7envWH8dedI3rgXx2d+L1",1,0],[1,1.4130095747980076e-12,0.0039025177247822285,6.2382069995758904e-12],[3,0.44612859977206404,0.0024843718465414003,-0.001238428502402574,0.8949645616764891],[1,52.99135786085413,0.3180989938466041,-3.3072239864412766e-8]],[4,"mixamorig:LeftToeBase",51,[[6,"mixamorig:LeftToe_End",-64,[0,"d9u8s5gmddZKu+fGf539ia",1,0],[1,-1.4418701692678337e-13,0.0006381655111908913,-5.57874057330489e-16]]],[0,"8bQlCId5BXcLLiqd4OBAJj",1,0],[1,-2.788708120763511e-13,0.0017521448899060488,2.9801588280475855e-11],[3,0.334477300473174,-0.007931112194664275,0.0028150174351094398,0.9423662284931341],[1,39.08295236842311,-0.9643990207261324,4.203737730997657e-8]],[2,"mixamorig:RightUpLeg",4,[-65],[0,"57XA1fZ7xegY3bybR4gTSb",1,0],[1,-0.0008215957786887884,-0.00046323894639499485,0.00011038672528229654],[3,0.0000029182047593587035,-0.0019481254671427967,0.9999969804666633,0.001497950668126878],[1,179.77675987204478,-179.999331195764,0.17165158940962907]],[2,"mixamorig:RightLeg",53,[-66],[0,"9eSrDkgnhW6LlFqX4hv63v",1,0],[1,-6.52771185629536e-13,0.0038936254568398,4.94762379937147e-13],[3,-0.02053978118231616,0.000048371774272083224,-0.0023545255071987627,0.9997862627875971],[1,-2.3538576039940744,-3.761112273909386e-10,-0.2698659302214446]],[2,"mixamorig:RightFoot",54,[-67],[0,"7bzI1ts3xcW7aWVyO5PIGf",1,0],[1,-6.426244085477872e-13,0.0039040313567966223,3.1067544370433353e-12],[3,0.45445113796258707,-0.002408697937718692,0.0012288678979694532,0.8907675629828713],[1,54.05946381742756,-0.30986286224317433,1.6489466027981544e-8]],[4,"mixamorig:RightToeBase",55,[[6,"mixamorig:RightToe_End",-68,[0,"46ByyRe7NRkoGJ9xDuA2DW",1,0],[1,-1.3575349611799625e-13,0.0006400716956704855,-2.14973002134113e-15]]],[0,"35SESBLQReapfOB1LvVLJI",1,0],[1,-1.1366921266004956e-13,0.001771859242580831,-1.4155508362700964e-11],[3,0.33023784392920336,0.007915917982534692,-0.0027696211585726866,0.9438604949239707],[1,38.56783451504961,0.9610277499709207,-3.554740757534538e-8]]],0,[0,3,1,0,7,1,0,-1,6,0,-2,4,0,-1,16,0,-2,19,0,-3,22,0,-4,25,0,-5,28,0,-1,34,0,-2,37,0,-3,40,0,-4,43,0,-5,46,0,-1,9,0,-2,49,0,-3,53,0,-1,11,0,-2,13,0,-3,31,0,-1,7,0,-1,8,0,7,8,0,-1,10,0,-1,12,0,0,12,0,-1,14,0,-1,15,0,-1,17,0,-1,18,0,0,18,0,-1,20,0,-1,21,0,0,21,0,-1,23,0,-1,24,0,0,24,0,-1,26,0,-1,27,0,0,27,0,-1,29,0,-1,30,0,0,30,0,-1,32,0,-1,33,0,-1,35,0,-1,36,0,0,36,0,-1,38,0,-1,39,0,0,39,0,-1,41,0,-1,42,0,0,42,0,-1,44,0,-1,45,0,0,45,0,-1,47,0,-1,48,0,0,48,0,-1,50,0,-1,51,0,-1,52,0,0,52,0,-1,54,0,-1,55,0,-1,56,0,0,56,0,12,1,2,0,15,3,0,33,5,0,10,68],[0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,14,15,-1,16],[75,8,8,8,8,8,8,8,76,77,78,31,31]],[[[26,"Sasuke_CurseForm:sa2_tex01_sa2_tex01_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[6],[6]],[[[41,"Skin-0",1801620811,["mixamorig:Hips","mixamorig:Hips/mixamorig:Spine","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3/mixamorig:LeftHandIndex4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3/mixamorig:RightHandIndex4","mixamorig:Hips/mixamorig:LeftUpLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase/mixamorig:LeftToe_End","mixamorig:Hips/mixamorig:RightUpLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase"],[[[7,0.9999898672103882,0.004499795380979776,0.00016590868472121656,0,-0.0044997986406087875,0.9999898672103882,0.000019881459593307227,0,-0.00016581753152422607,-0.000020627812773454934,1,0,0.010846395045518875,-2.667616128921509,-0.003845944767817855,1],[7,1,-1.3099464221677515e-11,-1.4637199785560995e-10,0,1.7095958329549354e-11,0.9996262788772583,0.027337132021784782,0,1.459591891794787e-10,-0.027337132021784782,0.9996262788772583,0,-0.0021625214722007513,-2.8900632858276367,-0.07671220600605011,1],[7,1,-1.3099467691124467e-11,-1.4637198397782214e-10,0,1.7095958329549354e-11,0.9996262788772583,0.027337104082107544,0,1.459591891794787e-10,-0.027337104082107544,0.9996262788772583,0,-0.0021625214722007513,-3.150846004486084,-0.07671211659908295,1],[7,1,-1.3099467691124467e-11,-1.4637198397782214e-10,0,1.7095958329549354e-11,0.9996262788772583,0.027337104082107544,0,1.459591891794787e-10,-0.027337104082107544,0.9996262788772583,0,-0.0021625214722007513,-3.4488837718963623,-0.07671211659908295,1],[7,1,-1.709596006427283e-11,-1.459591891794787e-10,0,1.7095958329549354e-11,1,-4.975397427386952e-9,0,1.459591891794787e-10,4.975397427386952e-9,1,0,-0.0021625214722007513,-3.7848587036132812,0.02676498144865036,1],[7,1,-1.709596006427283e-11,-1.459591891794787e-10,0,1.7095958329549354e-11,1,-4.975397427386952e-9,0,1.459591891794787e-10,4.975397427386952e-9,1,0,-0.0021625214722007513,-3.9602181911468506,0.01282343827188015,1],[7,-0.016290731728076935,0.9178345799446106,-0.39662861824035645,0,-0.030321549624204636,-0.3969523310661316,-0.9173382520675659,0,-0.9994074106216431,-0.0029177162796258926,0.03429681062698364,0,0.087038554251194,1.3198095560073853,3.4444446563720703,1],[7,-4.298451585782459e-7,1,0.0000028718056910292944,0,-0.04814692586660385,0.000002847779569492559,-0.9988402724266052,0,-0.9988402724266052,-5.676152454725525e-7,0.04814692586660385,0,0.14220580458641052,-0.49010801315307617,3.5391178131103516,1],[7,-5.788055545963289e-7,1,0.0000037042025269329315,0,-0.04773478955030441,0.0000036723508856084663,-0.9988600611686707,0,-0.9988600611686707,-7.549650717919576e-7,0.04773478955030441,0,0.14074566960334778,-1.0398361682891846,3.539175510406494,1],[7,1.1837277824611192e-8,1,0.0000030816638627584325,0,-0.048439331352710724,0.0000030786197839915985,-0.9988261461257935,0,-0.9988261461257935,-1.3745035687406926e-7,0.048439331352710724,0,0.1432410031557083,-1.7273132801055908,3.539076328277588,1],[7,7.031321729300544e-7,1,0.0000025162041765725007,0,-0.04743378609418869,0.000002546724090279895,-0.9988743662834167,0,-0.9988743662834167,5.829876386087562e-7,0.04743378609418869,0,0.1396767497062683,-1.990701675415039,3.539219856262207,1],[7,0.10660994797945023,0.9929233193397522,0.05232222005724907,0,-0.044367555528879166,0.0573202446103096,-0.9973694682121277,0,-0.9933105707168579,0.10400810092687607,0.05016448721289635,0,-0.08606373518705368,-2.2028651237487793,3.4284348487854004,1],[7,0.024811597540974617,0.9729511141777039,0.2296748161315918,0,-0.0327962264418602,0.23041407763957977,-0.9725398421287537,0,-0.9991540312767029,0.016597799956798553,0.03762606531381607,0,0.03635639697313309,-2.8339414596557617,2.9692296981811523,1],[7,0.024811597540974617,0.9729511141777039,0.2296748161315918,0,-0.0327962264418602,0.23041407763957977,-0.9725398421287537,0,-0.9991540312767029,0.016597799956798553,0.03762606531381607,0,0.03519659861922264,-2.8794307708740234,2.958491325378418,1],[7,-0.009473015554249287,-0.9178282022476196,0.39686480164527893,0,0.029250754043459892,-0.3969671130180359,-0.917366623878479,0,0.9995272159576416,0.002918366575613618,0.030607642605900764,0,-0.0830429345369339,1.3239909410476685,3.4427363872528076,1],[7,-0.0000013258173794383765,-1,0.000014421413652598858,0,0.043625734746456146,-0.000014465523236140143,-0.9990479350090027,0,0.9990479350090027,-6.954103923817456e-7,0.043625734746456146,0,-0.12936803698539734,-0.48571932315826416,3.5395894050598145,1],[7,-6.480571528300061e-7,-1,0.000014825873222434893,0,0.043330345302820206,-0.000014840028597973287,-0.9990608096122742,0,0.9990608096122742,-5.038293782178016e-9,0.043330345302820206,0,-0.12832078337669373,-1.0353409051895142,3.539628028869629,1],[7,-0.0000012168379726062994,-1,0.000015472989616682753,0,0.04467407613992691,-0.00001551190325699281,-0.9990016222000122,0,0.9990016222000122,-5.243815621724934e-7,0.04467407613992691,0,-0.1330825388431549,-1.7224277257919312,3.5394532680511475,1],[7,-8.788971967987891e-7,-1,0.000016392734323744662,0,0.044323716312646866,-0.000016415579011663795,-0.9990172386169434,0,0.9990172386169434,-1.5144654241794342e-7,0.044323716312646866,0,-0.1318405717611313,-1.982922077178955,3.539501428604126,1],[7,0.18388088047504425,-0.9828363060951233,0.014853437431156635,0,0.04494545981287956,-0.006688280031085014,-0.9989670515060425,0,0.9819204211235046,0.18435853719711304,0.042944181710481644,0,0.23630960285663605,-1.9534801244735718,3.569206714630127,1],[7,-0.10690183192491531,-0.9940528273582458,-0.020760957151651382,0,0.044052377343177795,0.016124717891216278,-0.9988991022109985,0,0.9932932257652283,-0.1076987087726593,0.042066626250743866,0,-0.35266193747520447,-2.1207945346832275,3.495948314666748,1],[7,-0.10690183192491531,-0.9940528273582458,-0.020760957151651382,0,0.044052377343177795,0.016124717891216278,-0.9988991022109985,0,0.9932932257652283,-0.1076987087726593,0.042066626250743866,0,-0.3571995496749878,-2.162992477416992,3.495065689086914,1],[7,-0.9898097515106201,0.14239467680454254,0.0006407079054042697,0,-0.14230754971504211,-0.9893428683280945,0.030810756608843803,0,0.005021167453378439,0.03040560893714428,0.9995250105857849,0,0.761311948299408,2.457200050354004,-0.0758100301027298,1],[7,-0.9895557761192322,-0.14347794651985168,-0.013909445144236088,0,0.1441490650177002,-0.9844818115234375,-0.10008323192596436,0,0.0006661424995400012,-0.1010429710149765,0.9948818683624268,0,0.30901339650154114,1.6348856687545776,0.13886946439743042,1],[7,-0.6431164741516113,0.5541620850563049,0.5284936428070068,0,0.057831570506095886,-0.6530296206474304,0.7551210522651672,0,0.7635815143585205,0.5161944627761841,0.38792604207992554,0,0.5426609516143799,-0.46088889241218567,-0.5698953866958618,1],[7,-2.245610475540161,-0.06638174504041672,1.008784532546997,0,1.0016310214996338,-0.4215422570705414,2.1830010414123535,0,0.14764022827148438,1.8501887321472168,0.5335628986358643,0,1.9458205699920654,-0.6207966804504395,-1.281934380531311,1],[7,-2.245610475540161,-0.06638174504041672,1.008784532546997,0,1.0016310214996338,-0.4215422570705414,2.1830010414123535,0,0.14764022827148438,1.8501887321472168,0.5335628986358643,0,1.9458205699920654,-0.972396969795227,-1.281934380531311,1],[7,-0.9873265027999878,-0.1586887091398239,0.002055590972304344,0,0.15670228004455566,-0.9727541208267212,0.1708621233701706,0,-0.025114305317401886,0.16901881992816925,0.9852927923202515,0,-0.7962436079978943,2.411924362182617,-0.43505725264549255,1],[7,-0.7584125995635986,0.15131910145282745,-0.6339659690856934,0,0.03830016031861305,-0.9606488943099976,-0.2751123309135437,0,-0.6506484746932983,-0.23292964696884155,0.7227727174758911,0,-0.37594932317733765,1.6585606336593628,-0.03288853168487549,1],[7,-0.8096542954444885,-0.4753130376338959,-0.3442925810813904,0,-0.023312821984291077,-0.5601133704185486,0.8280878663063049,0,-0.5864438414573669,0.6784913539886475,0.44241732358932495,0,-0.6058793663978577,-0.5476188659667969,-0.4570145905017853,1],[7,-0.9464408159255981,0.22765061259269714,-0.2793710231781006,0,-0.3189505338668823,-0.4699833393096924,0.8869024515151978,0,0.050202466547489166,1.3058403730392456,0.36790743470191956,0,-0.8896846175193787,-0.3769020736217499,-0.5114152431488037,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[26,"T_CHR_Pain_SC_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true}]]],0,0,[0],[6],[6]],[[[22,".bin",2112511563,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":3345792,"length":226152,"count":113076,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":3878280,"length":20940,"count":10470,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[2],"indexView":{"offset":3918036,"length":1344,"count":336,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[3],"indexView":{"offset":3922452,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3345792,"count":34852,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3571944,"length":306336,"count":3191,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3899220,"length":18816,"count":196,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3919380,"length":3072,"count":32,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,22,23,24,25,26,27,28,29,30],[0,14,15,16,17,18,19,20,21]]},"minPosition",8,[1,-2.1207799911499023,-0.007093213964253664,-0.4782893657684326],"maxPosition",8,[1,2.124208927154541,4.707925796508789,0.7377506494522095]]],-1],0,0,[],[],[]],[[[29],[50,"Angry",[-3,-4],[[42,-2,[9,"9duOpALmRaaIxsSHSN3rRV"],[6,7],8]],[0,"57eOudXfRV/Z0AvZX5sF0e",-1,0]],[2,"mixamorig:Hips",1,[-5,-6,-7],[0,"b4mhUYK4Jbm5RdOSGz5kXB",1,0],[1,0.0011580792488530278,2.667637825012207,0.0037927161902189255],[3,-0.000010127343845886347,0.00008293176742535183,-0.0022499042738068345,0.9999974654720468],[1,-0.0011391352401385947,0.009500741633990489,-0.25782035125692865]],[51,"mixamorig:Spine2",[-8,-9,-10],[0,"6daSXYArpWToFVKgWNYeHg",1,0],[1,-2.7755574995243454e-19,0.29803770780563354,-3.631598077813436e-10]],[52,"polySurface3",1,[[43,-11,[9,"310J1oB4VW0I65S53AgmVB"],[0,1,2,3],[21],1,4,5]],[0,"8csyybsQxQ46hpSAv0EKr1",1,0]],[2,"mixamorig:Spine",2,[-12],[0,"3euqPpOe9ZGLyNRDn8duoP",1,0],[1,2.2204459996194763e-18,0.22344481945037842,-0.006110615562647581],[3,-0.013659682285280115,-0.00011367992689700347,0.002248560337681096,0.9999041674746373],[1,-1.5653155498733697,-0.009505971779949583,0.2578201533448801]],[34,"mixamorig:Spine1",5,[3],[0,"c1ER5mpGNc5bKhXL2mpJ8T",1,0],[1,-2.7755574995243454e-19,0.2607825994491577,-3.67367837539323e-11]],[2,"mixamorig:Neck",3,[-13],[0,"80qtlhQE9QFaftMYIEUJXW",1,0],[1,0,0.335292249917984,1.8251015143633254e-9],[3,0.013669830138125056,-3.951769289393884e-14,-2.2793535175614365e-13,0.9999065635068083],[1,1.566495936750165,-4.170922239081774e-12,-2.617892918077948e-11]],[53,"mixamorig:Head",7,[[6,"mixamorig:HeadTop_End",-14,[0,"22dg/qx7pUEoWE4PIJ2SEr",1,0],[1,0,0.6312945485115051,0.050189580768346786]]],[0,"adFGNbZINdA49hQNW2ncBE",1,0],[1,-2.7755574995243454e-19,0.17535950243473053,0.01394154317677021]],[2,"mixamorig:LeftShoulder",3,[-15],[0,"bev/8CcutbJ5IQSxPF3X+/",1,0],[1,0.15405386686325073,0.2367461770772934,-0.0032258639112114906],[3,-0.5854969763875152,-0.3906276917609622,0.5962846424952677,-0.38606725087071425],[1,113.37366013895243,90.93343593002214,-0.17127341096991378]],[2,"mixamorig:LeftArm",9,[-16],[0,"4a0YawUFVTSYWycNALkGw5",1,0],[1,1.3289903899593725e-10,0.36377090215682983,3.0223070712764866e-9],[3,-0.20245387608595988,-0.007082748968661206,0.009782358742315998,0.979217324286215],[1,-23.35645586120754,-0.5679567464250997,1.2620971998527304]],[2,"mixamorig:LeftForeArm",10,[-17],[0,"e4WC6RpulZpK5jgYjascDL",1,0],[1,5.312988382577544e-10,0.5497251749038696,7.229476128856049e-9],[3,-4.1642106476154595e-7,0.000206306252196236,-7.380189813203538e-8,0.9999999787187754],[1,-0.00004771659325950412,0.02364095524019035,-0.000008466918977747983]],[2,"mixamorig:LeftHand",11,[-18],[0,"f3ti9A5wxe443+nsGkb1Hz",1,0],[1,2.2853942349687628e-10,0.6874792575836182,1.6264111835084805e-8],[3,3.1139097619800044e-7,-0.0003526802747699277,2.9412478776370004e-7,0.9999999378082182],[1,0.000035694662022898585,-0.0404141833719694,0.00003369163127021046]],[2,"mixamorig:LeftHandIndex1",12,[-19],[0,"fdtvFrewFWL4O3susQL8Ah",1,0],[1,-2.2166732338568806e-10,0.26339036226272583,8.402309958910337e-10],[3,2.8283761610204216e-7,0.000503349172381836,3.470562122848771e-7,0.9999998733196972],[1,0.000032390781222735767,0.057679568822143874,0.00003978602134846135]],[2,"mixamorig:LeftHandIndex2",13,[-20],[0,"f0Nk+HSXBYwKIWzVvXyl2+",1,0],[1,-6.062828711295154e-11,0.02637527883052826,-5.341831976757305e-10],[3,-0.02620626207624835,-9.483139130982648e-8,0.053399178451361405,0.9982293121165604],[1,-3.0162732767973313,0.16126703599573244,6.11989057404939]],[4,"mixamorig:LeftHandIndex3",14,[[6,"mixamorig:LeftHandIndex4",-21,[0,"0aq7v6NJ1Rr7bTu3hCjSGo",1,0],[1,0.0011597954435274005,0.04548925533890724,0.010738188400864601]]],[0,"0fdPMlBfBT772jl6GaL5/j",1,0],[1,0.006114770192652941,0.0569533072412014,0.003001295030117035],[3,-0.08900110490952105,0.011649856432072293,-0.03973706096695348,0.995170362378073],[1,-10.183422107077348,0.9263548972211644,-4.655475096758343]],[2,"mixamorig:RightShoulder",3,[-22],[0,"22rWnVGG1bULNMaJTdLOQD",1,0],[1,-0.15405386686325073,0.23671716451644897,-0.0021648688707500696],[3,0.5877728012351628,-0.38956914320869385,0.5941147952016342,0.38702277311591626],[1,113.38447753657557,-90.54277286042233,0.10975689478373567]],[2,"mixamorig:RightArm",16,[-23],[0,"115KK0BQ9SvZU1cGI55Kh5",1,0],[1,-1.2277036331997948e-10,0.36377090215682983,3.0227449432373987e-9],[3,-0.20259784586976592,0.0060825912626321,-0.006094895431084702,0.9792241659508544],[1,-23.374813009805514,0.5410976212429657,-0.8251552181607292]],[2,"mixamorig:RightForeArm",17,[-24],[0,"7aE99dPBhauaxlmY56BJ3x",1,0],[1,2.8092997372830553e-10,0.5496230125427246,-1.5400685171584882e-8],[3,2.020114613495015e-7,-0.00014783539356697775,-3.367182407185052e-7,0.999999989072271],[1,0.000023143103805498426,-0.01694068828200183,-0.000038588489948021875]],[2,"mixamorig:RightHand",18,[-25],[0,"6092J2ICJWZawZC72rMZ3z",1,0],[1,1.268639748808198e-9,0.6870890855789185,-1.1725145299124051e-8],[3,3.2420365812582107e-7,0.0006725176436513792,2.7420211149712315e-7,0.9999997738598938],[1,0.00003712986288200792,0.07706485105758092,0.00003144622504386465]],[2,"mixamorig:RightHandIndex1",19,[-26],[0,"a1CXoFK2Bc6JEbmsTKtT35",1,0],[1,3.739666076807424e-10,0.2604975998401642,-5.87745763169778e-9],[3,4.5988326039729427e-7,-0.0001753483639149625,-1.661765171011531e-7,0.9999999846263561],[1,0.00005269539991052672,-0.020093442487913254,-0.000019051666513208738]],[2,"mixamorig:RightHandIndex2",20,[-27],[0,"23WcQpO0tVVZCZXMThXkvG",1,0],[1,-2.6808605335659763e-10,0.03343874588608742,1.2735505983130224e-9],[3,0.007450563105110725,-1.5176551985164344e-8,-0.09233795358388798,0.995699850073985],[1,0.8648800363121595,0.08020138488289544,-10.595944331778327]],[4,"mixamorig:RightHandIndex3",21,[[6,"mixamorig:RightHandIndex4",-28,[0,"1dgiiIvSdRWq63yokE/5yD",1,0],[1,0.004537614528089762,0.042197756469249725,0.0008824855904094875]]],[0,"f8bUpVLWVcbLLOAy+5oGPN",1,0],[1,-0.010459652170538902,0.055907636880874634,-0.0008436270873062313],[3,-0.017776792398951666,-0.0011294173010960435,0.14549880835163595,0.9891980624914399],[1,-2.084948198306202,0.17581136415550583,16.731940737432605]],[2,"mixamorig:LeftUpLeg",2,[-29],[0,"22iz2voKZZpJqwQHU48Lrt",1,0],[1,0.4031160771846771,-0.12413574010133743,-0.006489744409918785],[3,0.0013012949144381456,0.01534401839103032,0.9971683203709634,-0.07360848171041835],[1,-178.21610675008915,-179.71883386190214,-8.439219352619322]],[2,"mixamorig:LeftLeg",23,[-30],[0,"e6lrk+WVlWqoOfXKHiJo98",1,0],[1,-1.4210854397564648e-16,0.9731911420822144,-1.092369771027446e-11],[3,-0.06549388822248363,0.0072233177626552835,-0.14306267892710434,0.9875178196793214],[1,-7.62747402710362,-0.26725870226595966,-16.469210555586887]],[2,"mixamorig:LeftFoot",24,[-31],[0,"bakvNTAFZWlJ92dLzG20+e",1,0],[1,-0.5729619860649109,1.4039828777313232,0.16085809469223022],[3,0.455796599706778,-0.3751561942339122,0.19140402986079605,0.7841376071689931],[1,59.224504512063326,-49.773602639729,-2.3965584192150398]],[28,"mixamorig:LeftToeBase",25,[[6,"mixamorig:LeftToe_End",-32,[0,"fbIyN2ZKdSobgO2LTK36je",1,0],[1,-3.966003525590622e-9,0.3516002893447876,5.763488797327909e-9]]],[0,"6bXK0TsXhXkJn8YXnhU9lk",1,0],[1,0.24691450595855713,0.20412278175354004,0.1171284168958664],[3,0.11970339850469584,0.029039157881980037,-0.4139738129569312,0.901916573681752],[1,0.4059600830078125,0.5266585350036621,0.4059600830078125],[1,20.8945364898414,13.011688859698419,-47.713318184424466]],[2,"mixamorig:RightUpLeg",2,[-33],[0,"52YB24I99ar4h7GhLosUP7",1,0],[1,-0.4031160771846771,-0.12413574010133743,-0.0028610515873879194],[3,-0.006078488188718549,0.08552653335824788,0.9933246962440877,0.07716418796728793],[1,-170.0455735176693,178.53460607113178,8.757829394750232]],[2,"mixamorig:RightLeg",27,[-34],[0,"583oCTCaRc2qowd3VEY7wG",1,0],[1,1.4210854397564648e-16,0.9731873273849487,1.0302656644478603e-10],[3,-0.24301073827643477,0.33019559736303467,0.07347970269138572,0.9091300137256477],[1,-29.377347727567976,39.518255491913614,-1.5401210070395412]],[2,"mixamorig:RightFoot",28,[-35],[0,"96/ZBFrEtfVrlnaDhTcrlP",1,0],[1,0.17291708290576935,1.414926528930664,0.6849043369293213],[3,0.5866004849754515,-0.028106417627274904,0.0429657475999835,0.8082473908698382],[1,72.0424160493259,-5.5034200269774995,2.0905812470967517]],[28,"mixamorig:RightToeBase",29,[[6,"mixamorig:RightToe_End",-36,[0,"f3l1FSYxdfFqXF+GtJJdYb",1,0],[1,7.068791330056001e-9,0.3249409794807434,1.3591366920806536e-9]]],[0,"d029L2YzFZU61mfG+U3Gx9",1,0],[1,-0.12789864838123322,0.18174734711647034,0.14669384062290192],[3,0.05166032088529188,-0.025251386311960593,0.35667919582636354,0.9324556450577214],[1,1,0.7110411524772644,1],[1,8.782063729060386,-6.4348944047095396,41.495870735273826]]],0,[0,3,1,0,7,1,0,-1,4,0,-2,2,0,-1,5,0,-2,23,0,-3,27,0,-1,7,0,-2,9,0,-3,16,0,7,4,0,-1,6,0,-1,8,0,0,8,0,-1,10,0,-1,11,0,-1,12,0,-1,13,0,-1,14,0,-1,15,0,0,15,0,-1,17,0,-1,18,0,-1,19,0,-1,20,0,-1,21,0,-1,22,0,0,22,0,-1,24,0,-1,25,0,-1,26,0,0,26,0,-1,28,0,-1,29,0,-1,30,0,0,30,0,12,1,3,0,6,36],[0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,14,15,-1,-2,16],[32,32,79,80,81,82,33,19,33]],[[[26,"T_CHR_Pain_BC_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true}]]],0,0,[0],[6],[6]],[[[26,"T_CHR_PainEye_BC_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true}]]],0,0,[0],[6],[6]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[11],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[57,[[58,[59,[-16,-17,-18,-19,-20,-21,-22],[[60,-5,-4],[23,0,false,-7,-6,[[61,"Victory"]]],[37,0.1,-9,-8],[23,0.1,false,-11,-10,[[62,[38,"Fail"]]]],[23,0.1,false,-13,-12,[[63,1,[38,"Fail"]]]],[37,0,-15,-14]],-3,-2,-1]]],[{},"Victory",4,[64,2],"Fail",4,[65,1,false]]],[24,"Idle",[19,0]],[25,"Entry"],[24,"Jump",[19,1]],[66,"Fail",2,[19,2]],[24,"Victory",[19,3]],[25,"Exit"],[25,"Any"]],0,[0,17,7,0,18,6,0,19,2,0,9,1,0,10,2,0,9,5,0,10,1,0,9,1,0,10,5,0,9,4,0,10,1,0,9,3,0,10,4,0,9,1,0,10,3,0,-1,2,0,-2,6,0,-3,7,0,-4,1,0,-5,3,0,-6,4,0,-7,5,22],[0,0,0,0],[13,13,13,13],[23,83,84,85]],[[[22,".bin",2124042801,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":75600,"length":5388,"count":2694,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":175380,"length":5628,"count":2814,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[2],"indexView":{"offset":186192,"length":144,"count":72,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":75600,"count":1050,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":80988,"length":94392,"count":1311,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":181008,"length":5184,"count":72,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,25,27,28,29],[0,1,2,3,5,6,8,9,10,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]]},"minPosition",8,[1,-2.2465627193450928,-1.4147316217422485,-0.14921867847442627],"maxPosition",8,[1,2.2469348907470703,1.2410751581192017,3.456017255783081]]],-1],0,0,[],[],[]],[[[41,"Skin-0",817915499,["RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck/RigHead/RigJaw","RigPelvis/RigSpine1/RigSpine2/RigRibcage","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck/RigHead","RigPelvis/RigSpine1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone","RigPelvis","RigPelvis/RigLLeg1","RigPelvis/RigRLeg1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmThumb1","RigPelvis/RigRLeg1/RigRLeg2/RigRLegAnkle/RigRLegFeet1","RigPelvis/RigRLeg1/RigRLeg2/RigRLegAnkle","RigPelvis/RigRLeg1/RigRLeg2/RigRLegAnkle/RigRLegFeet1/RigRLegFeet2","RigPelvis/RigRLeg1/RigRLeg2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmIndex1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmPinky1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmThumb1/RigRArmThumb2/RigRArmThumb3","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmThumb1/RigRArmThumb2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmIndex1/RigRArmIndex2/RigRArmIndex3","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmPinky1/RigRArmPinky2/RigRArmPinky3","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmIndex1/RigRArmIndex2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRArmCollarbone/RigRArm1/RigRArm2/RigRArmPalm/RigRArmPinky1/RigRArmPinky2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2","RigPelvis/RigLLeg1/RigLLeg2","RigPelvis/RigLLeg1/RigLLeg2/RigLLegAnkle/RigLLegFeet1/RigLLegFeet2","RigPelvis/RigLLeg1/RigLLeg2/RigLLegAnkle","RigPelvis/RigLLeg1/RigLLeg2/RigLLegAnkle/RigLLegFeet1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmThumb1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmIndex1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmPinky1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmThumb1/RigLArmThumb2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmThumb1/RigLArmThumb2/RigLArmThumb3","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmIndex1/RigLArmIndex2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmPinky1/RigLArmPinky2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmIndex1/RigLArmIndex2/RigLArmIndex3","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLArmCollarbone/RigLArm1/RigLArm2/RigLArmPalm/RigLArmPinky1/RigLArmPinky2/RigLArmPinky3","RigPelvis/RigSpine1/RigSpine2"],[[[7,-4.366411587852781e-8,1.9674077122999734e-7,1,0,-0.9989171624183655,0.046523258090019226,-5.2769859593126967e-8,0,-0.046523258090019226,-0.9989171624183655,1.9449635146884248e-7,0,-0.44607535004615784,2.200519561767578,-4.981652637070511e-7,1],[7,-1.5753226279002774e-8,1.5393314356515475e-7,1,0,-0.3603912591934204,-0.9328011870384216,1.3791169806154358e-7,0,0.9328011870384216,-0.3603912591934204,7.017079184379327e-8,0,-1.7749855518341064,0.8204684853553772,-1.0736922462228904e-7,1],[7,6.123234262925839e-17,1.5099578831723193e-7,1,0,6.123234262925839e-17,-1,1.5099578831723193e-7,0,1,6.123232939436859e-17,-6.123234924670329e-17,0,-2.3677639961242676,-0.46382057666778564,2.060092363365129e-8,1],[7,-9.355651542364285e-8,0.000004330015144660138,1,0,0.03866314888000488,-0.9992522597312927,0.000004330394858698128,0,0.9992522597312927,0.03866314888000488,-7.39254559789515e-8,0,-1.0849337577819824,0.20653696358203888,-0.0000010066598861158127,1],[7,-0.8132864236831665,0.2096989005804062,-0.5427629351615906,0,-3.2782557468635787e-7,-0.9328011274337769,-0.36039143800735474,0,-0.5818636417388916,-0.2931012809276581,0.7586345076560974,0,0.9979068636894226,0.8098247051239014,-1.7474361658096313,1],[7,-4.944679776741623e-9,1.5127633901101945e-7,1,0,-0.11311965435743332,-0.9935814142227173,1.4974600048844877e-7,0,0.9935814142227173,-0.11311965435743332,2.2025266943614952e-8,0,-0.9249148964881897,0.10530219227075577,-2.050306591172557e-8,1],[7,0.2760924994945526,0.04952234774827957,-0.9598544239997864,0,0.11987888067960739,-0.9926475286483765,-0.016732309013605118,0,-0.9536257982254028,-0.11044660210609436,-0.2799991965293884,0,0.7537644505500793,0.07878638803958893,0.7263566255569458,1],[7,-0.27609020471572876,-0.04952109977602959,-0.9598551392555237,0,0.11987920850515366,-0.9926475286483765,0.01673118956387043,0,-0.9536263346672058,-0.11044736206531525,0.2799968123435974,0,0.753765881061554,0.07878755033016205,-0.726354718208313,1],[7,-0.6393546462059021,-0.49524739384651184,-0.5881800651550293,0,0.3134876489639282,-0.866380512714386,0.3887293040752411,0,-0.7021048665046692,0.06414869427680969,0.7091782689094543,0,0.5269625782966614,-0.47284215688705444,-1.8020299673080444,1],[7,-0.4288192689418793,-0.8638097047805786,-0.2644842565059662,0,-0.45980212092399597,-0.04331613704562187,0.8869614005088806,0,-0.7776214480400085,0.5019603371620178,-0.3786042630672455,0,-0.008296593092381954,-1.858841061592102,-0.2403862029314041,1],[7,-0.5626558065414429,0.569394052028656,-0.5993404388427734,0,-0.39316871762275696,-0.8220550417900085,-0.4118780791759491,0,-0.7272118330001831,0.0038963162805885077,0.686402440071106,0,0.2367289960384369,1.055180549621582,-1.5230520963668823,1],[7,-0.10204502195119858,-0.8112953901290894,-0.5756657719612122,0,-0.9355781674385071,-0.11837837100028992,0.33267733454704285,0,-0.3380436301231384,0.5725322365760803,-0.7469503879547119,0,-0.30063268542289734,-1.8734583854675293,-0.14338965713977814,1],[7,2.559229415055597e-7,-8.742280499518529e-8,-1,0,-1,-2.2312269151963764e-14,-2.559229415055597e-7,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,0.22627584636211395,-6.707426223329094e-7,-0.6907927989959717,1],[7,1.6829731919187907e-7,5.4388419101769614e-8,-1,0,-0.5789985656738281,-0.8153284192085266,-1.4178836238443182e-7,0,-0.8153284192085266,0.5789985656738281,-1.0572679087772485e-7,0,0.36179018020629883,0.1844886690378189,-0.6907928586006165,1],[7,2.559229415055597e-7,-8.742280499518529e-8,-1,0,-1,-2.231226745789787e-14,-2.559229415055597e-7,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.2804442346096039,-7.75447290379816e-7,-0.6907928586006165,1],[7,-0.18524940311908722,-0.19340552389621735,-0.9634714126586914,0,0.6776145696640015,-0.735213577747345,0.01729941926896572,0,-0.7117051482200623,-0.6496555209159851,0.2672522962093353,0,0.2152397483587265,0.25323501229286194,-0.7220711708068848,1],[7,-0.37161925435066223,-0.865531325340271,-0.3357970118522644,0,-0.6042612791061401,-0.04909731075167656,0.7952695488929749,0,-0.7048157453536987,0.4984503984451294,-0.5047587752342224,0,-0.6557630300521851,-1.8989371061325073,-0.08151581883430481,1],[7,-0.4085783064365387,-0.9031598567962646,-0.13180620968341827,0,-0.19394822418689728,-0.0552021786570549,0.9794536828994751,0,-0.8918784260749817,0.4257507622241974,-0.152610644698143,0,-0.6059405207633972,-1.9773274660110474,-0.34776943922042847,1],[7,-0.4077136516571045,-0.7666416168212891,-0.49601662158966064,0,-0.5797287225723267,-0.20235669612884521,0.789280354976654,0,-0.7054662108421326,0.609359085559845,-0.361939013004303,0,-0.5840604305267334,-1.894822359085083,-0.0179281048476696,1],[7,-0.3578578531742096,-0.7727656960487366,-0.524188220500946,0,-0.7660844326019287,-0.07800090312957764,0.6379872560501099,0,-0.5339001417160034,0.6298847198486328,-0.5640890598297119,0,-0.6154270768165588,-1.832311749458313,-0.024105047807097435,1],[7,0.16888155043125153,-0.9266890287399292,-0.3357595205307007,0,-0.5108910799026489,-0.3736226558685303,0.7742051482200623,0,-0.8428906202316284,0.040787991136312485,-0.5365324020385742,0,0.2409241646528244,-2.0807437896728516,-0.08608626574277878,1],[7,-0.049662429839372635,-0.9929094314575195,-0.1080518290400505,0,-0.19722768664360046,-0.09630654752254486,0.975612223148346,0,-0.9790973663330078,0.06976284086704254,-0.19104497134685516,0,-0.07552225142717361,-2.163938283920288,-0.2968294024467468,1],[7,-0.2414567917585373,-0.9102774262428284,-0.33630427718162537,0,-0.5909604430198669,-0.13695621490478516,0.7949870228767395,0,-0.7697147130966187,0.3907010853290558,-0.5048661828041077,0,-0.5032272934913635,-1.993468165397644,-0.08261706680059433,1],[7,-0.4139646291732788,-0.9017311334609985,-0.12458336353302002,0,-0.1796444058418274,-0.05324354022741318,0.9822859168052673,0,-0.8923903703689575,0.42901596426963806,-0.13994890451431274,0,-0.7401467561721802,-1.9749199151992798,-0.33442094922065735,1],[7,1.4375679313616274e-7,-1.2338401234046614e-7,0.9999997615814209,0,-0.8542541861534119,-0.5198545455932617,5.8663140123371704e-8,0,0.5198546051979065,-0.8542541265487671,-1.8013408009665e-7,0,-0.9529144763946533,1.7815529108047485,4.0429017644783016e-7,1],[7,0.6393547058105469,0.49524760246276855,-0.5881798267364502,0,0.3134878873825073,-0.8663802742958069,-0.3887294828891754,0,-0.7021048069000244,0.06414877623319626,-0.7091783285140991,0,0.5269625186920166,-0.4728422462940216,1.802030086517334,1],[7,0.8132864832878113,-0.20969867706298828,-0.5427628755569458,0,-8.940696005765858e-8,-0.9328011274337769,0.3603914678096771,0,-0.5818634033203125,-0.2931014597415924,-0.7586345672607422,0,0.997906506061554,0.8098251223564148,1.7474361658096313,1],[7,0.4288250207901001,0.86380535364151,-0.26447391510009766,0,-0.4598004221916199,-0.043302472680807114,-0.8869677186012268,0,-0.7776203155517578,0.5019568800926208,0.37861037254333496,0,-0.008306659758090973,-1.8588343858718872,0.24036522209644318,1],[7,0.5626587271690369,-0.5693939924240112,-0.5993377566337585,0,-0.3931679427623749,-0.8220548033714294,0.4118789732456207,0,-0.7272100448608398,0.0038930971641093493,-0.6864044666290283,0,0.23672296106815338,1.0551844835281372,1.523050308227539,1],[7,0.18524721264839172,0.19338709115982056,-0.9634752869606018,0,0.6776096820831299,-0.7352188229560852,-0.017287088558077812,0,-0.7117061614990234,-0.6496599316596985,-0.2672380805015564,0,0.21524199843406677,0.25324881076812744,0.7220667004585266,1],[7,2.559229415055597e-7,-8.742280499518529e-8,-1,0,-1,-2.231226745789787e-14,-2.559229415055597e-7,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.2804966866970062,-0.00003546378138707951,0.6907452940940857,1],[7,-0.00020870051230303943,1.1926117338134645e-7,-0.9999999403953552,0,-0.5792227387428284,-0.8151692748069763,0.00012078687723260373,0,-0.8151692152023315,0.5792227387428284,0.00017019532970152795,0,0.36198312044143677,0.1843899041414261,0.6907179355621338,1],[7,2.559229130838503e-7,-8.742280499518529e-8,-1,0,-1,-2.231226745789787e-14,-2.559229130838503e-7,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,0.2262233942747116,-0.0000353590767190326,0.6907453536987305,1],[7,0.10204935073852539,0.8112929463386536,-0.5756624341011047,0,-0.93558269739151,-0.11837401986122131,-0.33268028497695923,0,-0.33804601430892944,0.5725274085998535,0.7469514012336731,0,-0.3006354868412018,-1.8734503984451294,0.14338377118110657,1],[7,0.37162548303604126,0.8655277490615845,-0.3357875943183899,0,-0.6042600274085999,-0.04908502474427223,-0.7952754497528076,0,-0.7048161029815674,0.4984453320503235,0.504764199256897,0,-0.6557719111442566,-1.8989282846450806,0.08149641752243042,1],[7,0.40858325362205505,0.9031528830528259,-0.13179737329483032,0,-0.19394758343696594,-0.055190857499837875,-0.9794604182243347,0,-0.8918771147727966,0.4257506728172302,0.15261493623256683,0,-0.605950653553009,-1.9773201942443848,0.3477514982223511,1],[7,0.3578646779060364,0.7727644443511963,-0.5241820812225342,0,-0.766083836555481,-0.07799229770898819,-0.6379924416542053,0,-0.5339009165763855,0.6298803687095642,0.5640924572944641,0,-0.6154335141181946,-1.832303762435913,0.024093016982078552,1],[7,0.40771982073783875,0.7666410207748413,-0.4960091710090637,0,-0.5797269940376282,-0.20234552025794983,-0.7892874479293823,0,-0.7054658532142639,0.6093560457229614,0.3619430661201477,0,-0.5840668082237244,-1.894813895225525,0.01791316829621792,1],[7,0.24146191775798798,0.910273551940918,-0.3362947404384613,0,-0.5909604430198669,-0.1369439959526062,-0.7949936389923096,0,-0.7697169780731201,0.39069539308547974,0.5048705339431763,0,-0.5032331943511963,-1.9934582710266113,0.08259745687246323,1],[7,0.4139695167541504,0.9017240405082703,-0.12457510828971863,0,-0.17964377999305725,-0.05323291942477226,-0.9822925925254822,0,-0.8923889398574829,0.4290160834789276,0.13995294272899628,0,-0.7401567697525024,-1.974912405014038,0.3344042897224426,1],[7,-0.16888299584388733,0.9266806244850159,-0.33576279878616333,0,-0.5108913779258728,-0.37362170219421387,-0.7742084264755249,0,-0.8428948521614075,0.04078739508986473,0.5365331172943115,0,0.24093419313430786,-2.080730438232422,0.08609480410814285,1],[7,0.049663908779621124,0.992901623249054,-0.10804101079702377,0,-0.19722722470760345,-0.09629422426223755,-0.975619375705719,0,-0.9791003465652466,0.06976120173931122,0.19104576110839844,0,-0.07552213966846466,-2.163928508758545,0.2968069314956665,1],[7,-3.964248307397611e-8,-5.252962296253827e-7,1,0,-0.28662583231925964,-0.9580426812171936,-5.146187049831497e-7,0,0.9580427408218384,-0.28662583231925964,-1.1258426724225501e-7,0,-1.3498733043670654,0.6796941161155701,3.312456726689561e-7,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[29],[98,"Cactus Boss@Idle",[[-3,[92,"Rig",-5,[0,"e6VZ3a3MxS7I4bObgkgCf5",-4,0],[3,0.5000000447034803,0.5000000447034803,0.49999995529651575,0.49999995529651575],[1,0,90.00001024528345,90]],-6,[31,"RigLLegPlatform",-8,[0,"8extG8WpZa6pT2x1SWtKrg",-7,0],[1,0.6907929182052612,-6.020398846118269e-9,0.13773036003112793],[3,0.4777143975556944,0.4777143975556944,0.5213338223902224,0.5213338223902224],[1,0,84.99999570225637,90]],[31,"RigRLegPlatform",-10,[0,"c6k7SF36da0bCoVeGea93V",-9,0],[1,-0.6907929182052612,5.807428760107314e-9,-0.13285943865776062],[3,0.4080735125267516,0.4080735125267516,0.5774738161805079,0.5774738161805079],[1,0,70.49409343126568,90]]],1,4,1,4,4],[[42,-2,[9,"0fggfDbF9f14NPZW1JS7q7"],[5],6]],[0,"admiQRrpBfeblJsjLrXkKN",-1,0]],[2,"RigPelvis",1,[-11,-12,-13],[0,"3a9ywqG75TsaNln70WEiN5",1,0],[1,0.015456543304026127,0.8909908533096313,-2.483172636402742e-7],[3,0.5074601746002805,0.4165177624056095,0.580484506786256,0.4816999711193621],[1,178.3864072069277,-96.34739534139491,79.10375191447083]],[27,"RigRibcage",[-14,-15,-16],[0,"e9tNUkBtNRbZBE/Eea1XWa",1,0],[1,0.4836367666721344,-7.629394360719743e-8,-4.76837147544984e-9],[3,-0.003917191203972675,0.012951756914709798,0.05063919757118475,0.9986253447991594],[1,-0.5261164749638534,1.5127688818455178,5.798929165399738]],[93,"RigLArmPalm",[-17,-18,-19],[0,"70ut7GtelYXZe4eVsn9Nmi",1,0],[1,0.5196183919906616,0,0],[3,0.889518497067288,0.1546331640047581,0.05517008513804164,-0.4263820935157715],[1,0.9999974370002747,1.000002145767212,0.9999960064888],[1,-127.19308227091231,-13.664749916103515,13.182355812876994]],[93,"RigRArmPalm",[-20,-21,-22],[0,"4axbzyO1RWCLGKDERFghXv",1,0],[1,0.5196183919906616,-1.5258788721439487e-7,2.8421708795129297e-16],[3,0.8353340268342301,0.16514592344456436,-0.010281774509114671,0.5242501050982207],[1,1.0000014305114746,0.9999950528144836,1.000001311302185],[1,114.23411530138392,11.384779523325841,15.374295816476709]],[94,"Cactus Boss",1,[[43,-23,[9,"fcQIRUDllf14ybCoUSeFew"],[0,1,2],[21],1,3,4]],[0,"bf+bu873Zcaapl6SqrLwMw",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[2,"RigSpine1",2,[-24],[0,"12U1UZvwBcUbGhUE+kugjA",1,0],[1,0.11622398346662521,-0.26316559314727783,5.602836594675864e-8],[3,-0.010996364744961932,-0.02547972965460837,-0.07402159854822098,0.996870436058513],[1,-1.4886140301724826,-3.0383222452811776,-8.454242526497701]],[2,"RigSpine2",7,[3],[0,"29/f1POJxSKb3zIhbldzxV",1,0],[1,0.4122249484062195,0,-9.53674295089968e-9],[3,-0.03241578438468631,0.017413468757091533,0.18951952158826477,0.9811872089288194],[1,-4.3357584630999835,2.867376504744625,21.763687888726267]],[2,"RigNeck",3,[-25],[0,"47dCfBePxV8pGPLkI1BNAk",1,0],[1,0.06632766872644424,-0.011124267242848873,-2.38418573772492e-9],[3,0.05422279646291865,0.01961149287984224,0.29736533953309174,0.9530210556620109],[1,6.401117483868542,0.3575718095604603,34.67478390818619]],[4,"RigHead",9,[[31,"RigJaw",-26,[0,"a9CLEKBPZSJoyHW+2ZWVhx",1,0],[1,-0.19038009643554688,0.08414707332849503,-9.53674295089968e-9],[3,-0.0004942270974628821,-0.0010336116976327318,0.7684907209999093,0.6398599058571135],[1,179.69758747124627,-179.82190123051197,79.56272512351227]]],[0,"91AkBEHfJTaI0RXaql8KxL",1,0],[1,0.6741992235183716,0,-3.552713599391162e-17],[3,0.050538988336514115,-0.08942501497339031,-0.5047025821869902,0.8571605922397011],[1,-0.4279632042695328,-12.163781752180574,-60.95766243691625]],[2,"RigLArmCollarbone",3,[-27],[0,"c28FRiwtZYKbjNoe4hZ/dh",1,0],[1,0.17935287952423096,-0.06929397583007812,0.3066788613796234],[3,0.07786321790582688,0.874825017679873,-0.0778632402575691,-0.47175822574211884],[1,3.680662937605855,-123.71795836113505,12.104691789704622]],[16,"RigLArm1",11,[-28],[0,"b3eAjmHWZRzqCnrNV4KziK",1,0],[1,0.7998373508453369,-1.4210854397564648e-16,-1.5258788721439487e-7],[3,-0.443374969407019,0.030396879253561507,-0.22044285029175745,0.8682739291204217],[1,1.0000014305114746,1.0000019073486328,1.0000003576278687],[1,-56.033623707383,-8.999608716169275,-24.190009908454915]],[16,"RigLArm2",12,[4],[0,"c8txnCLzpQL4HzXcygfxs1",1,0],[1,0.6620225310325623,0,-1.5258788721439487e-7],[3,0.3473640652694112,-0.05312511282642606,0.5794225885097577,0.7353811205567762],[1,1.0000001192092896,1.0000008344650269,0.9999984502792358],[1,81.33740075513316,-56.10872297014362,54.615586872014156]],[16,"RigLArmThumb1",4,[-29],[0,"3f/xCXvMBY/4rHemRDvYsZ",1,0],[1,0.2296222746372223,0.0052322386763989925,0.5393834114074707],[3,0.11902426462481634,-0.34752050857514305,-0.15861480310176532,0.9164628005474],[1,0.999998152256012,1.0000032186508179,0.9999982714653015],[1,6.6806880225802505,-40.23750923313697,-21.92890885770425]],[28,"RigLArmThumb2",14,[[36,"RigLArmThumb3",-30,[0,"2dpN0arXNZQLFderSSo6Vj",1,0],[1,0.1421007513999939,0,-1.5258788721439487e-7],[3,0.020418135866020933,0.1253804441054335,-0.21625234628016657,0.9680381018802946],[1,0.9999972581863403,1.0000046491622925,0.9999979138374329],[1,5.910661128106185,16.040312250748922,-24.42872540352915]]],[0,"37MuhjvsNa+p9DRuOyy8Hr",1,0],[1,0.1535646766424179,2.8421708795129297e-16,-9.769962563761818e-17],[3,-0.010931750081585914,0.1794611257195139,-0.13399026108467849,0.9745362030884734],[1,0.9999985098838806,1.0000030994415283,0.9999980330467224],[1,1.5918284389491668,21.083112067344643,-15.371728385758802]],[16,"RigLArmIndex1",4,[-31],[0,"44BDaBwndfzJwU3PExQC/F",1,0],[1,0.6633715033531189,0.03589813411235809,0.2784382104873657],[3,0.01604868858737502,-0.08422851639051898,-0.17358641484193144,0.9810788720605507],[1,0.9999986290931702,1.0000029802322388,0.9999980330467224],[1,0.13714830179372098,-9.789678854548036,-20.078509966785184]],[28,"RigLArmIndex2",16,[[36,"RigLArmIndex3",-32,[0,"d1+lEnXstem4z7eVIH80Rd",1,0],[1,0.14035728573799133,-1.5258788721439487e-7,-3.814697180359872e-8],[3,0.0022178714282182024,-0.018809590984163172,-0.37542850768100106,0.9266578203165142],[1,0.9999938607215881,1.0000075101852417,0.9999980926513672],[1,-0.7988608321701786,-2.649245261916988,-44.09666213619728]]],[0,"c6ugq8PnlUy6Ky9yko4DHl",1,0],[1,0.13250260055065155,0,-3.814697180359872e-8],[3,0.00017735130584558837,-0.00023581925656045784,-0.24256056420098157,0.9701362201414263],[1,0.9999972581863403,1.000003695487976,0.9999980330467224],[1,0.014916610047258036,-0.02412518314389304,-28.075436734562317]],[16,"RigLArmPinky1",4,[-33],[0,"39EbydiCtQALr3yeWvVReh",1,0],[1,0.6378105282783508,0.05695099011063576,-0.31658935546875],[3,-0.03216279009080834,0.13517985099015997,-0.2110657597768235,0.9675449384238879],[1,0.9999985098838806,1.0000030994415283,0.9999980926513672],[1,-0.32619546508775704,15.835827274806785,-24.65331884902209]],[28,"RigLArmPinky2",18,[[36,"RigLArmPinky3",-34,[0,"d1dZDutsNRD4/03bBWdAYE",1,0],[1,0.13408218324184418,-2.8421708795129297e-16,-7.629394360719743e-8],[3,-0.010056592323490345,-0.025119598453949104,-0.35130175247532486,0.9358712248125365],[1,0.9999943971633911,1.0000072717666626,0.9999979138374329],[1,-2.773126761660408,-4.1140611963913045,-41.074603901090406]]],[0,"1cuJXYbItQKrB3qqe+SPwS",1,0],[1,0.121518075466156,1.5258788721439487e-7,3.814697180359872e-8],[3,-0.0018863684304697838,0.00718111424389516,-0.16915834403269955,0.9855609204186595],[1,0.9999980330467224,1.0000032186508179,0.9999979734420776],[1,-0.07832407923580798,0.8214925705327057,-19.478845528181484]],[2,"RigRArmCollarbone",3,[-35],[0,"62qbBS2+RWWJoDYqcIgIs4",1,0],[1,0.1793530285358429,-0.06929390132427216,-0.3066789507865906],[3,0.07786327806314429,0.8748250238893577,0.0778632706125635,0.471758199288323],[1,-3.680663127727195,123.7179616545239,12.104699451017089]],[16,"RigRArm1",20,[-36],[0,"dfPbJcZNRftorf1k89Jx/8",1,0],[1,0.7998374104499817,7.629394360719743e-8,-1.5258788721439487e-7],[3,0.38970165515728017,-0.031553278856256556,-0.2694922323352881,0.8800630359650601],[1,1.0000005960464478,0.9999999403953552,1.0000016689300537],[1,50.52039386425256,10.26963861815842,-29.92943518800758]],[16,"RigRArm2",21,[5],[0,"9ck2K2QRpRgKI4xinURfaH",1,0],[1,0.6620224714279175,3.814697180359872e-8,2.8421708795129297e-16],[3,-0.33097504983600207,0.057707588098192736,0.6294138320136745,0.7006879324862155],[1,1,1.0000015497207642,0.9999982118606567],[1,-91.21870185274426,67.99912810110904,57.54848399189759]],[16,"RigRArmThumb1",5,[-37],[0,"5a1Q3FTAxamaiCTbc8wA5p",1,0],[1,0.22962230443954468,0.0052322386763989925,-0.5393782258033752],[3,-0.11293889789332694,0.3495435778842091,-0.1425991084508046,0.919091718367423],[1,1.0000050067901611,0.9999926090240479,1.0000017881393433],[1,-6.591915592027277,40.48486987553217,-19.942531870160824]],[28,"RigRArmThumb2",23,[[36,"RigRArmThumb3",-38,[0,"29c0cWrQVWBpQ4vklO1I14",1,0],[1,0.14210082590579987,2.8421708795129297e-16,-3.814697180359872e-8],[3,-0.02260401970729743,-0.12500458621115637,-0.1993320977968923,0.9716633298149827],[1,1.0000059604644775,0.9999891519546509,1.0000044107437134],[1,-5.822280365267493,-15.817593733529966,-22.44002660472121]]],[0,"cfJhCECNtRqIFxeruP32Rp",1,0],[1,0.15356460213661194,1.5258788721439487e-7,1.2434497928741312e-16],[3,0.007796738371185615,-0.17962460391354473,-0.11696526519866654,0.9767258260518551],[1,1.000005841255188,0.9999927878379822,1.000001311302185],[1,-1.5778813144058537,-21.026060136707503,-13.37285245498102]],[16,"RigRArmIndex1",5,[-39],[0,"928YOe+BNcdagX1VQumokM",1,0],[1,0.6633713245391846,0.035898588597774506,-0.27843546867370605],[3,-0.014575888645777716,0.08449538938015747,-0.15643936656469948,0.9839587375660207],[1,1.0000019073486328,0.9999929070472717,1.000004768371582],[1,-0.13544996820085958,9.794679316225638,-18.078694272045276]],[28,"RigRArmIndex2",25,[[36,"RigRArmIndex3",-40,[0,"9anKq8InlYPY3ZkFOlh5Sz",1,0],[1,0.14035721123218536,0,-7.105427198782324e-17],[3,-0.001889046319745669,0.018844889857669616,-0.3592066539388556,0.9330658505144777],[1,1.0000114440917969,0.9999837279319763,1.0000048875808716],[1,0.7732222149304453,2.611634947168424,-42.09779947785153]]],[0,"b0rjbVgUZfKKcOeEyaQ0gW",1,0],[1,0.13250257074832916,-1.5258788721439487e-7,7.629394360719743e-8],[3,-0.00018153592603829192,0.00023260303427893023,-0.22559667845478246,0.9742207407003329],[1,1.0000041723251343,0.999990701675415,1.0000046491622925],[1,-0.015868277052047724,0.02368509704795179,-26.07593904729685]],[16,"RigRArmPinky1",5,[-41],[0,"b4wHdFaHdZJrUfBu+mgBmY",1,0],[1,0.6378103494644165,0.05695144832134247,0.31658652424812317],[3,0.02979781691575694,-0.1357201200949085,-0.19414974922843944,0.9710808483246968],[1,1.0000022649765015,0.9999926090240479,1.000004529953003],[1,0.3211164295985673,-15.848140251591248,-22.65358253304484]],[28,"RigRArmPinky2",27,[[36,"RigRArmPinky3",-42,[0,"3fIXwSqrBXdrKoINdfPPcy",1,0],[1,0.1340821087360382,0,1.5258788721439487e-7],[3,0.010493552186519628,0.024939326270611323,-0.33492275671192784,0.9418570286429675],[1,1.0000098943710327,0.9999850988388062,1.0000048875808716],[1,2.6929108129982207,3.989370204618472,-39.07781697001739]]],[0,"3eZuR69QZcdrFO7zDdgbkp",1,0],[1,0.12151817232370377,0,0],[3,0.0017605401344034234,-0.007213115967546123,-0.15193548397814613,0.9883625246663292],[1,1.000002384185791,0.9999920725822449,1.000004529953003],[1,0.07738430452122637,-0.8243834861634356,-17.479231340903098]],[2,"RigLLeg1",2,[-43],[0,"72AZTiMVlUOJ2OBzSNkqUE",1,0],[1,1.4210854397564648e-16,-3.552713599391162e-17,0.4851863384246826],[3,0.134630275017802,0.9815469184787772,0.008862976736079019,-0.13550565861551195],[1,-3.2007119732045655,-163.85296976751553,15.182231494188208]],[16,"RigLLeg2",29,[-44],[0,"01XOzGIAtS6ZwCBofivPcT",1,0],[1,0.4406464397907257,-1.1920928955078125e-7,-3.0517577442878974e-7],[3,0.002526049693081627,-0.008919435405152927,-0.4674581211673867,0.883966610059259],[1,1.0000065565109253,0.9999995231628418,0.9999943375587463],[1,-0.394180692765117,-1.3646562169468222,-55.738808682806884]],[16,"RigLLegAnkle",30,[-45],[0,"aeRRdnhNRdGJm7D5PJ5pj0",1,0],[1,0.4531649053096771,-1.907348590179936e-8,0],[3,-0.005576754827788925,-0.1259151527285576,0.6766081340269239,0.7254761933292773],[1,1.0000070333480835,0.9999936819076538,0.9999995231628418],[1,62.54077769507734,-73.25619522800616,79.46098332450389]],[28,"RigLLegFeet1",31,[[6,"RigLLegFeet2",-46,[0,"fcse9w9/pYPbZzEyNGV9IR",1,0],[1,0.5067200660705566,2.7105053706292436e-22,1.4210854397564648e-16]]],[0,"8bpQ3YXhpRp77UYPUHjNvM",1,0],[1,0.23077476024627686,-9.53674295089968e-9,-7.629394360719743e-8],[3,8.680806272928358e-9,4.640834548745806e-8,0.4588049936014556,0.888536987326001],[1,1.0000046491622925,0.9999955892562866,1],[1,-0.0000026875101046693914,0.000007372847513443824,54.62004554306101]],[2,"RigRLeg1",2,[-47],[0,"b7i+3xJidY9KKUub8hMLrw",1,0],[1,-1.5258788721439487e-7,3.814697180359872e-8,-0.4851863384246826],[3,0.05752197204124349,0.9912195074032757,-0.026367418117781285,0.11610284293459909],[1,3.78508843843989,166.43372415787937,6.194915736788133]],[16,"RigRLeg2",33,[-48],[0,"a7Tc7IaLlfN7ezVH+qZdmN",1,0],[1,0.44064652919769287,-1.335144048653092e-7,3.0517577442878974e-7],[3,-0.0024339912870006194,0.007927404698727167,-0.3971166303735841,0.9177306869784226],[1,1.000006079673767,0.9999999403953552,0.9999939799308777],[1,0.15305216177476902,1.0560497399433035,-46.79683619867246]],[16,"RigRLegAnkle",34,[-49],[0,"97fS4JjsFeHpMGrT0kZ8E6",1,0],[1,0.4531649053096771,-3.814697180359872e-8,1.4210854397564648e-16],[3,0.0718435272898338,0.12330534314708125,0.669005990330009,0.7294280532310912],[1,1.0000061988830566,0.9999949932098389,0.9999989867210388],[1,-32.477009197879845,48.365442922765425,83.56562094550218]],[28,"RigRLegFeet1",35,[[6,"RigRLegFeet2",-50,[0,"304Mkmwm9XzreDauxJQcfH",1,0],[1,0.5067200660705566,-4.33680859300679e-21,0]]],[0,"dcTKngAllRI7TFdDILabOM",1,0],[1,0.23077483475208282,-9.53674295089968e-9,0],[3,0.00008815877115301756,0.0001705882057814391,0.4589389059984178,0.8884678067823677],[1,1.0000041723251343,0.9999960064888,1.0000001192092896],[1,0.000007259711002380369,0.021998136903480736,54.637317528488225]]],0,[0,3,1,0,7,1,0,-1,6,0,3,1,0,0,1,0,-3,2,0,3,1,0,0,1,0,3,1,0,0,1,0,-1,7,0,-2,29,0,-3,33,0,-1,9,0,-2,11,0,-3,20,0,-1,14,0,-2,16,0,-3,18,0,-1,23,0,-2,25,0,-3,27,0,7,6,0,-1,8,0,-1,10,0,0,10,0,-1,12,0,-1,13,0,-1,15,0,0,15,0,-1,17,0,0,17,0,-1,19,0,0,19,0,-1,21,0,-1,22,0,-1,24,0,0,24,0,-1,26,0,0,26,0,-1,28,0,0,28,0,-1,30,0,-1,31,0,-1,32,0,0,32,0,-1,34,0,-1,35,0,-1,36,0,0,36,0,12,1,3,0,8,4,0,13,5,0,22,50],[0,0,0,0,0,0,0],[-1,-2,-3,14,15,-1,16],[24,24,24,86,87,14,14]],[[[54,"01 - Default",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":0,"shininessExponent":1.9999999173704188},"mainColor",8,[4,4288059030],"specularColor",8,[4,4293256677],"emissiveColor",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[11,6],[88,10]],[[[44,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,3049455360]]],11]]],0,0,[0],[6],[12]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[89,4]],[[[108,"MergeUnit",".wav",1.319773],-1],0,0,[],[],[]],[[[44,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"normalMap",6,0,"mainTexture",6,1],{},{}],0,11,0,0]]],0,0,[0,0,0],[25,11,6],[29,90,4]],[[[39,"WarUnit_Far_0"],[70,"WarUnit_Far_0",[-6],[[67,-5,[9,"d3pW+jyDNFhbx8InozEoiY"],[153],-4,-3]],[100,"9e4LhbfZtP+qxgGRbwO+Tp",-2,0,[-1]],[1,-0.026,0,-5.089]],[49,0,{},[12,"admiQRrpBfeblJsjLrXkKN",-19,[74,"dbPQ1wt7hOAr4c6+u1l3EL",1,[[68,[1,["admiQRrpBfeblJsjLrXkKN"]],[-18]]],[[11,"Cactus Boss@Idle",["_name"],-7],[10,["_lpos"],-8,[1,0,0,0]],[10,["_lrot"],-9,[3,0,0,0,1]],[10,["_euler"],-10,[1,0,0,0]],[10,["_lscale"],-11,[1,1.3,1.3,1.3]],[3,["_materials","0"],-12,1],[40,["_skinningRoot"],-14,-13],[3,["_materials","1"],-15,2],[3,["_materials","2"],-16,3],[11,1,["_shadowCastingMode"],-17]],[[1,["0fggfDbF9f14NPZW1JS7q7"]]]],0]],[1,["admiQRrpBfeblJsjLrXkKN"]],[1,["fcQIRUDllf14ybCoUSeFew"]],[35,"body",1,[2],[0,"fcEBJXLulFP794+C6fDXyn",1,0]],[69,2,[9,"7bwR+yCUZJTLPqIt8wKA5E"]]],0,[0,-1,2,0,3,1,0,23,6,0,24,5,0,7,1,0,-1,5,0,4,3,0,4,3,0,4,3,0,4,3,0,4,3,0,4,4,0,1,2,0,4,4,0,4,4,0,4,4,0,4,4,0,-1,6,0,3,2,0,12,1,2,0,5,19],[0,0,0,0,6],[8,1,1,1,20],[91,25,25,25,92]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[93,4]],[[[44,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,3036741611]]],11]]],0,0,[0],[6],[12]],[[[22,".bin",1701510914,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":48384,"length":13824,"count":3456,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":48384,"count":1008,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1121587753295898,-0.8407589793205261,-1.093660831451416],"maxPosition",8,[1,1.1317960023880005,1.144273042678833,0.06616023927927017]]],-1],0,0,[],[],[]],[[[29],[95,"w09",[-2,-3],[0,"47LaGKdYVfZYy4WPAi7QAg",-1,0]],[96,"Wolf",1,[-4,-5,-6,-7,-8,-9,-10,-11],[0,"72YBEu39xZybVg4RA2+Z62",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[4,"polySurface3",2,[[30,"transform3",-12,[0,"2cTnIOYl5bKq7jvDs+3Y5a",1,0]]],[0,"3boY/BIBlYwq2FyJbUxdEK",1,0],[1,-0.2631398141384125,-0.4238472580909729,-1.0169832706451416],[3,0,0,-0.27424064249062347,0.9616610993517051],[1,0,0,-31.833533067653864]],[4,"polySurface4",2,[[30,"transform7",-13,[0,"10nMTTSZ5VDK82wC1YYDmt",1,0]]],[0,"18oHCkwi9axKCPSJm/wXRi",1,0],[1,0.2641889154911041,-0.42319414019584656,-1.0169832706451416],[3,0,0,0.2754312220813997,0.9613207799183093],[1,0,0,31.97542764865867]],[4,"polySurface5",2,[[30,"transform6",-14,[0,"55ExsGGsVVvJ2qaTOZ9BD3",1,0]]],[0,"72SZyxVztTS4ffLr84qjKf",1,0],[1,0.10061410069465637,0.16206179559230804,-1.1165826320648193],[3,0.2957745245772436,-0.0843471750355929,-0.26094729161191066,0.9150461713351019],[1,35.82524840552402,2.0730740070945607e-7,-31.833534141413864]],[4,"polySurface6",2,[[30,"transform5",-15,[0,"a5cylDW2RfaZtDRiMrAn/m",1,0]]],[0,"89VX9cS4lZk6ALatagIi2r",1,0],[1,-0.005797866266220808,0.009287647902965546,-1.1327065229415894],[3,0.22184031724286787,0.06356020880031728,0.2679971100821865,0.9353740013975373],[1,26.684367244737302,3.9370117347188974e-7,31.975426146441848]],[4,"polySurface7",2,[[30,"transform4",-16,[0,"1aiCE4SFldf4YQATiAAVy6",1,0]]],[0,"4fiD5xkoBYwab1lxag/uC+",1,0],[1,-0.4440118372440338,-0.22746989130973816,-1.0169832706451416],[3,0,0,-0.5215583375625132,0.8532156236960429],[1,0,0,-62.87367972697906]],[4,"polySurface8",2,[[30,"transform9",-17,[0,"91GcQ4uHtZpLw3GafJUp3l",1,0]]],[0,"bchrOCuaxUZ7gQi/+By7x0",1,0],[1,0.43630820512771606,-0.24191777408123016,-1.0169832706451416],[3,0,0,0.5074867466383794,0.8616595626965405],[1,0,0,60.993135456914224]],[4,"polySurface9",2,[[30,"transform8",-18,[0,"ef1BGcuq9dBpWcCn4S/MJx",1,0]]],[0,"4cd/5vzCNUophWcS297I6x",1,0],[1,-0.5484904050827026,-0.8834697604179382,-0.449203222990036],[3,-0.3328972747223383,0.09493361385990205,-0.2572849385441077,0.9022036764723883],[1,-40.50634614414305,7.779530231366276e-8,-31.833533208538263]],[4,"polySurface10",2,[[30,"transform2",-19,[0,"d6o2mwF8pck7U/Hti9fF+F",1,0]]],[0,"d077KW+epU6ZW9w1+mtW/M",1,0],[1,0.565233051776886,-0.9054255485534668,-0.37928900122642517],[3,-0.3625025654040638,-0.10386182095138652,0.2550981871869364,0.8903535966783497],[1,-44.30685051863632,1.9500730806612228e-7,31.97542870035516]],[52,"polySurface8",1,[[73,-20,[9,"d1ppO1bKtTcrHfbSH6Zv07"],[0],[21],1]],[0,"263Hc/hKpXFqwc0nhOSDKV",1,0]]],0,[0,3,1,0,-1,2,0,-2,11,0,-1,3,0,-2,4,0,-3,5,0,-4,6,0,-5,7,0,-6,8,0,-7,9,0,-8,10,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,7,11,0,12,1,20],[0,0],[-1,14],[94,95]],[[[54,"02 - Default",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":1,"shininessExponent":2},"mainColor",8,[4,4294967295],"specularColor",8,[4,4278190080],"emissiveColor",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[11,6],[96,10]],[[[57,[[58,[59,[-16,-17,-18,-19,-20,-21,-22],[[60,-5,-4],[23,0,false,-7,-6,[[61,"Victory"]]],[37,0.1,-9,-8],[23,0.1,false,-11,-10,[[62,[38,"Fail"]]]],[23,0.1,false,-13,-12,[[63,1,[38,"Fail"]]]],[37,0,-15,-14]],-3,-2,-1]]],[{},"Victory",4,[64,2],"Fail",4,[65,1,false]]],[24,"Idle",[19,0]],[25,"Entry"],[24,"Cast Spell",[19,1]],[66,"Idle",2,[19,2]],[24,"Cast Spell",[19,3]],[25,"Exit"],[25,"Any"]],0,[0,17,7,0,18,6,0,19,2,0,9,1,0,10,2,0,9,5,0,10,1,0,9,1,0,10,5,0,9,4,0,10,1,0,9,3,0,10,4,0,9,1,0,10,3,0,-1,2,0,-2,6,0,-3,7,0,-4,1,0,-5,3,0,-6,4,0,-7,5,22],[0,0,0,0],[13,13,13,13],[15,34,15,34]],[[[56,"builtin-unlit",[{"hash":3152709001,"name":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"Constant","stageFlags":16,"binding":1,"members":[{"name":"mainColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":1,"defines":["USE_VERTEX_COLOR"]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":["USE_TEXTURE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  layout(location = 14) in lowp vec4 a_color;\n  layout(location = 1) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 2) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 2) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 1) in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n   uniform vec4 mainColor;\n   uniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o.rgb *= SRGBToLinear(v_color.rgb);\n    o.a *= v_color.a;\n  #endif\n  #if USE_TEXTURE\n    vec4 texColor = texture2D(mainTexture, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  CC_APPLY_FOG(o);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":198,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":41}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}]}],[{"name":"opaque","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"transparent","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"add","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-unlit|unlit-vs:vert|unlit-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"color":{"linear":true,"type":16,"editor":{"visible":false},"handleInfo":["mainColor",0,16]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]}},"migrations":{"properties":{"mainColor":{"formerlySerializedAs":"color"}}}}]}]]],0,0,[],[],[]],[[[41,"Skin-0",262536407,["RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck/RigHead","RigPelvis/RigSpine1/RigSpine2/RigRibcage","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRFLeg1","RigPelvis","RigPelvis/RigTail1","RigPelvis/RigRBLeg1","RigPelvis/RigSpine1/RigSpine2","RigPelvis/RigSpine1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRFLeg1/RigRFLeg2","RigPelvis/RigRBLeg1/RigRBLeg2","RigPelvis/RigRBLeg1/RigRBLeg2/RigRBLegAnkle","RigPelvis/RigRBLeg1/RigRBLeg2/RigRBLegAnkle/RigRBLegToes1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRFLeg1/RigRFLeg2/RigRFLegAnkle","RigPelvis/RigTail1/RigTail2/RigTail3/RigTail4/RigTail5","RigPelvis/RigTail1/RigTail2/RigTail3/RigTail4","RigPelvis/RigTail1/RigTail2/RigTail3","RigPelvis/RigTail1/RigTail2","RigPelvis/RigRBLeg1/RigRBLeg2/RigRBLegAnkle/RigRBLegToes1/RigRBLegToes2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRFLeg1/RigRFLeg2/RigRFLegAnkle/RigRFLegToes1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigRFLeg1/RigRFLeg2/RigRFLegAnkle/RigRFLegToes1/RigRFLegToes2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigNeck/RigHead/RigJaw","RigPelvis/RigLBLeg1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLFLeg1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLFLeg1/RigLFLeg2","RigPelvis/RigLBLeg1/RigLBLeg2","RigPelvis/RigLBLeg1/RigLBLeg2/RigLBLegAnkle","RigPelvis/RigLBLeg1/RigLBLeg2/RigLBLegAnkle/RigLBLegToes1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLFLeg1/RigLFLeg2/RigLFLegAnkle","RigPelvis/RigLBLeg1/RigLBLeg2/RigLBLegAnkle/RigLBLegToes1/RigLBLegToes2","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLFLeg1/RigLFLeg2/RigLFLegAnkle/RigLFLegToes1","RigPelvis/RigSpine1/RigSpine2/RigRibcage/RigLFLeg1/RigLFLeg2/RigLFLegAnkle/RigLFLegToes1/RigLFLegToes2"],[[[7,-0.00003329763421788812,0.000004976707714376971,1,0,-0.8403172492980957,0.5420950055122375,-0.00003067842044401914,0,-0.5420950055122375,-0.8403172492980957,-0.000013868465430277865,0,0.07762505859136581,1.1295506954193115,-0.000003030469770237687,1],[7,-4.009789122960683e-8,2.121097963936336e-7,1,0,-0.9173317551612854,0.39812377095222473,-1.2122900727717933e-7,0,-0.39812377095222473,-0.9173317551612854,1.786111170076765e-7,0,-0.3217792809009552,1.0917396545410156,0.00000700253076502122,1],[7,-4.1958614360737556e-8,2.0696136004971777e-7,1,0,-0.9598995447158813,0.280344158411026,-9.829646074877019e-8,0,-0.280344158411026,-0.9598995447158813,1.8689925695980492e-7,0,-0.07538577914237976,1.1173694133758545,-2.3523597292296472e-7,1],[7,0.0029365383088588715,-0.1646709442138672,-0.9863443374633789,0,0.08918919414281845,-0.9823746085166931,0.1642737090587616,0,-0.9960103631019592,-0.08845365792512894,0.011802087537944317,0,0.9106752872467041,-0.2760513126850128,-0.207959845662117,1],[7,-4.3492008217072e-8,1.9908215165287402e-7,1,0,-0.9949789047241211,0.10008526593446732,-6.319881862282273e-8,0,-0.10008526593446732,-0.9949789047241211,1.9372961901353847e-7,0,0.4707012474536896,0.917450487613678,-1.7863420964658872e-7,1],[7,4.363073813351548e-8,1.920547560985142e-7,1,0,0.9981571435928345,-0.0606815367937088,-3.1896156826860533e-8,0,0.0606815367937088,0.9981571435928345,-1.9434841647125722e-7,0,-0.5833480954170227,-0.9829054474830627,1.9137878837227618e-7,1],[7,-0.023630984127521515,0.13111191987991333,-0.9910857081413269,0,-0.03658158704638481,-0.9908121228218079,-0.1302034705877304,0,-0.9990512132644653,0.0331786572933197,0.028210146352648735,0,0.9671709537506104,0.3725323975086212,-0.21486152708530426,1],[7,1.7185509904038554e-8,2.6753497195386444e-7,1,0,-0.9830616116523743,-0.1832752525806427,6.59269687730557e-8,0,0.1832752674818039,-0.9830615520477295,2.5985372076320346e-7,0,-0.09987719357013702,0.9629459381103516,-2.486160326498066e-7,1],[7,-7.961989467730746e-8,1.2573310925745318e-7,1,0,-0.9998602271080017,-0.016718029975891113,-7.750676189743899e-8,0,0.016718028113245964,-0.9998603463172913,1.270466185587793e-7,0,0.3604133427143097,0.9661145806312561,-1.0923443483079609e-7,1],[7,0.006482894532382488,0.006647008005529642,-0.9999572038650513,0,-0.3920736014842987,-0.9198934435844421,-0.008656681515276432,0,-0.9199112057685852,0.3921128809452057,-0.0033574546687304974,0,0.3140358030796051,-0.43594852089881897,-0.2528683841228485,1],[7,0.004866509698331356,-0.04163980856537819,-0.9991205334663391,0,0.9142626523971558,-0.4045603275299072,0.02131381630897522,0,-0.4050920009613037,-0.9135628938674927,0.036100924015045166,0,-0.11700894683599472,0.612064003944397,-0.275598406791687,1],[7,-0.000018422339053358883,1.5733888858449063e-7,-1,0,-0.27926790714263916,-0.9602131247520447,0.000004993690254195826,0,-0.9602131247520447,0.27926790714263916,0.00001773331496224273,0,0.5647449493408203,0.4738146662712097,-0.2479683756828308,1],[7,2.681585442587675e-7,5.2579327558532896e-8,-1,0,-0.6992723345756531,-0.7148553729057312,-2.2510246822093904e-7,0,-0.7148553729057312,0.6992723345756531,-1.5492730653932085e-7,0,0.46161791682243347,0.296175092458725,-0.24796374142169952,1],[7,1.9693561625899747e-7,-4.903772943265494e-9,-1,0,-0.7008450627326965,-0.7133134603500366,-1.345234466043621e-7,0,-0.7133134603500366,0.7008450627326965,-1.439136241287997e-7,0,-0.19767580926418304,-0.392548531293869,-0.24970613420009613,1],[7,4.194966152226698e-8,1.8242572252802347e-7,1,0,0.9597082138061523,-0.2809986174106598,1.1001940691812706e-8,0,0.2809986174106598,0.9597082138061523,-1.868632466539566e-7,0,-1.4557682275772095,-0.7028754353523254,1.368552062785966e-7,1],[7,4.31676312473428e-8,1.878361928220329e-7,1,0,0.9875657558441162,-0.1572062075138092,-1.3101860929509712e-8,0,0.1572062075138092,0.9875657558441162,-1.9228681935601344e-7,0,-1.1975388526916504,-0.8815646767616272,1.7164737187158607e-7,1],[7,4.344384052501482e-8,1.898779942166584e-7,1,0,0.9938789010047913,-0.1104750856757164,-2.2201128047072416e-8,0,0.1104750856757164,0.9938789010047913,-1.9351519142674078e-7,0,-0.9489282369613647,-0.9370394945144653,1.8244823252189235e-7,1],[7,4.362540195756992e-8,1.9196806988475146e-7,1,0,0.9980344772338867,-0.06266622990369797,-3.150974237087212e-8,0,0.06266622990369797,0.9980344772338867,-1.9432461328960926e-7,0,-0.7150200009346008,-0.9814855456352234,1.9110241566977493e-7,1],[7,6.123234262925839e-17,-8.742283341689472e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742283341689472e-8,0,0.41455939412117004,-0.00025019905297085643,-0.24796384572982788,1],[7,6.123234262925839e-17,-8.742280499518529e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.5503169298171997,-8.858720690341215e-8,-0.24970605969429016,1],[7,6.123234262925839e-17,-8.742280499518529e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.6483776569366455,-1.0884971146651878e-7,-0.24970604479312897,1],[7,-3.4945035309874584e-8,2.209662000041135e-7,1,0,-0.7994484305381775,0.6007347702980042,-1.6067883734649513e-7,0,-0.6007347702980042,-0.7994484305381775,1.556583697492897e-7,0,-0.32308298349380493,1.0500495433807373,0.000007010648459981894,1],[7,0.02363046631217003,-0.13114207983016968,-0.9910818934440613,0,-0.03658056631684303,-0.9908083081245422,0.13023366034030914,0,-0.9990513324737549,0.03317685425281525,-0.028210509568452835,0,0.9671709537506104,0.37253984808921814,0.21484965085983276,1],[7,-0.0029363951180130243,0.1646713763475418,-0.9863440990447998,0,0.08918919414281845,-0.9823741912841797,-0.1642741560935974,0,-0.9960103631019592,-0.08845359832048416,-0.011802270077168941,0,0.9106753468513489,-0.27605140209198,0.2079598754644394,1],[7,-0.006482996512204409,-0.006647145841270685,-0.9999569654464722,0,-0.392072468996048,-0.9198933243751526,0.008656847290694714,0,-0.9199113845825195,0.3921116292476654,0.0033575037959963083,0,0.3140362501144409,-0.435947984457016,0.2528684735298157,1],[7,-0.004866776056587696,0.04164351522922516,-0.9991205334663391,0,0.9142624735832214,-0.40456151962280273,-0.02131560817360878,0,-0.4050934314727783,-0.9135623574256897,-0.03610417991876602,0,-0.11700839549303055,0.6120634078979492,0.2756005525588989,1],[7,0.00001867453829618171,8.364219183931709e-8,-1,0,-0.27926790714263916,-0.9602131247520447,-0.000005295514711178839,0,-0.9602131247520447,0.27926790714263916,-0.000017908181689563207,0,0.5647446513175964,0.47381478548049927,0.2479683756828308,1],[7,6.800517837746156e-8,4.1036329889720946e-8,-1,0,-0.6992723345756531,-0.7148553729057312,-7.688917946779839e-8,0,-0.7148553729057312,0.6992723345756531,-1.9918296345622366e-8,0,0.46161773800849915,0.2961753010749817,0.24796374142169952,1],[7,1.3943351007128513e-7,9.77789724743161e-8,-1,0,-0.7008450627326965,-0.7133134603500366,-1.674683716146319e-7,0,-0.7133134603500366,0.7008450627326965,-3.0931893491015217e-8,0,-0.19767583906650543,-0.3925482928752899,0.24970611929893494,1],[7,6.123234262925839e-17,-8.742282631146736e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742282631146736e-8,0,0.4145595133304596,-0.00024992681574076414,0.24796371161937714,1],[7,6.123234262925839e-17,-8.742280499518529e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.5503166913986206,1.0766070346335255e-7,0.2497062087059021,1],[7,6.123234262925839e-17,-8.742280499518529e-8,-1,0,-1,6.123233601181349e-17,-6.123234262925839e-17,0,6.123234262925839e-17,1,-8.742280499518529e-8,0,-0.6483774781227112,8.739819890024592e-8,0.2497062236070633,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[29],[98,"Wolf@Idle",[[-3,[92,"Rig",-5,[0,"2dhjIgK9JeGoyJLVaVzQLq",-4,0],[3,0.5000000447034803,0.5000000447034803,0.49999995529651575,0.49999995529651575],[1,0,90.00001024528345,90]],-6,[31,"RigLFLegPlatform",-8,[0,"a4jKxPZ/RffrXi+jXkOiWX",-7,0],[1,0.26857367157936096,5.5624472139470527e-8,0.550316572189331],[3,0.5150360452722308,0.5150360452722308,0.48449754599000877,0.48449754599000877],[1,0,93.4999984032698,90]],[31,"RigLBLegPlatform",-10,[0,"a9ElVwpxNYXJKckZa7rBs1",-9,0],[1,0.2482585459947586,-5.672027469927343e-8,-0.4822469651699066],[3,0.5107884403592357,0.5107884403592357,0.4889735874210176,0.4889735874210176],[1,0,92.49999632115454,90]],[31,"RigRBLegPlatform",-12,[0,"ccI3iDZeRcc6Gd8O+wAGP5",-11,0],[1,-0.27384909987449646,-5.927053692289519e-8,-0.4239038825035095],[3,0.4867401675354041,0.4867401675354041,0.5129171563786951,0.5129171563786951],[1,0,86.99999535339101,90]],[31,"RigRFLegPlatform",-14,[0,"5akvjlfwFTvowNGOfy7EE7",-13,0],[1,-0.2596813142299652,6.117182493881046e-8,0.4234079122543335],[3,0.48897354209592003,0.48897354209592003,0.5107884837485761,0.5107884837485761],[1,0,87.4999935104999,90]]],1,4,1,4,4,4,4],[[42,-2,[9,"85e1IBJo1fLb2LdwvVS3cA"],[3],4]],[0,"767tFETGRSvriw5QNcll/G",-1,0]],[2,"RigPelvis",1,[-15,-16,-17,-18],[0,"89PDhQIlhY866aXgfyoaBN",1,0],[1,1.6457939011615963e-8,0.9599540829658508,-0.3765145242214203],[3,0.7062185436195009,-0.03543004780911448,0.706218662828791,-0.03542993977569538],[1,179.9999907266631,-90.00001013672458,-5.744081465952221]],[27,"RigRibcage",[-19,-20,-21],[0,"37zIiBX1dckr5J3bbiO8yg",1,0],[1,0.4719027280807495,7.629394360719743e-8,9.094946814441375e-15],[3,4.208294834103455e-8,9.130989934702178e-8,0.2320989351576494,0.9726921837347492],[1,0.0000025352827985730302,0.000010152140058234415,26.84135278901541]],[94,"Wolf",1,[[43,-22,[9,"be1OI3ev9S64fnypq2RHZx"],[0],[21],1,1,2]],[0,"e1LaZkZjFWkZSPaYYpirtS",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[96,"RigSpine1",2,[-23],[0,"9aDlFB5LBTqLujV1jRB/Ya",1,0],[3,1.8557484276936318e-8,-1.3442824514539782e-8,-0.05845281431004375,0.9982901724945684],[1,0.000002046839339152552,-0.0000014232241668491547,-6.702019322501405]],[2,"RigSpine2",5,[3],[0,"aenc42JcBcRrh+va4VXJMG",1,0],[1,0.29825741052627563,-7.629394360719743e-8,-9.094946814441375e-15],[3,-1.176160511823334e-9,-2.9104436429448213e-8,-0.08370112695337346,0.9964909037952802],[1,-4.193342596760563e-7,-0.000003382089572817411,-9.602677499421873]],[2,"RigNeck",3,[-24],[0,"f4BfHa8vdYf59zgghyEg/L",1,0],[1,0.17187540233135223,0.01248374953866005,-2.435981416581967e-9],[3,0.002010366841683612,-0.0004962180880857868,0.10443360162530647,0.9945297054609972],[1,0.24029119573564037,-0.08240734705604341,11.988926598124408]],[4,"RigHead",7,[[31,"RigJaw",-25,[0,"451ZRhjDRVqqWwq/9JVQqL",1,0],[1,0.2368723303079605,0.14575080573558807,-2.9802322831784522e-9],[3,1.0245993510619666e-8,-3.038355437249343e-10,0.004432303884432187,0.9999901772928952],[1,0.0000011742932954743233,-4.002220650440834e-8,0.5079062752007576]]],[0,"0bL5TAj6xeIbj7zTAyP9UX",1,0],[1,0.21745574474334717,7.629394360719743e-8,-2.98023217215615e-10],[3,0.001847607437811238,-0.0010457382332591653,-0.12119269403479846,0.9926267292849268],[1,0.2015576837213067,-0.09611376871042918,-13.922078278454698]],[2,"RigLFLeg1",3,[-26],[0,"15LzmTUFhXBIqi0aO4q0bT",1,0],[1,-0.018028469756245613,0.17856445908546448,0.2532518208026886],[3,0.7702602196940653,0.6321252624575274,0.057668913521790335,0.06157225782013014],[1,173.52137624655944,-3.2414177409776603,78.78477204422026]],[2,"RigLFLeg2",9,[-27],[0,"d6LSu/j/BbepEHhV4Kt3OY",1,0],[1,0.4278086721897125,1.907348590179936e-8,1.907348590179936e-8],[3,0.08449019636703808,-0.021007124695170663,0.24241136430571728,0.966259198085763],[1,11.29878510270713,-5.2856116220065195,27.704697111155564]],[2,"RigLFLegAnkle",10,[-28],[0,"40DN+BRwRXVJ0Tjmb3oFQJ",1,0],[1,0.3531494140625,-7.629394360719743e-8,0],[3,-0.03119205276373116,0.014373004277208551,0.1855185607377797,0.982040394390279],[1,-4.099345048757745,2.4487323059489365,21.313872035193622]],[4,"RigLFLegToes1",11,[[6,"RigLFLegToes2",-29,[0,"86Brmq47lUt70ck+H1DQoA",1,0],[1,0.09806080162525177,1.818989362888275e-14,1.907348590179936e-8]]],[0,"3eJ/Ld1iRa14rfcKDbX8r0",1,0],[1,0.18801109492778778,-3.814697180359872e-8,0],[3,3.2489672799748746e-8,4.1903244835313664e-8,0.3867523327618111,0.9221836222267746],[1,0.000002249051972155862,0.0000042637192446613806,45.50514077348764]],[2,"RigRFLeg1",3,[-30],[0,"a9RtkdG6lfToJajkDukUau",1,0],[1,-0.018028507009148598,0.17856445908546448,-0.253251850605011],[3,0.7043747940049185,0.7049440779702502,-0.059783678825494825,-0.05775732205783759],[1,79.07543042724292,110.45974706913651,89.82945077502119]],[2,"RigRFLeg2",13,[-31],[0,"83uOTC6IRfrq7O57z/MBJj",1,0],[1,0.42780864238739014,-9.53674295089968e-9,-1.907348590179936e-8],[3,-0.08378473102319481,0.02362352287317887,0.27258644087348244,0.9581850970800782],[1,-11.702223626968717,6.105341020843483,31.22619039383383]],[2,"RigRFLegAnkle",14,[-32],[0,"cdDgrC5axbfp5Hs18b8clv",1,0],[1,0.3531494438648224,3.814697180359872e-8,0],[3,0.022776978337775818,-0.012637179482139133,0.251176956043653,0.9675906405630337],[1,3.306646651717199,-2.3532995537028816,29.045057325988434]],[4,"RigRFLegToes1",15,[[6,"RigRFLegToes2",-33,[0,"85POIU6aJTApa65OTrX6jv",1,0],[1,0.09806075692176819,-4.656612768993984e-12,-1.907348590179936e-8]]],[0,"edldWf+4JeRJmUar/VhU3n",1,0],[1,0.1880110204219818,-3.552713599391162e-17,-1.907348590179936e-8],[3,-0.000004964340542303026,-0.000012624970061321011,0.38652775757346935,0.9222777740145268],[1,0.000049256003309562006,-0.0015892758729519488,45.47723624022828]],[2,"RigTail1",2,[-34],[0,"04ZTgOx/BdtLZun8hjPnDn",1,0],[1,-0.15103934705257416,-0.04163070768117905,-2.217955596961474e-8],[3,-0.015205871585764202,-0.0064542113095004214,0.9842214760376552,0.1761681319988063],[1,179.55114921071936,178.31010838965128,20.302293955741867]],[2,"RigTail2",17,[-35],[0,"0ajssWChFWU7/Ol/E/h7SK",1,0],[1,0.12971889972686768,-7.629394360719743e-8,0],[3,-0.004458682278238298,0.01633480239705592,-0.004384277052899084,0.9998470245481126],[1,-0.5026689850670301,1.8697101549698198,-0.5106769464711745]],[2,"RigTail3",18,[-36],[0,"442e4x+7JWvoyHzuWhUlJo",1,0],[1,0.18786075711250305,-7.629394360719743e-8,8.881783998477905e-18],[3,-0.005300864523909106,0.015631167060669734,0.09802545508369886,0.9950470228121153],[1,-0.7952873125457244,1.8782257779715603,11.239708933164692]],[4,"RigTail4",19,[[31,"RigTail5",-37,[0,"f7xdLFXNVUyaAAgwAYcWqZ",1,0],[1,0.1575029045343399,1.4210854397564648e-16,-1.776356799695581e-17],[3,0.0017940991733328584,0.016376057162065732,0.1366943379109017,0.9904762813632041],[1,-0.05493758188656506,1.9020104028024454,15.71448161940655]]],[0,"8d0CMrySBV8pWaFu51MUsE",1,0],[1,0.20572014153003693,-7.629394360719743e-8,0],[3,-0.002118232407931266,0.016355424970892023,0.09733978570529599,0.9951145558599446],[1,-0.4321646984982176,1.9254717195085564,11.166407612678919]],[2,"RigLBLeg1",2,[-38],[0,"25tPUCUb9Vcqy1TpjJOJvQ",1,0],[1,-1.1444091541079615e-7,-4.577636616431846e-7,0.23893451690673828],[3,0.7520159628380955,0.6560043223400627,-0.036088150692485235,-0.05317862434704165],[1,-166.27920015296908,-6.4655444660052455,82.09175758856911]],[16,"RigLBLeg2",21,[-39],[0,"82/NsPlW1T3rVzZL1D6fdv",1,0],[1,0.4386618137359619,-1.1444091541079615e-7,1.907348590179936e-8],[3,-0.06635353859433744,-0.036988646601455746,-0.559748959869768,0.8251728000021057],[1,1.0000001192092896,0.9999982118606567,1.0000017881393433],[1,-22.48801772326291,-20.058664156802106,-66.7615226588703]],[16,"RigLBLegAnkle",22,[-40],[0,"28Frp+lBNdZ4VzKenjvudt",1,0],[1,0.2758634686470032,7.105427198782324e-17,1.907348590179936e-8],[3,-0.002644864386048785,-0.01656906498905915,0.6580019616660487,0.752829256353258],[1,1.0000022649765015,0.9999980926513672,1],[1,7.573216276822016,-9.133727546114171,82.22793878420882]],[4,"RigLBLegToes1",23,[[36,"RigLBLegToes2",-41,[0,"14DjO69mtRgadCFlBWxPeH",1,0],[1,0.17154911160469055,5.7220457705398076e-8,-3.552713599391162e-17],[3,5.655523476000377e-8,8.037295824398803e-8,0.38776842702224196,0.9217568263944056],[1,1.0000011920928955,0.9999990463256836,1],[1,0.0000034354426033526836,0.000008546621178941275,45.63143098391429]]],[0,"5fX5fiz0lWJJnyMQawi02k",1,0],[1,0.29748162627220154,-0.005120201036334038,-3.4332276754867053e-7],[3,-0.0000022548672060472907,-0.000009036249001180626,0.24321019278103703,0.9699736089403015],[1,0.0000013706549835906047,-0.0010678756705127033,28.152172648737398]],[2,"RigRBLeg1",2,[-42],[0,"d5JhS9hdNfi5DIakytpj/O",1,0],[1,-1.9073486612342094e-7,-5.340576194612368e-7,-0.23893456161022186],[3,0.7905313360073293,0.607236861219472,0.02482824768658323,0.07554574298797176],[1,160.42588851072387,11.359371571148673,74.54302777961134]],[16,"RigRBLeg2",25,[-43],[0,"72W915EVBeqbZD2rwkJtN1",1,0],[1,0.43866193294525146,-1.1444091541079615e-7,-1.907348590179936e-8],[3,0.06397721169090884,0.03972842542896321,-0.6011790631051426,0.7955578562752146],[1,1.0000003576278687,1.0000017881393433,0.9999985694885254],[1,29.075578838377808,27.086351617435003,-72.07533917765959]],[16,"RigRBLegAnkle",26,[-44],[0,"ad4ryrpSpR76l3h2BCCjMX",1,0],[1,0.2758633494377136,3.814697180359872e-8,0],[3,0.0056185889097441965,0.0383432315165193,0.6475652949558451,0.7610239265780565],[1,0.9999985098838806,1.0000015497207642,1],[1,-14.301429774823625,17.876651543715806,80.42070455071529]],[4,"RigRBLegToes1",27,[[36,"RigRBLegToes2",-45,[0,"c3XmArtZ5YKoHjziEdCH1z",1,0],[1,0.17154906690120697,3.814697180359872e-8,1.907348590179936e-8],[3,3.0358914704483714e-8,4.688419325894306e-9,0.3877673956690535,0.9217572602676035],[1,0.999999463558197,1.000001072883606,1.0000001192092896],[1,0.000004287810021339541,-0.0000012209501282898964,45.631302767513866]]],[0,"37oBsQkNpVsZ9x7nJFrsNi",1,0],[1,0.2974815368652344,-0.005120124667882919,3.623962356869015e-7],[3,0.000002296589172454097,0.00000905635806465257,0.24320942157088812,0.9699738023121357],[1,0.000003254334284785568,0.0010690914563534343,28.152081538918452]]],0,[0,3,1,0,7,1,0,-1,4,0,3,1,0,0,1,0,-3,2,0,3,1,0,0,1,0,3,1,0,0,1,0,3,1,0,0,1,0,3,1,0,0,1,0,-1,5,0,-2,17,0,-3,21,0,-4,25,0,-1,7,0,-2,9,0,-3,13,0,7,4,0,-1,6,0,-1,8,0,0,8,0,-1,10,0,-1,11,0,-1,12,0,0,12,0,-1,14,0,-1,15,0,-1,16,0,0,16,0,-1,18,0,-1,19,0,-1,20,0,0,20,0,-1,22,0,-1,23,0,-1,24,0,0,24,0,-1,26,0,-1,27,0,-1,28,0,0,28,0,12,1,3,0,6,45],[0,0,0,0,0],[-1,14,15,-1,16],[97,98,99,15,15]],[[[22,".bin",276055935,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":95760,"length":18408,"count":4602,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":95760,"count":1330,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]]},"minPosition",8,[1,-0.373635470867157,-1.4365330934524536,-0.00009283542749471962],"maxPosition",8,[1,0.373635470867157,1.770563006401062,1.5102485418319702]]],-1],0,0,[],[],[]],[[[54,"02 - Default",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":1,"specularFactor":0,"shininessExponent":1.9999999173704188},"mainColor",8,[4,4288059030],"specularColor",8,[4,4293256677],"emissiveColor",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[11,6],[100,10]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_OUTLINE_PASS":true},{},{},{}],[[{},[{},"mainColor",8,[4,4288387995]],{},{}],0,11,0,0]]],0,0,[0],[6],[4]],[[[56,"builtin-toon",[{"hash":2285632444,"name":"builtin-toon|outline-vs:vert|outline-fs:frag","blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 2) uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nout vec2 v_uv;\nlayout(std140) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 v_uv;\nlayout(std140) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nvarying vec2 v_uv;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  pos.z -= outlineParams.y * 0.002;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_mainLitColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 v_uv;\n   uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":198,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_POSITION_SCALING","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]}]},{"hash":3307737695,"name":"builtin-toon|toon-vs:vert|toon-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_shadowBias","type":14,"count":1,"stageFlags":17,"location":4,"defines":["CC_RECEIVE_SHADOW"]},{"name":"v_tangent","type":16,"count":1,"stageFlags":17,"location":5,"defines":["USE_NORMAL_MAP"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\nlayout(location = 1) out vec3 v_position;\nlayout(location = 2) out vec2 v_uv;\nlayout(location = 3) out mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  layout(location = 4) out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 5) out mediump vec4 v_tangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    layout(location = 0) in highp vec4 v_shadowPos;\n    layout(set = 0, binding = 2) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      highp vec4 cc_shadowInvProjDepthInfo;\n      highp vec4 cc_shadowProjDepthInfo;\n      highp vec4 cc_shadowProjInfo;\n      mediump vec4 cc_shadowNFLSInfo;\n      mediump vec4 cc_shadowWHPBInfo;\n      mediump vec4 cc_shadowLPNNInfo;\n      lowp vec4 cc_shadowColor;\n      mediump vec4 cc_planarNDInfo;\n    };\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n    #if CC_RECEIVE_SHADOW\n      layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n      layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n      {\n        vec4 newShadowPos = shadowPos;\n        if(normalBias > EPSILON_LOWP)\n        {\n          vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n          if(viewNormal.z < 0.1)\n            newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n        }\n        return newShadowPos;\n      }\n      vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n      {\n        float coeffA = cc_shadowProjDepthInfo.x;\n        float coeffB = cc_shadowProjDepthInfo.y;\n        float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n        viewSpacePos_z += viewspaceDepthBias;\n        vec4 result = shadowPos;\n        result.z = viewSpacePos_z * coeffA + coeffB;\n        return result;\n      }\n      float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(clipPos.z, closestDepth);\n        return shadow;\n      }\n      float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        vec2 clipPos_offset = clipPos.xy + oneTap;\n        float block0, block1, block2, block3;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n          block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n          block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n        }\n        float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block2, block3, coefX);\n        float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n        return mix(resultX, resultY, coefY);\n      }\n      float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        float clipPos_offset_L = clipPos.x - oneTap.x;\n        float clipPos_offset_R = clipPos.x + oneTap.x;\n        float clipPos_offset_U = clipPos.y - oneTap.y;\n        float clipPos_offset_D = clipPos.y + oneTap.y;\n        float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n          block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n          block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n          block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n          block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n          block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n          block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n          block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n        }\n        float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n        float shadow = 0.0;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block3, block4, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block1, block2, coefX);\n        resultY = mix(block4, block5, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block3, block4, coefX);\n        resultY = mix(block6, block7, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        resultX = mix(block4, block5, coefX);\n        resultY = mix(block7, block8, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        return shadow * 0.25;\n      }\n    float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n    {\n      float realtimeShadow = 1.0;\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n      float pcf = cc_shadowWHPBInfo.z;\n      if (pcf > 1.9) {\n        realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n      }else if (pcf > 0.9) {\n        realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n      }else {\n        realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n      }\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n    #endif\n        #if CC_RECEIVE_SHADOW\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 dirlightContrib = diffuse + specular;\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n    if(s.shadowCover < NL && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(v_shadowPos, N, s.shadowBias);\n    }\n    #endif\n    dirlightContrib *= shadow;\n    vec3 finalColor = lightColor * dirlightContrib;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in vec3 v_position;\nlayout(location = 2) in vec2 v_uv;\n#if CC_RECEIVE_SHADOW\n  layout(location = 4) in mediump vec2 v_shadowBias;\n#endif\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\nlayout(location = 3) in mediump vec3 v_normal;\n#if USE_NORMAL_MAP\n  layout(location = 5) in mediump vec4 v_tangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  layout(set = 1, binding = 3) uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  layout(set = 1, binding = 4) uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  layout(set = 1, binding = 5) uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n  s.shadowCover = miscParams.x;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\nout vec3 v_position;\nout vec2 v_uv;\nout mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    in highp vec4 v_shadowPos;\n    layout(std140) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      highp vec4 cc_shadowInvProjDepthInfo;\n      highp vec4 cc_shadowProjDepthInfo;\n      highp vec4 cc_shadowProjInfo;\n      mediump vec4 cc_shadowNFLSInfo;\n      mediump vec4 cc_shadowWHPBInfo;\n      mediump vec4 cc_shadowLPNNInfo;\n      lowp vec4 cc_shadowColor;\n      mediump vec4 cc_planarNDInfo;\n    };\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n    #if CC_RECEIVE_SHADOW\n      uniform highp sampler2D cc_shadowMap;\n      uniform highp sampler2D cc_spotLightingMap;\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n      {\n        vec4 newShadowPos = shadowPos;\n        if(normalBias > EPSILON_LOWP)\n        {\n          vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n          if(viewNormal.z < 0.1)\n            newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n        }\n        return newShadowPos;\n      }\n      vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n      {\n        float coeffA = cc_shadowProjDepthInfo.x;\n        float coeffB = cc_shadowProjDepthInfo.y;\n        float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n        viewSpacePos_z += viewspaceDepthBias;\n        vec4 result = shadowPos;\n        result.z = viewSpacePos_z * coeffA + coeffB;\n        return result;\n      }\n      float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(clipPos.z, closestDepth);\n        return shadow;\n      }\n      float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        vec2 clipPos_offset = clipPos.xy + oneTap;\n        float block0, block1, block2, block3;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n          block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n          block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n        }\n        float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block2, block3, coefX);\n        float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n        return mix(resultX, resultY, coefY);\n      }\n      float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        float clipPos_offset_L = clipPos.x - oneTap.x;\n        float clipPos_offset_R = clipPos.x + oneTap.x;\n        float clipPos_offset_U = clipPos.y - oneTap.y;\n        float clipPos_offset_D = clipPos.y + oneTap.y;\n        float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n          block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n          block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n          block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n          block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n          block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n          block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n          block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n        }\n        float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n        float shadow = 0.0;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block3, block4, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block1, block2, coefX);\n        resultY = mix(block4, block5, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block3, block4, coefX);\n        resultY = mix(block6, block7, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        resultX = mix(block4, block5, coefX);\n        resultY = mix(block7, block8, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        return shadow * 0.25;\n      }\n    float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n    {\n      float realtimeShadow = 1.0;\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n      float pcf = cc_shadowWHPBInfo.z;\n      if (pcf > 1.9) {\n        realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n      }else if (pcf > 0.9) {\n        realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n      }else {\n        realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n      }\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n    #endif\n        #if CC_RECEIVE_SHADOW\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 dirlightContrib = diffuse + specular;\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n    if(s.shadowCover < NL && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(v_shadowPos, N, s.shadowBias);\n    }\n    #endif\n    dirlightContrib *= shadow;\n    vec3 finalColor = lightColor * dirlightContrib;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nin mediump vec3 v_normal;\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n  s.shadowCover = miscParams.x;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_localShadowBias;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBias.x + cc_shadowWHPBInfo.w, a_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #elif !USE_BATCHING\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    varying highp vec4 v_shadowPos;\n    uniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n    #if CC_RECEIVE_SHADOW\n      uniform highp sampler2D cc_shadowMap;\n      uniform highp sampler2D cc_spotLightingMap;\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n      {\n        vec4 newShadowPos = shadowPos;\n        if(normalBias > EPSILON_LOWP)\n        {\n          vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n          if(viewNormal.z < 0.1)\n            newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n        }\n        return newShadowPos;\n      }\n      vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n      {\n        float coeffA = cc_shadowProjDepthInfo.x;\n        float coeffB = cc_shadowProjDepthInfo.y;\n        float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n        viewSpacePos_z += viewspaceDepthBias;\n        vec4 result = shadowPos;\n        result.z = viewSpacePos_z * coeffA + coeffB;\n        return result;\n      }\n      float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n        } else {\n          closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(clipPos.z, closestDepth);\n        return shadow;\n      }\n      float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        vec2 clipPos_offset = clipPos.xy + oneTap;\n        float block0, block1, block2, block3;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n          block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n          block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n        }\n        float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block2, block3, coefX);\n        float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n        return mix(resultX, resultY, coefY);\n      }\n      float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n        vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n        vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        float offsetDepth = clipPos.z;\n        vec2 mapSize = cc_shadowWHPBInfo.xy;\n        vec2 oneTap = 1.0 / mapSize;\n        float clipPos_offset_L = clipPos.x - oneTap.x;\n        float clipPos_offset_R = clipPos.x + oneTap.x;\n        float clipPos_offset_U = clipPos.y - oneTap.y;\n        float clipPos_offset_D = clipPos.y + oneTap.y;\n        float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n        if (cc_shadowLPNNInfo.y > EPSILON) {\n          block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        } else {\n          block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n          block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n          block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n          block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n          block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n          block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n          block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n          block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n          block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n        }\n        float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n        float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n        float shadow = 0.0;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block3, block4, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block1, block2, coefX);\n        resultY = mix(block4, block5, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block3, block4, coefX);\n        resultY = mix(block6, block7, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        resultX = mix(block4, block5, coefX);\n        resultY = mix(block7, block8, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        return shadow * 0.25;\n      }\n    float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n    {\n      float realtimeShadow = 1.0;\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n      float pcf = cc_shadowWHPBInfo.z;\n      if (pcf > 1.9) {\n        realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n      }else if (pcf > 0.9) {\n        realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n      }else {\n        realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n      }\n      return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n    }\n    #endif\n        #if CC_RECEIVE_SHADOW\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 dirlightContrib = diffuse + specular;\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n    if(s.shadowCover < NL && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(v_shadowPos, N, s.shadowBias);\n    }\n    #endif\n    dirlightContrib *= shadow;\n    vec3 finalColor = lightColor * dirlightContrib;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n    uniform vec4 shadeColor1;\n    uniform vec4 shadeColor2;\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 miscParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvarying mediump vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture2D(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture2D(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture2D(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    baseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = baseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w;\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture2D(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n  s.shadowCover = miscParams.x;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":227,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":79}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_1ST_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_2ND_SHADE_MAP","type":"boolean","defines":[]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]},{"name":"SHADE_MAP_1_AS_SHADE_MAP_2","type":"boolean","defines":["USE_1ST_SHADE_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_1","type":"boolean","defines":["USE_BASE_COLOR_MAP"]},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_2","type":"boolean","defines":["USE_BASE_COLOR_MAP"]}]},{"hash":3596762244,"name":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":2,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec4 v_worldPos;\nlayout(location = 2) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec4 v_worldPos;\nlayout(location = 2) in float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  layout(set = 1, binding = 1) uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nout vec2 v_uv;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 baseColor;\n   uniform vec4 colorScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    baseColor *= texture2D(baseColorMap, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":188,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":79}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_BASE_COLOR_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r","g","b"]}]}],[{"passes":[{"program":"builtin-toon|outline-vs:vert|outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16,"editor":{"type":"color"}},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[10,0,0,0]}}},{"program":"builtin-toon|toon-vs:vert|toon-fs:frag","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":1,"program":"builtin-toon|toon-vs:vert|toon-fs:frag","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":1,"program":"builtin-toon|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"editor":{"displayName":"BaseColor","type":"color"},"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1],"editor":{"type":"color"}},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1],"editor":{"type":"color"}},"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"mainTexture":{"value":"white","type":28,"editor":{"displayName":"BaseColorMap"},"handleInfo":["baseColorMap",0,28]},"baseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[101,4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[102,4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[[{},"baseColorMap",6,0],[{},"mainColor",8,[4,4294967295],"normalMap",6,1,"mainTexture",6,2],{},{}],11,11,0,0]]],0,0,[0,0,0,0],[43,25,11,6],[16,16,16,4]],[[[29],[50,"dy10_Idle (9)",[-3,-4],[[42,-2,[9,"98ZgMaUV9SDIBKrfnoOnNs"],[22],23]],[0,"80lU7+iv5Q5Im2sVmcAxVz",-1,0]],[27,"mixamorig:LeftHand",[-5,-6,-7,-8,-9],[0,"8bhgZxrTZUWqAA/FbpehDO",1,0],[1,3.1512395470834065e-10,0.7554779648780823,2.537192900220475e-9],[3,-0.07319512061847175,0.010128947689779563,-0.07400186201768912,0.994516768664189],[1,-8.378268867098845,0.5396391414473153,-8.550146620868958]],[27,"mixamorig:RightHand",[-10,-11,-12,-13,-14],[0,"bbQ/Ci/NtcgowicPX0NjHK",1,0],[1,3.9580949628970075e-10,0.7555135488510132,-1.2063841481335658e-8],[3,-0.06639504403065177,-0.009502746122415263,0.07731718535509512,0.9947479322889125],[1,-7.598066674064674,-0.5010302330982042,8.921673287207016]],[34,"mixamorig:Hips",1,[-15,-16,-17],[0,"2fhT3teTRRxYKu/h2SGMrW",1,0],[1,-0.000003128051730527659,2.543825387954712,0.018579719588160515]],[51,"mixamorig:Spine2",[-18,-19,-20],[0,"3er0TGo99b3ogY+EpLU59e",1,0],[1,0,0.33084166049957275,9.062015027261339e-11]],[97,"SK_CHR_Naruto_Next",1,[[43,-21,[9,"00ulMVNgNeUrTrVMrGWZu3"],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19],[21],1,20,21]],[0,"a8c6xpfdNemqCDwTbVq2va",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,100,100,100],[1,-90.00000000000003,0,0]],[2,"mixamorig:Spine",4,[-22],[0,"4eu77FTKlX8ZCHrFcKueCn",1,0],[1,0,0.24791350960731506,-0.010390781797468662],[3,-0.02094264564679409,0,0,0.9997806787457502],[1,-2.400025876259385,0,0]],[34,"mixamorig:Spine1",7,[5],[0,"b2x82qlclXTID0qUcAPqd8",1,0],[1,0,0.28948670625686646,8.921819394380748e-10]],[2,"mixamorig:Neck",5,[-23],[0,"22Vd78MqJUd4ITX35hNqy8",1,0],[1,0,0.37219691276550293,1.0185607912660544e-8],[3,0.02094267729787427,0,0,0.9997806780827467],[1,2.400029504001649,0,0]],[53,"mixamorig:Head",9,[[6,"mixamorig:HeadTop_End",-24,[0,"b7ZQnv7aBScqf80eP3rX/3",1,0],[1,0,0.569049060344696,-0.00009705543197924271]]],[0,"30e0vZrNJYO6MAKXFYOx2o",1,0],[1,0,0.2271398901939392,-0.00003874063622788526]],[2,"mixamorig:LeftShoulder",5,[-25],[0,"0ejUDj5OpUr7FXzL7d60b2",1,0],[1,0.15344485640525818,0.29873865842819214,-0.003171046730130911],[3,-0.5919275242595988,-0.3810095462494408,0.6042740898970456,-0.37323766686897286],[1,115.53426120277456,91.1821473743769,-0.000895422090938213]],[2,"mixamorig:LeftArm",11,[-26],[0,"f0cKJLiVpYqJf4KqoVSnAh",1,0],[1,1.0116951026928334e-10,0.33991023898124695,2.1838895136738756e-9],[3,0.20068999084257297,-0.0009171252227886108,-0.004476843967709169,0.979644141678509],[1,23.154866542726896,1.630926845430626e-7,-0.5236645676689122]],[2,"mixamorig:LeftForeArm",12,[2],[0,"a5mBEB4ddSUaSjMK7baECg",1,0],[1,5.925358120828506e-11,0.49952372908592224,6.95890989277359e-9],[3,-0.023481829753164353,0.000020572896243713544,-0.0008759789299098567,0.9997238798333836],[1,-2.691067859722887,-2.718628554057736e-7,-0.10040748371046077]],[2,"mixamorig:LeftHandThumb1",2,[-27],[0,"ea3YlqpsVUEIA0ZhV/hbK8",1,0],[1,-0.06823808699846268,0.09966664016246796,0.03487679734826088],[3,0.13863880878587703,0.030493646741913957,0.21264009095254782,0.9667645059302211],[1,16.32171760416248,8.100581909751039e-7,24.809398928534957]],[2,"mixamorig:LeftHandThumb2",14,[-28],[0,"begtylQW1XoI1VeoHSM7mq",1,0],[1,-0.01609603688120842,0.09928210079669952,-1.647740610621895e-9],[3,0.021835349476455067,2.2023824405999494e-17,5.5043377226331714e-17,0.9997615803346521],[1,2.502345611016994,2.3854160573160743e-15,6.3611094172673865e-15]],[4,"mixamorig:LeftHandThumb3",15,[[6,"mixamorig:LeftHandThumb4",-29,[0,"d9CtBZzOBfBZcMDpWQryrj",1,0],[1,0.012453935109078884,0.05345321074128151,1.04612640772217e-9]]],[0,"9fCxVpgOpRD6tJaAI8I7jK",1,0],[1,0.003642096882686019,0.08011551201343536,-4.5480250121521237e-10],[3,-0.11054969377193524,3.7550184167513686e-17,-2.3749986153053617e-17,0.9938705978179109],[1,-12.694007932625842,3.97569344016752e-15,-3.180554530348419e-15]],[2,"mixamorig:LeftHandIndex1",2,[-30],[0,"eaScZuxINfUpGFlVrSzwxL",1,0],[1,-0.07622948288917542,0.24970991909503937,-0.0012822211720049381],[3,0.06383292973351552,0.005827381139842849,0.09072616485007168,0.9938109285584882],[1,7.350171439555715,-2.1488352665250387e-7,10.432280742345364]],[2,"mixamorig:LeftHandIndex2",17,[-31],[0,"f34swq6ctWn5878J7lrGST",1,0],[1,0.000026728408556664363,0.08337091654539108,-3.3406763466636846e-10],[3,-0.01969022720842755,1.7343871628522296e-18,3.4157099385776544e-20,0.9998061286831965],[1,-2.2564796575054356,1.987846675914698e-16,0]],[4,"mixamorig:LeftHandIndex3",18,[[6,"mixamorig:LeftHandIndex4",-32,[0,"00LOq5hZdetqW0/s0rZ4tc",1,0],[1,-0.000033836047805380076,0.06835298985242844,-8.388485461807704e-10]]],[0,"db9rQMNTdVwqNOs+F/cLtj",1,0],[1,0.0000071081522037275136,0.07807380706071854,4.615358761839161e-9],[3,-0.05012604700220879,1.3847234323529613e-18,7.017126313075974e-18,0.998742899555202],[1,-5.746430022243372,1.9878467026410057e-16,7.951387236170566e-16]],[2,"mixamorig:LeftHandMiddle1",2,[-33],[0,"dcDxvoEp1d6pJehQhu28J1",1,0],[1,-0.024737069383263588,0.25656914710998535,-0.008600491099059582],[3,0.07398408087880048,0.004819509225909332,0.06482587168776664,0.9951385503874633],[1,8.503723282789823,-3.593405397795123e-7,7.454255093166267]],[2,"mixamorig:LeftHandMiddle2",20,[-34],[0,"9atXOBbvJRKIvzq0sOt8mv",1,0],[1,0.00005336236790753901,0.08792310953140259,2.0153914093157255e-9],[3,-0.04813092145635443,-4.174691968536692e-20,8.663564966127093e-19,0.9988410356006415],[1,-5.5175290316936385,0,9.939233379573487e-17]],[4,"mixamorig:LeftHandMiddle3",21,[[6,"mixamorig:LeftHandMiddle4",-35,[0,"06MJCbzwVab5SX3uQfQjbD",1,0],[1,-0.00002879076600947883,0.07313071191310883,-1.0715780485170967e-9]]],[0,"efB8Y+aeddi7q0uXT9mE7J",1,0],[1,-0.000024571641915827058,0.08239860087633133,2.1458503862703537e-9],[3,-0.005070612396355796,1.725905142994781e-18,1.743497413801058e-18,0.9999871443623293],[1,-0.5810518696487094,1.987846766449175e-16,1.9878468226379773e-16]],[2,"mixamorig:LeftHandRing1",2,[-36],[0,"6a0ildNMFY2b5L6TPkOyud",1,0],[1,0.026519620791077614,0.25759923458099365,-0.004224080126732588],[3,0.0490502230768457,0.0005321560310538997,0.010835536754415656,0.9987373946985836],[1,5.623329010992383,-1.5667592426688468e-7,1.2431819765407806]],[2,"mixamorig:LeftHandRing2",23,[-37],[0,"beZoTUr8FVOq6KcQIRodNi",1,0],[1,0.0000425052858190611,0.08264815807342529,7.008867264346463e-9],[3,-0.007396858661537385,-1.2091406092316009e-17,-7.028524723372817e-18,0.9999726428667642],[1,-0.8476252954685697,-1.391492670647784e-15,-7.951386838068007e-16]],[4,"mixamorig:LeftHandRing3",24,[[6,"mixamorig:LeftHandRing4",-38,[0,"16+d/w9YJYhqBcoKTtbnKj",1,0],[1,-0.00006422551814466715,0.0730326697230339,7.1040511251396765e-9]]],[0,"42jwZXIFtaPaUwILlPBLY8",1,0],[1,0.00002171814048779197,0.08137925714254379,-2.361488116164878e-9],[3,-0.034261353767509134,-5.2011153051955505e-18,-1.7830192409773356e-19,0.9994129074801954],[1,-3.9268304435742594,-5.963540264574764e-16,8.118905892053997e-25]],[2,"mixamorig:LeftHandPinky1",2,[-39],[0,"a1n4vWewVVULsD9TVGX2wa",1,0],[1,0.0744469165802002,0.2509515583515167,-0.0017113537760451436],[3,0.05025585473332685,-0.0005912904285565831,-0.011749823823325517,0.9986670822054626],[1,5.76172274169704,-5.556725424570618e-7,-1.348165529586794]],[2,"mixamorig:LeftHandPinky2",26,[-40],[0,"ebhhk0Mv1RW7Rbn7b+BPuI",1,0],[1,0.00008914539648685604,0.07797853648662567,-8.057935430016983e-10],[3,0.0030054182690797283,-6.9388625659216576e-18,2.085427850600874e-20,0.9999954837203155],[1,0.34439608344273104,-7.951386703658792e-16,0]],[4,"mixamorig:LeftHandPinky3",27,[[6,"mixamorig:LeftHandPinky4",-41,[0,"b6EFUr7tRd/bi5HmZDzB/d",1,0],[1,-0.00016625438001938164,0.05385046824812889,-6.097087834611159e-10]]],[0,"c49jdfEM9eFoUdXBCfh3GV",1,0],[1,0.00007710701902396977,0.06458614021539688,2.4846753543528166e-9],[3,-0.10780145850212305,-4.9452744204174535e-18,1.342290283814983e-17,0.9941724425595466],[1,-12.377189476347342,-3.975693460044179e-16,1.590277350843624e-15]],[2,"mixamorig:RightShoulder",5,[-42],[0,"5ad6+7MihayJ8nzo2rpV9S",1,0],[1,-0.15344485640525818,0.2987309396266937,-0.002986963139846921],[3,0.5922993447157963,-0.3807701782950536,0.6039285089849684,0.3734513537337686],[1,115.53715521373003,-91.11339268754342,0.000915832627791337]],[2,"mixamorig:RightArm",29,[-43],[0,"8ezMwYU9NU5b133h4w+ZP9",1,0],[1,-1.017364872901716e-10,0.33991023898124695,2.1838633124104945e-9],[3,0.20055134389464332,0.0015336432104644461,0.007491547072106388,0.9796533484467973],[1,23.13908982464429,-1.291261816383748e-7,0.8762806767470795]],[2,"mixamorig:RightForeArm",30,[3],[0,"deC0fGm4dUwoD3rLSxLBHN",1,0],[1,5.93234628087913e-11,0.4995066225528717,-6.89195200909154e-10],[3,-0.023228412717369782,0.000102404840692939,-0.004407330458512823,0.9997204638268187],[1,-2.66204532255812,1.0588253200707587e-7,-0.5051808152861212]],[2,"mixamorig:RightHandThumb1",3,[-44],[0,"afWXC0sHtQsp8yFzqrScjq",1,0],[1,0.06479472666978836,0.09475252777338028,0.029395591467618942],[3,0.1252670912173926,-0.0247446695293918,-0.19220425618798348,0.9730125287430982],[1,14.671984459182434,-6.664981729443646e-7,-22.34815834619427]],[2,"mixamorig:RightHandThumb2",32,[-45],[0,"35FfASWvZUQIt5P5U9q+hR",1,0],[1,0.01911994256079197,0.09284579753875732,3.001782822309451e-9],[3,0.051165446782335686,-4.1749658517031826e-18,-1.3682095111170818e-17,0.9986901907276171],[1,5.865689516926802,-3.9756933306112336e-16,-1.5902773821471549e-15]],[4,"mixamorig:RightHandThumb3",33,[[6,"mixamorig:RightHandThumb4",-46,[0,"72oXpVeONbbYRrJzM6fZn8",1,0],[1,-0.021108077839016914,0.06503773480653763,-3.464731557212275e-10]]],[0,"52mTqSo5NVg7cEsgUAafO5",1,0],[1,0.0019881364423781633,0.08343122154474258,1.7993954937178813e-10],[3,-0.03349625016741229,6.470146502470955e-18,1.4102427195954242e-17,0.9994388431638636],[1,-3.8391056685462623,7.951387002681411e-16,1.5902773486209386e-15]],[2,"mixamorig:RightHandIndex1",3,[-47],[0,"8fwxTLCw5Q3rw4/chgJxnT",1,0],[1,0.07861758768558502,0.2661815583705902,-0.0008132026414386928],[3,0.041519231041866174,-0.0030345895024086874,-0.07283109986945563,0.9964750752588092],[1,4.771823329367738,-1.7839885948707137e-7,-8.36048578499081]],[2,"mixamorig:RightHandIndex2",35,[-48],[0,"8ddKsGJCZYHKkABoLw4znK",1,0],[1,-0.00001536621493869461,0.07450277358293533,-1.2334078203224408e-9],[3,-0.004706038688964687,1.728836660831948e-18,1.254982415059233e-18,0.9999889265386182],[1,-0.539274300751762,1.987846717681466e-16,1.4287648527318676e-16]],[4,"mixamorig:RightHandIndex3",36,[[6,"mixamorig:RightHandIndex4",-49,[0,"f7ywL4zdhZsJgJckhIirtZ",1,0],[1,0.000026592764697852544,0.05952368304133415,-2.907086238401746e-10]]],[0,"2fQYs7wHJT24a206DgBb8u",1,0],[1,-0.000011226647984585725,0.07401841878890991,2.3260378068101772e-9],[3,-0.05102627202659136,1.7703294395221336e-19,-3.4649273425536405e-18,0.9986973112825868],[1,-5.849720405078481,0,-3.9756933518293945e-16]],[2,"mixamorig:RightHandMiddle1",3,[-50],[0,"74YTgWL3VdqItDckUCBYtQ",1,0],[1,0.026139628142118454,0.28110793232917786,-0.0027039896231144667],[3,0.017386499699073518,-0.0009861915552241856,-0.05662195726658538,0.9982438033916021],[1,1.995649420414369,-2.2673939828236065e-7,-6.4928560417921695]],[2,"mixamorig:RightHandMiddle2",38,[-51],[0,"1csPJYrzZQ/rlWvDC+r73v",1,0],[1,0.00003327268495922908,0.07489927113056183,4.691635080433798e-9],[3,0.0073172500633655515,1.734677034944191e-18,-1.2693405464513001e-20,0.9999732285674003],[1,0.8385025751971076,1.987846675914698e-16,0]],[4,"mixamorig:RightHandMiddle3",39,[[6,"mixamorig:RightHandMiddle4",-52,[0,"feXbhJxlVS/6iUXeCEySlK",1,0],[1,-0.00005511975541594438,0.062118180096149445,-1.356068590752102e-9]]],[0,"86biREmrlVfYpdMc+zCTew",1,0],[1,0.000021846488380106166,0.07580455392599106,1.3156875589004358e-9],[3,0.08819276277731773,-1.1789768292622986e-17,4.52685849284356e-18,0.9961034266549351],[1,10.119293121578451,-1.3914927213945246e-15,3.975693428054566e-16]],[2,"mixamorig:RightHandRing1",3,[-53],[0,"98NCGSXL1SlZM54u6AoILh",1,0],[1,-0.025078412145376205,0.28350740671157837,-0.0012442772276699543],[3,0.005766132761062361,0.00008758735072977568,0.015188338010039574,0.9998680205056717],[1,0.6608300377323263,-2.501989408517762e-7,1.7405511977415764]],[2,"mixamorig:RightHandRing2",41,[-54],[0,"a4zrmG6PBXF5OP7rb34+CR",1,0],[1,0.000020215476979501545,0.07875383645296097,-6.068735736164399e-9],[3,0.03580028979671507,-1.0401668943150802e-17,3.7262163186750476e-19,0.9993589641617627],[1,4.103287843723973,-1.19270802928363e-15,6.317530675107159e-25]],[4,"mixamorig:RightHandRing3",42,[[6,"mixamorig:RightHandRing4",-55,[0,"b3qyqzeBJYbq1XWfM9GdS2",1,0],[1,0.0000338208737957757,0.06180074065923691,4.1634223846287455e-10]]],[0,"5fO23mjbhRiohrTMNVOjgM",1,0],[1,-0.00005403748946264386,0.07021472603082657,-2.92122415146423e-9],[3,-0.04625854268900973,-2.823766723138221e-18,-1.4023422881521722e-17,0.9989295006296938],[1,-5.302730850097638,-3.9756933938804923e-16,-1.5902773034708191e-15]],[2,"mixamorig:RightHandPinky1",3,[-56],[0,"150u9jGntTxJjwIehwJ8SY",1,0],[1,-0.07967879623174667,0.28354570269584656,-0.001356903463602066],[3,0.04458761538137666,-0.0008690296575609725,-0.01946724743346461,0.9988154061784493],[1,5.112030150776474,-2.373045897289809e-7,-2.2331452068535502]],[2,"mixamorig:RightHandPinky2",44,[-57],[0,"e0cydqLsZcA7UMslLqZglh",1,0],[1,-0.000008642132343084086,0.06324749439954758,-4.9407771207654605e-9],[3,-0.022904551978148707,-2.0811220173604655e-17,-4.76796768278707e-19,0.9997376563372414],[1,-2.6248978657602136,-2.3854159637161142e-15,-1.0855373558406892e-24]],[4,"mixamorig:RightHandPinky3",45,[[6,"mixamorig:RightHandPinky4",-58,[0,"4aDfSjSzddGaiLVpThOJqL",1,0],[1,-0.00001315343615715392,0.04210589453577995,-4.743065940004954e-10]]],[0,"b7NQPv379a2KLVXv7o4KAt",1,0],[1,0.000021795172870042734,0.056013647466897964,6.3092939761588696e-9],[3,0.04801307978237481,1.0396336782858228e-17,-4.99736512839295e-19,0.9988467070425829],[1,5.504009740529499,1.1927079819502797e-15,-2.6171180290804034e-24]],[2,"mixamorig:LeftUpLeg",4,[-59],[0,"155fvYY5FXUoxdZr/4e7JD",1,0],[1,0.26550695300102234,-0.13765335083007812,0.001145936199463904],[3,-0.0009335272704862828,-0.01210788200928808,0.996967399313972,-0.0768669787699461],[1,178.5917496698333,179.78415004402945,-8.81503415842526]],[2,"mixamorig:LeftLeg",47,[-60],[0,"6eAWzQKM1cB4XldORPo8Dc",1,0],[1,-5.653903567548468e-9,1.0730738639831543,3.630646998320497e-12],[3,-0.012169317370129218,-0.00009363309094177091,0.0076934122656128826,0.999896349805969],[1,-1.3945767516091212,2.1736668749234872e-8,0.8816740946293606]],[2,"mixamorig:LeftFoot",48,[-61],[0,"0bbEOGEk5Tp5bxYG8rI9FN",1,0],[1,-3.2567057384191855e-10,1.043325424194336,-9.016710295073338e-11],[3,0.44114047073934176,0.01608258664221803,-0.007907071112309476,0.8972591118005949],[1,52.36238849895966,2.053734448546008,-0.0000013477251489260234]],[4,"mixamorig:LeftToeBase",49,[[6,"mixamorig:LeftToe_End",-62,[0,"7cGm4cT51ftKylV2s41TvQ",1,0],[1,-8.349559238451931e-11,0.1661551594734192,-4.190820260263628e-11]]],[0,"86MQ/YjwxZuI8qGaI/dIvY",1,0],[1,2.077596761296263e-9,0.4394707679748535,-1.1199151828122922e-8],[3,0.34384214410733793,-0.015489041594741073,0.005672470589368213,0.938882576578966],[1,40.22797349906079,-1.8902815068092897,-1.684025034802733e-7]],[2,"mixamorig:RightUpLeg",4,[-63],[0,"1eEOfV8odTwY6tCw2k9f+D",1,0],[1,-0.26550695300102234,-0.13765335083007812,0.00302491313777864],[3,0.0008598101679088959,-0.011151274823023615,0.9969782969501428,0.07687122482886052],[1,178.7030134768817,-179.80119236679036,8.815821067282183]],[2,"mixamorig:RightLeg",51,[-64],[0,"72ampx0wxewKI+8n4R3nMd",1,0],[1,5.520355284005518e-9,1.0730268955230713,5.36511945981033e-10],[3,-0.015384339570424291,0.00011825177959764652,-0.007685369267841721,0.9998521106702308],[1,-1.763037087938019,-4.483278453370156e-9,-0.8807913620924719]],[2,"mixamorig:RightFoot",52,[-65],[0,"ed6eAppfhe7qXIRFMrh8+X",1,0],[1,3.454321051421516e-9,1.0435596704483032,-1.9439050369385313e-9],[3,0.4420593121416263,-0.016241764791244263,0.008006020518849,0.8968030292437631],[1,52.47995579723936,-2.0751108606493003,9.385963468691186e-9]],[4,"mixamorig:RightToeBase",53,[[6,"mixamorig:RightToe_End",-66,[0,"d378n3nGRc4Ym0Pp2CMHt+",1,0],[1,-6.524600998369934e-11,0.16844326257705688,4.4584513164691586e-11]]],[0,"45FPQOqFdZhZzMECwBooHy",1,0],[1,8.664327033613972e-10,0.438231498003006,-2.5824924421158357e-9],[3,0.3449957941043856,0.015650199609364757,-0.005753333171710594,0.9384561110994413],[1,40.368934562339206,1.9108133397760128,2.7134616561642496e-7]]],0,[0,3,1,0,7,1,0,-1,6,0,-2,4,0,-1,14,0,-2,17,0,-3,20,0,-4,23,0,-5,26,0,-1,32,0,-2,35,0,-3,38,0,-4,41,0,-5,44,0,-1,7,0,-2,47,0,-3,51,0,-1,9,0,-2,11,0,-3,29,0,7,6,0,-1,8,0,-1,10,0,0,10,0,-1,12,0,-1,13,0,-1,15,0,-1,16,0,0,16,0,-1,18,0,-1,19,0,0,19,0,-1,21,0,-1,22,0,0,22,0,-1,24,0,-1,25,0,0,25,0,-1,27,0,-1,28,0,0,28,0,-1,30,0,-1,31,0,-1,33,0,-1,34,0,0,34,0,-1,36,0,-1,37,0,0,37,0,-1,39,0,-1,40,0,0,40,0,-1,42,0,-1,43,0,0,43,0,-1,45,0,-1,46,0,0,46,0,-1,48,0,-1,49,0,-1,50,0,0,50,0,-1,52,0,-1,53,0,-1,54,0,0,54,0,12,1,2,0,13,3,0,31,5,0,8,66],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,14,15,-1,16],[103,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,104,105,23,23]],[[[41,"Skin-0",3065174259,["mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1","mixamorig:Hips","mixamorig:Hips/mixamorig:LeftUpLeg","mixamorig:Hips/mixamorig:RightUpLeg","mixamorig:Hips/mixamorig:Spine","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2/mixamorig:RightHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2/mixamorig:RightHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2/mixamorig:RightHandRing3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2/mixamorig:LeftHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2/mixamorig:LeftHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2/mixamorig:LeftHandRing3"],[[[7,17.455259323120117,-49.561954498291016,85.08187866210938,0,-97.07734680175781,-23.11672019958496,6.45026159286499,0,16.471263885498047,-83.72114562988281,-52.14851760864258,0,-0.22742345929145813,1.3597556352615356,2.5169308185577393,1],[7,17.455259323120117,-55.14738845825195,81.57254028320312,0,-97.07734680175781,-23.496723175048828,4.888009548187256,0,16.471263885498047,-80.04167175292969,-57.63703536987305,0,-0.22941160202026367,1.1049394607543945,2.5967390537261963,1],[7,-12.852639198303223,-77.16976165771484,62.28673553466797,0,-98.87743377685547,14.797611236572266,-2.0695886611938477,0,-7.619852542877197,-61.8535270690918,-78.20536804199219,0,0.054706871509552,0.618044912815094,2.886904716491699,1],[7,17.455259323120117,-57.99755859375,79.57133483886719,0,-97.07734680175781,-23.654882431030273,4.054033279418945,0,16.471263885498047,-77.95338439941406,-60.431514739990234,0,-0.2083035260438919,1.1882596015930176,2.6427154541015625,1],[7,-1.4955122470855713,-72.76583862304688,68.57766723632812,0,-99.97823333740234,0.09042481333017349,-2.0843350887298584,0,1.4546726942062378,-68.59391021728516,-72.75135040283203,0,-0.07481779158115387,0.5836756825447083,2.8490383625030518,1],[7,-9.835891723632812,-71.7532958984375,68.95447540283203,0,-99.37894439697266,10.705631256103516,-3.0355710983276367,0,-5.203889846801758,-68.8248062133789,-72.36066436767578,0,0.12124956399202347,0.5954853296279907,2.846524238586426,1],[7,-15.190638542175293,-76.02029418945312,63.1677131652832,0,-98.38235473632812,17.76900291442871,-2.274676561355591,0,-9.49505615234375,-62.49142074584961,-77.48977661132812,0,0.0899096205830574,0.365247905254364,2.8841283321380615,1],[7,-4.0438971519470215,-75.9117202758789,64.96966552734375,0,-99.91653442382812,3.447498083114624,-2.1909713745117188,0,-0.5766237378120422,-65.00403594970703,-75.98777770996094,0,-0.009716584347188473,0.43842780590057373,2.8760855197906494,1],[7,-4.0438971519470215,-74.95281982421875,66.0736083984375,0,-99.91653442382812,3.4150660037994385,-2.241187810897827,0,-0.5766237378120422,-66.10909271240234,-75.02836608886719,0,-0.009749856777489185,0.4055785536766052,2.870457649230957,1],[7,100,0,0,0,0,4.18761682510376,-99.91227722167969,0,0,99.91227722167969,4.18761682510376,0,0.000003128051730527659,-3.409275531768799,-0.12508909404277802,1],[7,100,0,0,0,0,7.511012990767726e-15,-100,0,0,100,7.511012990767726e-15,0,0.000003128051730527659,-3.783393621444702,0.03337418660521507,1],[7,100,0,0,0,0,7.511012990767726e-15,-100,0,0,100,7.511012990767726e-15,0,0.000003128051730527659,-4.010533332824707,0.03341292962431908,1],[7,21.29783821105957,52.32951736450195,-82.51074981689453,0,95.94265747070312,-27.17105484008789,7.532630920410156,0,-18.477251052856445,-80.76728820800781,-55.9931755065918,0,0.22114010155200958,1.2314738035202026,2.5727779865264893,1],[7,21.29783821105957,69.18170928955078,-68.994873046875,0,95.94265747070312,-28.162179946899414,1.377833366394043,0,-18.477251052856445,-66.48896789550781,-72.37271118164062,0,0.21749800443649292,0.557863175868988,2.762897253036499,1],[7,-98.97116088867188,-1.7765125036239624,-14.196950912475586,0,1.8497669696807861,-99.9821548461914,-0.3841700255870819,0,-14.187592506408691,-0.6428280472755432,98.98635864257812,0,0.6436911821365356,-0.2663470208644867,0.054360345005989075,1],[7,-98.52191925048828,7.812491416931152,-15.244531631469727,0,3.9883687496185303,-76.08634948730469,-64.76851654052734,0,-16.659042358398438,-64.41919708251953,74.65013885498047,0,0.6476459503173828,0.20101232826709747,-0.1092083752155304,1],[7,-98.97732543945312,1.7510716915130615,14.157096862792969,0,-1.8243001699447632,-99.98260498046875,-0.38762491941452026,0,14.147847175598145,-0.6419287323951721,98.99205017089844,0,-0.6436074376106262,-0.26403242349624634,0.054123248904943466,1],[7,-98.52481842041016,-7.835526466369629,15.213977813720703,0,-3.9924583435058594,-75.92464447021484,-64.95774841308594,0,16.640939712524414,-64.6069107055664,74.49178314208984,0,-0.6475769281387329,0.20201194286346436,-0.10824719816446304,1],[7,-3.322563409805298,-65.98184204101562,75.06901550292969,0,-99.88249969482422,-0.4593040645122528,-4.824515342712402,0,3.5280990600585938,-75.14110565185547,-65.88904571533203,0,-0.10794160515069962,2.3740110397338867,2.6947505474090576,1],[7,-2.740675449371338,-69.42389678955078,71.92225646972656,0,-99.87456512451172,-1.1144262552261353,-4.881542682647705,0,4.1904778480529785,-71.96582794189453,-69.3062744140625,0,-0.12446483969688416,1.7463010549545288,2.778855800628662,1],[7,-1.4955122470855713,-73.40806579589844,67.88975524902344,0,-99.97823333740234,0.11003851890563965,-2.0833916664123535,0,1.4546726942062378,-67.90613555908203,-73.39373779296875,0,-0.07480242848396301,0.48233526945114136,2.8537044525146484,1],[7,-98.57054138183594,16.84279441833496,0.41003382205963135,0,0.4091626703739166,4.826197147369385,-99.88262939453125,0,-16.842815399169922,-98.45317840576172,-4.826123237609863,0,0.6505444645881653,1.252557635307312,0.06922076642513275,1],[7,-98.57068634033203,-16.838960647583008,-0.5183119177818298,0,-0.37682124972343445,5.27954626083374,-99.85982513427734,0,16.84272003173828,-98.4305648803711,-5.267537593841553,0,-0.6505666971206665,1.2524479627609253,0.07078671455383301,1],[7,-15.190638542175293,-71.30548095703125,68.44539642333984,0,-98.38235473632812,17.560691833496094,-3.5403010845184326,0,-9.49505615234375,-67.87599182128906,-72.81959533691406,0,0.08988939970731735,0.4921325743198395,2.8562355041503906,1],[7,-2.063091516494751,90.21357727050781,-43.09586715698242,0,99.89095306396484,0.05420432984828949,-4.668526649475098,0,-4.1882853507995605,-43.14518737792969,-90.11631774902344,0,0.12511563301086426,1.4621856212615967,3.4108848571777344,1],[7,-2.8875162601470947,65.97959899902344,-75.08898162841797,0,99.88628387451172,-0.946496844291687,-4.672759532928467,0,-3.7937827110290527,-75.13851928710938,-65.87723541259766,0,0.11485330760478973,2.3740997314453125,2.694392681121826,1],[7,-3.0031373500823975,69.42716217041016,-71.90862274169922,0,99.88778686523438,-0.5512104034423828,-4.703826904296875,0,-3.6621012687683105,-71.96920013427734,-69.33270263671875,0,0.11156806349754333,1.7462031841278076,2.7794432640075684,1],[7,-12.621977806091309,78.06205749511719,-61.21275329589844,0,98.8990249633789,14.707194328308105,-1.6373625993728638,0,7.724519729614258,-60.7454833984375,-79.05895233154297,0,-0.06285963207483292,0.5766960382461548,2.8952994346618652,1],[7,21.29783821105957,55.88206100463867,-80.14734649658203,0,95.94265747070312,-27.474021911621094,6.339151859283447,0,-18.477251052856445,-78.24559783935547,-59.46610641479492,0,0.20504406094551086,1.21725332736969,2.624091386795044,1],[7,-1.9431196451187134,-90.21356964111328,43.101463317871094,0,-99.89334869384766,-0.054205067455768585,-4.616890907287598,0,4.188425540924072,-43.145206451416016,-90.11630249023438,0,-0.1251201182603836,1.462216854095459,3.410869836807251,1],[7,100,0,0,0,0,4.18761682510376,-99.91227722167969,0,0,99.91227722167969,4.18761682510376,0,0.000003128051730527659,-3.0784337520599365,-0.12508909404277802,1],[7,100,0,0,0,0,6.1232337864698064e-15,-100,0,0,100,6.1232337864698064e-15,0,0.000003128051730527659,-2.543825387954712,-0.018579719588160515,1],[7,-98.81812286376953,15.329034805297852,1.780910530158053e-8,0,0.37227851152420044,2.399881362915039,-99.97050476074219,0,-15.32451343536377,-98.78897094726562,-2.428584098815918,0,0.6311734914779663,2.3368067741394043,0.03871607407927513,1],[7,-98.8180160522461,-15.329706192016602,-1.4755778821040622e-8,0,-0.3428848385810852,2.210296869277954,-99.97498321533203,0,15.325870513916016,-98.79328918457031,-2.2367348670959473,0,-0.6312127113342285,2.336912155151367,0.03222045674920082,1],[7,100,0,0,0,0,4.187610626220703,-99.91228485107422,0,0,99.91228485107422,4.187610626220703,0,0.000003128051730527659,-2.788947105407715,-0.1250889003276825,1],[7,-4.0438971519470215,-62.1778450012207,78.21485137939453,0,-99.91653442382812,2.9681687355041504,-2.806345224380493,0,-0.5766237378120422,-78.26305389404297,-62.24597930908203,0,-0.00977170281112194,0.8289783596992493,2.767864227294922,1],[7,-1.4955122470855713,-79.94509887695312,60.054508209228516,0,-99.97823333740234,0.3218039572238922,-2.0613276958465576,0,1.4546726942062378,-60.072265625,-79.9325180053711,0,-0.07479120045900345,0.1153421625494957,2.880459785461426,1],[7,-9.835891723632812,-74.83592224121094,65.59603881835938,0,-99.37894439697266,10.833418846130371,-2.5420992374420166,0,-5.203889846801758,-65.43868255615234,-75.43671417236328,0,0.1212582066655159,0.4013168513774872,2.867912530899048,1],[7,-9.835891723632812,-68.19921875,72.47151947021484,0,-99.37894439697266,10.539644241333008,-3.5694708824157715,0,-5.203889846801758,-72.37252807617188,-68.81233215332031,0,0.1212364137172699,0.6187881827354431,2.8215701580047607,1],[7,-15.190638542175293,-77.3259048461914,61.56256103515625,0,-98.38235473632812,17.812725067138672,-1.9022250175476074,0,-9.49505615234375,-60.85565948486328,-78.78091430664062,0,0.08994343876838684,0.15614445507526398,2.8830044269561768,1],[7,-14.455109596252441,83.9646987915039,-52.3543586730957,0,98.52561950683594,17.106945037841797,0.23266197741031647,0,9.151585578918457,-51.548828125,-85.19956970214844,0,-0.14509880542755127,-0.1353033035993576,2.8847947120666504,1],[7,-14.455109596252441,70.79119110107422,-69.13506317138672,0,98.52561950683594,16.75921058654785,-3.4395592212677,0,9.151585578918457,-68.61294555664062,-72.17002868652344,0,-0.1450217068195343,0.5507732033729553,2.846747398376465,1],[7,-14.455109596252441,71.20547485351562,-68.70829772949219,0,98.52561950683594,16.779582977294922,-3.3387606143951416,0,9.151585578918457,-68.17790222167969,-72.58113861083984,0,-0.1449325531721115,0.6116305589675903,2.850006580352783,1],[7,-10.925378799438477,71.9425048828125,-68.59236145019531,0,99.19483184814453,12.337151527404785,-2.860020875930786,0,6.4047722816467285,-68.35254669189453,-72.71112823486328,0,-0.08243510872125626,0.6035351157188416,2.8541195392608643,1],[7,-10.925378799438477,72.9493408203125,-67.52058410644531,0,99.19483184814453,12.3781099319458,-2.6772005558013916,0,6.4047722816467285,-67.26942443847656,-73.7143325805664,0,-0.0824776142835617,0.478608101606369,2.8615128993988037,1],[7,-2.3879592418670654,69.119140625,-72.22770690917969,0,99.97123718261719,1.4908905029296875,-1.8784780502319336,0,-0.22155195474624634,-72.25179290771484,-69.1348648071289,0,0.0037311597261577845,0.7482335567474365,2.824305534362793,1],[7,1.7216200828552246,70.5763931274414,-70.82378387451172,0,99.9272689819336,-3.625065326690674,-1.1833207607269287,0,-3.4025535583496094,-70.75189971923828,-70.58747100830078,0,0.07235729694366455,0.6871061325073242,2.831948757171631,1],[7,1.7216200828552246,73.3102035522461,-67.99007415771484,0,99.9272689819336,-3.5756638050079346,-1.3251322507858276,0,-3.4025535583496094,-67.91780853271484,-73.31844329833984,0,0.07233057171106339,0.4917652904987335,2.8535234928131104,1],[7,-2.3879592418670654,75.74361419677734,-65.24723815917969,0,99.97123718261719,1.664599061012268,-1.7264251708984375,0,-0.22155195474624634,-65.26969909667969,-75.76158142089844,0,0.0036777975037693977,0.38569334149360657,2.874709129333496,1],[7,1.7216200828552246,79.74938201904297,-60.30814743041992,0,99.9272689819336,-3.4250149726867676,-1.676490306854248,0,-3.4025535583496094,-60.23542022705078,-79.7503433227539,0,0.07232346385717392,0.1259004920721054,2.8806052207946777,1],[7,-2.3879592418670654,76.40139770507812,-64.47576141357422,0,99.97123718261719,1.6820213794708252,-1.7094556093215942,0,-0.22155195474624634,-64.49803924560547,-76.41959381103516,0,0.003702369052916765,0.27412647008895874,2.8776371479034424,1],[7,-10.925378799438477,77.40206146240234,-62.36631774902344,0,99.19483184814453,12.532391548156738,-1.82323157787323,0,6.4047722816467285,-62.063358306884766,-78.14805603027344,0,-0.08249933272600174,0.20033279061317444,2.881998062133789,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[11,6],[16,6]],[[[22,".bin",1406203523,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":9216,"length":1680,"count":420,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[1],"indexView":{"offset":409872,"length":28248,"count":14124,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[2],"indexView":{"offset":1075464,"length":55494,"count":27747,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[3],"indexView":{"offset":1436046,"length":26898,"count":13449,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[4],"indexView":{"offset":1588608,"length":7488,"count":3744,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":1653792,"length":3294,"count":1647,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[6],"indexView":{"offset":2295486,"length":59856,"count":29928,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":2404302,"length":3288,"count":1644,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[8],"indexView":{"offset":2471046,"length":5586,"count":2793,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[9],"indexView":{"offset":2609976,"length":11934,"count":5967,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[10],"indexView":{"offset":2724342,"length":7608,"count":3804,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[11],"indexView":{"offset":2833614,"length":9246,"count":4623,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[12],"indexView":{"offset":3370764,"length":41952,"count":20976,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[13],"indexView":{"offset":3447660,"length":2754,"count":1377,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[14],"indexView":{"offset":3512046,"length":4464,"count":2232,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[15],"indexView":{"offset":3543006,"length":1608,"count":804,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[16],"indexView":{"offset":3743430,"length":18360,"count":9180,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[17],"indexView":{"offset":3866814,"length":8478,"count":4239,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[18],"indexView":{"offset":3925308,"length":3432,"count":1716,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[19],"indexView":{"offset":3970980,"length":3636,"count":1818,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":9216,"count":96,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":10896,"length":398976,"count":4156,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":438120,"length":637344,"count":6639,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1130958,"length":305088,"count":3178,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1462944,"length":125664,"count":1309,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1596096,"length":57696,"count":601,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1657086,"length":638400,"count":6650,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2355342,"length":48960,"count":510,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2407590,"length":63456,"count":661,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2476632,"length":133344,"count":1389,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2621910,"length":102432,"count":1067,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2731950,"length":101664,"count":1059,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2842860,"length":527904,"count":5499,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3412716,"length":34944,"count":364,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3450414,"length":61632,"count":642,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3516510,"length":26496,"count":276,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3544614,"length":198816,"count":2071,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3761790,"length":105024,"count":1094,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3875292,"length":50016,"count":521,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3928740,"length":42240,"count":440,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,31,32,33,34,35,36],[0,1,2,3,5,6,9,10,11,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,33,34],[0,10,11,12,13,14,15,16,17,21,22,25,26,27,28,40,41,42,43,44,45,46,47,48,49,50,51],[0,1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,20,22,23,24,25,26,27,28,29,30,31,32,33,34],[0,9,10,11,17,18,22,24,25,26,27,28,29,30,33,42,43,45,46,47,48,50],[0,2,3,4,5,6,7,8,9,10,11,14,15,20,21,23,27,35,36,37,38,39,40,41,42,43,44,45],[0,1,2,3,4,5,6,7,9,10,11,12,13,16,18,19,20,24,25,26,29,30,31,32,33,34,37,38],[0,1,2,3,4,5,6,7,8,12,13,18,19,20,23,25,26,27,28,35,36,37,38,39,45,46,47,49],[0,2,9,10,11,12,13,14,18,19,24,25,26,27,28,29,30,40,41,42,43,44,45,46,47,48,49,50,51],[0,1,2,3,4,5,6,7,8,9,10,11,18,19,20,23,35,36,37,38,39,44,47,49,51]]},"minPosition",8,[1,-0.01710735633969307,-0.004503834992647171,0.0000700416712788865],"maxPosition",8,[1,0.017107293009757996,0.003861670847982168,0.04614057019352913]]],-1],0,0,[],[],[]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[11,6],[30,6]],[[[57,[[58,[59,[-16,-17,-18,-19,-20,-21,-22],[[60,-5,-4],[23,0,false,-7,-6,[[61,"Victory"]]],[37,0.1,-9,-8],[23,0.1,false,-11,-10,[[62,[38,"Fail"]]]],[23,0.1,false,-13,-12,[[63,1,[38,"Fail"]]]],[37,0,-15,-14]],-3,-2,-1]]],[{},"Victory",4,[64,2],"Fail",4,[65,1,false]]],[24,"Idle",[19,0]],[25,"Entry"],[24,"Jump Smack Attack",[19,1]],[66,"Idle",2,[19,2]],[24,"Cast Spell",[19,3]],[25,"Exit"],[25,"Any"]],0,[0,17,7,0,18,6,0,19,2,0,9,1,0,10,2,0,9,5,0,10,1,0,9,1,0,10,5,0,9,4,0,10,1,0,9,3,0,10,4,0,9,1,0,10,3,0,-1,2,0,-2,6,0,-3,7,0,-4,1,0,-5,3,0,-6,4,0,-7,5,22],[0,0,0,0],[13,13,13,13],[14,106,14,107]],[[[39,"Eff"],[124,"Eff",[-3],[-2],[0,"caBIEtyFNPD5ffbDI/aXOX",-1,0],[1,0,0,-1.711],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[122,"smokeing",1,[-4],[0,"302gw1u+VGxar0uAmnoKt7",1,0],[1,0,0,-0.565]],[103,1,false,2,[9,"7f2Iahi4ZIdas+s4IinUro"],[0],[32],[33,3,2,4],[5],[5],[13,15],[5],[5],[76,3,6.283185307179586],[5],[33,3,0.3,0.8],[13,0.12],[5],[5],[[77,[13,16]]],[78,true,[75,1,[79,[[104,[4,4288413951]],[81,0.6696428571428571,[4,4294928384]],[80,1]],[[82,255],[46,144,0.7700892857142857],[46,0,1]]]]],[161,true,1,0,0.1,1.3962634015954636,[13,1]],[83,true,[45,1,[47,[0,1],[[105,1,-1,1,-1,1],[106,-1,1,-1,1]]]],[5],[5],[5]],[84,true,[5],[5],[5],[13,0.3]],[107,[13,10],[13,10],[13,10]],[85,[5],[5],[5],[5]],[86,true,[5],[5],[33,3,-3.141592653589793,3.141592653589793]],[87,true,2,2,[45,1,[47,[0,1],[[48,2,1],[48,2,1]]]],[5]],[88,[13,1],[5],[32],[32],-5],[89,1]],[103,1,false,1,[9,"0cqfwPsdNDY7pdzpMM27gr"],[2],[32],[33,3,3,4],[5],[5],[33,3,8,20],[5],[5],[76,3,6.283185307179586],[5],[33,3,0.5,1],[13,0.12],[5],[5],[[77,[13,10]]],[78,true,[75,1,[79,[[104,[4,4288413951]],[81,0.6339285714285714,[4,4294928384]],[81,1,[4,4278190080]]],[[82,255],[46,144,0.7477678571428571],[46,0,1]]]]],[162,true,0,0.15,0.009773843811168246,[13,1]],[83,true,[45,1,[47,[0,1],[[163,2,1,1,1],[164,2,1,1]]]],[5],[5],[5]],[84,true,[5],[5],[13,0.4],[13,1]],[165,true,[5],[5],[13,15]],[85,[5],[5],[5],[5]],[86,true,[5],[5],[158,3,-3.141592653589793,3.141592653589793,45]],[87,true,2,2,[45,1,[47,[0,1],[[48,2,1],[48,2,1]]]],[5]],[88,[13,1],[5],[32],[32],-6],[89,3]]],0,[0,3,1,0,-1,4,0,-1,2,0,-1,3,0,21,3,0,21,4,0,12,1,6],[0,0,0,0],[-1,22,-1,22],[22,13,22,13]],[[[22,".bin",2190506843,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":4032,"length":84,"count":42,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":6708,"length":54,"count":27,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[2],"indexView":{"offset":55914,"length":3354,"count":1677,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[3],"indexView":{"offset":213156,"length":12270,"count":6135,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[4],"indexView":{"offset":264786,"length":2928,"count":1464,"stride":2}},{"primitiveMode":7,"jointMapIndex":5,"vertexBundelIndices":[5],"indexView":{"offset":282498,"length":1044,"count":522,"stride":2}},{"primitiveMode":7,"jointMapIndex":6,"vertexBundelIndices":[6],"indexView":{"offset":310518,"length":1980,"count":990,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[7],"indexView":{"offset":330738,"length":888,"count":444,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[8],"indexView":{"offset":1269642,"length":75534,"count":37767,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[9],"indexView":{"offset":1502904,"length":11502,"count":5751,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[10],"indexView":{"offset":1661094,"length":13314,"count":6657,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[11],"indexView":{"offset":1695720,"length":1806,"count":903,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[12],"indexView":{"offset":1720662,"length":1638,"count":819,"stride":2}},{"primitiveMode":7,"jointMapIndex":7,"vertexBundelIndices":[13],"indexView":{"offset":1770588,"length":2538,"count":1269,"stride":2}},{"primitiveMode":7,"jointMapIndex":14,"vertexBundelIndices":[14],"indexView":{"offset":1942278,"length":11754,"count":5877,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[15],"indexView":{"offset":2095632,"length":9342,"count":4671,"stride":2}},{"primitiveMode":7,"jointMapIndex":16,"vertexBundelIndices":[16],"indexView":{"offset":2197038,"length":8004,"count":4002,"stride":2}},{"primitiveMode":7,"jointMapIndex":14,"vertexBundelIndices":[17],"indexView":{"offset":2249298,"length":3324,"count":1662,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[18],"indexView":{"offset":2312430,"length":4590,"count":2295,"stride":2}},{"primitiveMode":7,"jointMapIndex":13,"vertexBundelIndices":[19],"indexView":{"offset":2561436,"length":13698,"count":6849,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[20],"indexView":{"offset":3084414,"length":30402,"count":15201,"stride":2}},{"primitiveMode":7,"jointMapIndex":14,"vertexBundelIndices":[21],"indexView":{"offset":3554784,"length":27096,"count":13548,"stride":2}},{"primitiveMode":7,"jointMapIndex":15,"vertexBundelIndices":[22],"indexView":{"offset":3602232,"length":1374,"count":687,"stride":2}},{"primitiveMode":7,"jointMapIndex":3,"vertexBundelIndices":[23],"indexView":{"offset":3617334,"length":1176,"count":588,"stride":2}},{"primitiveMode":7,"jointMapIndex":12,"vertexBundelIndices":[24],"indexView":{"offset":3684366,"length":3738,"count":1869,"stride":2}},{"primitiveMode":7,"jointMapIndex":14,"vertexBundelIndices":[25],"indexView":{"offset":3819528,"length":7500,"count":3750,"stride":2}},{"primitiveMode":7,"jointMapIndex":8,"vertexBundelIndices":[26],"indexView":{"offset":3943092,"length":6480,"count":3240,"stride":2}},{"primitiveMode":7,"jointMapIndex":14,"vertexBundelIndices":[27],"indexView":{"offset":3995364,"length":2952,"count":1476,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[28],"indexView":{"offset":4095084,"length":8538,"count":4269,"stride":2}},{"primitiveMode":7,"jointMapIndex":4,"vertexBundelIndices":[29],"indexView":{"offset":4131270,"length":1650,"count":825,"stride":2}},{"primitiveMode":7,"jointMapIndex":11,"vertexBundelIndices":[30],"indexView":{"offset":4149336,"length":1026,"count":513,"stride":2}},{"primitiveMode":7,"jointMapIndex":10,"vertexBundelIndices":[31],"indexView":{"offset":4166490,"length":1008,"count":504,"stride":2}},{"primitiveMode":7,"jointMapIndex":2,"vertexBundelIndices":[32],"indexView":{"offset":4191210,"length":1692,"count":846,"stride":2}},{"primitiveMode":7,"jointMapIndex":9,"vertexBundelIndices":[33],"indexView":{"offset":4249830,"length":5112,"count":2556,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[34],"indexView":{"offset":4262240,"length":384,"count":96,"stride":4}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[35],"indexView":{"offset":4266464,"length":336,"count":84,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4032,"count":42,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4116,"length":2592,"count":27,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":6762,"length":49152,"count":512,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":59268,"length":153888,"count":1603,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":225426,"length":39360,"count":410,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":267714,"length":14784,"count":154,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":283542,"length":26976,"count":281,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":312498,"length":18240,"count":190,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":331626,"length":938016,"count":9771,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1345176,"length":157728,"count":1643,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1514406,"length":146688,"count":1528,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1674408,"length":21312,"count":222,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1697526,"length":23136,"count":241,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1722300,"length":48288,"count":503,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1773126,"length":169152,"count":1762,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":1954032,"length":141600,"count":1475,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2104974,"length":92064,"count":959,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2205042,"length":44256,"count":461,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2252622,"length":59808,"count":623,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2317020,"length":244416,"count":2546,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":2575134,"length":509280,"count":5305,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3114816,"length":439968,"count":4583,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3581880,"length":20352,"count":212,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3603606,"length":13728,"count":143,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3618510,"length":65856,"count":686,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3688104,"length":131424,"count":1369,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3827028,"length":116064,"count":1209,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3949572,"length":45792,"count":477,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":3998316,"length":96768,"count":1008,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4103622,"length":27648,"count":288,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4132920,"length":16416,"count":171,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4150362,"length":16128,"count":168,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4167498,"length":23712,"count":247,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4192902,"length":56928,"count":593,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4254942,"length":7296,"count":76,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]},{"view":{"offset":4262624,"length":3840,"count":40,"stride":96},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,3,4,5,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],[0,3,4,5,6,7,31,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54],[0,1,2,3,4,5,7,8,17,18,20,21,22,40,41,42,44,45,46,55,56,57,58,59,61,62,63,64],[0,9,10,11,12,13,14,15,16,17,18,19,21,22,24,25,26,28,29,30,33,34,35,36,37,38,39,43],[0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,23,32,33,34,35,36,37,38,39,43,55,60],[0,3,4,5,7,11,12,13,14,33,34,35,39,43,44,47,48,49,50,51,52,53,54],[0,23,24,25,27,28,29,30,33,34,35,36,37,38,39,43,44,47,48,49,50,51,52,53,54],[0,1,2,3,4,5,6,7,8,31,32,33,34,35,36,39,40,41,42,43,44,45,46,57,58,59,60,62,63,64],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,31,32,33,55,56,57,58,59,60,61,62,63,64],[0,1,2,3,4,5,6,7,8,9,10,11,19,23,24,25,26,27,28,29,30,31,32,33,34,35,36,55],[0,15,16,17,18,20,21,22,24,25,26,28,29,30,40,41,42,45,47,48,49,50,52,53,54],[0,2,3,4,5,6,7,10,11,12,13,14,23,27,28,29,31,35,36,37,38],[0,5,6,8,9,10,11,12,13,15,23,32,33,34,35,36,37,39,40,41,42,43,45,48,49,50,52,53,54],[0,5,6,8,9,10,11,12,13,15,17,18,19,20,21,22,23,32,33,34,35,36,37,39,41,43,44,45,46],[0,1,2,3,4,5,6,7,8,9,10,11,12,15,19,23,31,32,33,34,35,36,43,55,56,57,58,59,60,61],[0,3,4,5,7,9,10,11,12,31,33,34,35,36,56,57,58,59,61,62,63,64],[0,1,2,3,4,5,6,10,23,24,25,26,27,28,29,30,31,56,57,58,59,60,61,62,63,64]]},"minPosition",8,[1,-0.023869866505265236,-0.0063956137746572495,-0.00018877994443755597],"maxPosition",8,[1,0.023887334391474724,0.008156758733093739,0.05052230507135391]]],-1],0,0,[],[],[]],[[[41,"Skin-0",355894149,["mixamorig:Hips","mixamorig:Hips/mixamorig:Spine","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:Neck/mixamorig:Head/mixamorig:HeadTop_End","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandThumb1/mixamorig:LeftHandThumb2/mixamorig:LeftHandThumb3/mixamorig:LeftHandThumb4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandIndex1/mixamorig:LeftHandIndex2/mixamorig:LeftHandIndex3/mixamorig:LeftHandIndex4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2/mixamorig:LeftHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandMiddle1/mixamorig:LeftHandMiddle2/mixamorig:LeftHandMiddle3/mixamorig:LeftHandMiddle4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2/mixamorig:LeftHandRing3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandRing1/mixamorig:LeftHandRing2/mixamorig:LeftHandRing3/mixamorig:LeftHandRing4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2/mixamorig:LeftHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:LeftShoulder/mixamorig:LeftArm/mixamorig:LeftForeArm/mixamorig:LeftHand/mixamorig:LeftHandPinky1/mixamorig:LeftHandPinky2/mixamorig:LeftHandPinky3/mixamorig:LeftHandPinky4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandThumb1/mixamorig:RightHandThumb2/mixamorig:RightHandThumb3/mixamorig:RightHandThumb4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandIndex1/mixamorig:RightHandIndex2/mixamorig:RightHandIndex3/mixamorig:RightHandIndex4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2/mixamorig:RightHandMiddle3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandMiddle1/mixamorig:RightHandMiddle2/mixamorig:RightHandMiddle3/mixamorig:RightHandMiddle4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2/mixamorig:RightHandRing3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandRing1/mixamorig:RightHandRing2/mixamorig:RightHandRing3/mixamorig:RightHandRing4","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2/mixamorig:RightHandPinky3","mixamorig:Hips/mixamorig:Spine/mixamorig:Spine1/mixamorig:Spine2/mixamorig:RightShoulder/mixamorig:RightArm/mixamorig:RightForeArm/mixamorig:RightHand/mixamorig:RightHandPinky1/mixamorig:RightHandPinky2/mixamorig:RightHandPinky3/mixamorig:RightHandPinky4","mixamorig:Hips/mixamorig:LeftUpLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase","mixamorig:Hips/mixamorig:LeftUpLeg/mixamorig:LeftLeg/mixamorig:LeftFoot/mixamorig:LeftToeBase/mixamorig:LeftToe_End","mixamorig:Hips/mixamorig:RightUpLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase","mixamorig:Hips/mixamorig:RightUpLeg/mixamorig:RightLeg/mixamorig:RightFoot/mixamorig:RightToeBase/mixamorig:RightToe_End"],[[[7,100,-0.002137149916961789,-0.00038071299786679447,0,-0.0003807121829595417,0.000038071535527706146,-100,0,0.002137150149792433,100,0.00003806340100709349,0,-0.000042311905417591333,-2.993596315383911,0.016354069113731384,1],[7,100,0,0,0,0,1.5798699855804443,-99.98750305175781,0,0,99.98750305175781,1.5798699855804443,0,0.000026082199838128872,-3.203671932220459,-0.030941659584641457,1],[7,100,0,0,0,0,1.5798699855804443,-99.98750305175781,0,0,99.98750305175781,1.5798699855804443,0,0.000026082199838128872,-3.448894739151001,-0.03094175085425377,1],[7,100,0,0,0,0,1.5798699855804443,-99.98750305175781,0,0,99.98750305175781,1.5798699855804443,0,0.000026082199838128872,-3.729149341583252,-0.03094175085425377,1],[7,100,0,0,0,0,-8.667419137964316e-8,-100,0,0,100,-8.667419137964316e-8,0,0.000026082199838128872,-4.044419765472412,0.03295901045203209,1],[7,100,0,0,0,0,-8.667419137964316e-8,-100,0,0,100,-8.667419137964316e-8,0,0.000026082199838128872,-4.3779520988464355,-0.007225759793072939,1],[7,100,0,0,0,0,-8.667419137964316e-8,-100,0,0,100,-8.667419137964316e-8,0,0.000026082199838128872,-4.99531364440918,-0.0816069096326828,1],[7,0.6817264556884766,98.9416732788086,-14.494443893432617,0,99.98699951171875,-0.8864453434944153,-1.3482787609100342,0,-1.4624947309494019,-14.483373641967773,-98.93477630615234,0,0.025898877531290054,0.40930983424186707,3.975963830947876,1],[7,0.00004906139292870648,100,-0.00046379296691156924,0,99.06739807128906,0.00001458795668440871,13.625,0,13.625,-0.00046615267638117075,-99.06739807128906,0,-0.5647144913673401,-0.5325571894645691,3.899792432785034,1],[7,-0.000010545106306381058,100,-0.00047474793973378837,0,99.04989624023438,0.00007573270704597235,13.752099990844727,0,13.752099990844727,-0.0004687870678026229,-99.04989624023438,0,-0.5697171092033386,-1.0792099237442017,3.899064779281616,1],[7,-8.677739143371582,99.60900115966797,-1.656488299369812,0,99.60569763183594,8.644221305847168,-1.9977563619613647,0,-1.846755862236023,-1.8233163356781006,-99.96630096435547,0,0.19893844425678253,-1.7001501321792603,3.9690208435058594,1],[7,36.38248062133789,81.86803436279297,-44.42902755737305,0,92.96611022949219,-34.884307861328125,11.84867000579834,0,-5.798487663269043,-45.61473846435547,-88.80133819580078,0,-0.45556390285491943,0.15959008038043976,4.33060359954834,1],[7,42.93064880371094,78.65924835205078,-44.38114547729492,0,89.82813262939453,-42.28801345825195,11.942870140075684,0,-9.373729705810547,-44.99391174316406,-88.81262969970703,0,-0.4414314925670624,0.03676697984337807,4.330137729644775,1],[7,78.2737045288086,43.626609802246094,-44.38405990600586,0,53.41522216796875,-83.69180297851562,11.937124252319336,0,-31.93805694580078,-33.05147933959961,-88.81192779541016,0,-0.3936288356781006,0.19883298873901367,4.330166339874268,1],[7,78.2737045288086,43.626609802246094,-44.38405990600586,0,53.41522216796875,-83.69180297851562,11.937124252319336,0,-31.93805694580078,-33.05147933959961,-88.81192779541016,0,-0.41295328736305237,0.166262686252594,4.330166339874268,1],[7,-0.06904806941747665,100,-0.0003730779862962663,0,99.98410034179688,0.0690305158495903,-1.7805299758911133,0,-1.7805297374725342,-0.001602441887371242,-99.98410034179688,0,0.09326814115047455,-2.1685588359832764,3.925187587738037,1],[7,0.017670677974820137,100,-0.00039557594573125243,0,99.98410034179688,-0.017674922943115234,-1.782539963722229,0,-1.7825400829315186,-0.00008052617340581492,-99.98410034179688,0,0.09145352244377136,-2.24257493019104,3.9251863956451416,1],[7,0.06295529752969742,100,-0.0003296408976893872,0,99.98419952392578,-0.0629512146115303,-1.777459979057312,0,-1.7774602174758911,0.0007894164300523698,-99.98419952392578,0,0.09019246697425842,-2.315781831741333,3.92518949508667,1],[7,0.0629553273320198,100,-0.00033761700615286827,0,99.98419952392578,-0.06295137852430344,-1.777459979057312,0,-1.7774602174758911,0.0007814420969225466,-99.98419952392578,0,0.09015439450740814,-2.3760643005371094,3.925189733505249,1],[7,-0.06489577144384384,100,-0.0005098771071061492,0,99.97799682617188,0.06487081944942474,-2.0970399379730225,0,-2.0970396995544434,-0.0018706555711105466,-99.97799682617188,0,0.055945686995983124,-2.174434185028076,3.940091133117676,1],[7,0.019283859059214592,100,-0.0004776738060172647,0,99.97799682617188,-0.019289642572402954,-2.0954699516296387,0,-2.0954701900482178,-0.0000734813220333308,-99.97799682617188,0,0.05403772369027138,-2.25325608253479,3.940091371536255,1],[7,0.06399927288293839,100,-0.00048695612349547446,0,99.97799682617188,-0.06399547308683395,-2.094480037689209,0,-2.094478130340576,0.0008536031818948686,-99.97810363769531,0,0.052944350987672806,-2.3253369331359863,3.940092086791992,1],[7,0.06399919092655182,100,-0.0004848682146985084,0,99.97799682617188,-0.0639953538775444,-2.094480037689209,0,-2.094478130340576,0.0008556889952160418,-99.97810363769531,0,0.05290796235203743,-2.3814706802368164,3.940092086791992,1],[7,0.0764327123761177,100,-0.000386828207410872,0,99.98919677734375,-0.07643023133277893,-1.464859962463379,0,-1.4648587703704834,0.0007328460924327374,-99.98930358886719,0,-0.04621047526597977,-2.1879849433898926,3.9341342449188232,1],[7,0.060446809977293015,100,-0.00031810670043341815,0,99.98930358886719,-0.060444995760917664,-1.4628499746322632,0,-1.4628502130508423,0.0005661735194735229,-99.98930358886719,0,-0.04597587138414383,-2.246742010116577,3.9341318607330322,1],[7,-0.19084030389785767,99.99980163574219,-0.0003677445638459176,0,99.98899841308594,0.19081424176692963,-1.4703900814056396,0,-1.4703865051269531,-0.003173800418153405,-99.98919677734375,0,-0.03991062194108963,-2.311201810836792,3.934136390686035,1],[7,-0.19084033370018005,99.99980163574219,-0.00037238930235616863,0,99.98899841308594,0.19081421196460724,-1.4703900814056396,0,-1.4703865051269531,-0.0031784451566636562,-99.98919677734375,0,-0.0398261621594429,-2.355257272720337,3.9341366291046143,1],[7,0.06758851557970047,100,-0.0003979839093517512,0,99.96530151367188,-0.0675756186246872,-2.6317999362945557,0,-2.6317975521087646,0.0013809491647407413,-99.96540069580078,0,-0.037925172597169876,-2.1419665813446045,3.9315781593322754,1],[7,0.19707120954990387,99.99980163574219,-0.000390359025914222,0,99.96479797363281,-0.19701246917247772,-2.646480083465576,0,-2.6464755535125732,0.004825226031243801,-99.96499633789062,0,-0.04024329036474228,-2.203902006149292,3.9315834045410156,1],[7,-0.35072576999664307,99.99939727783203,-0.0003837284748442471,0,99.96369934082031,0.3505905568599701,-2.6704399585723877,0,-2.6704225540161133,-0.00974951684474945,-99.96430206298828,0,-0.027033664286136627,-2.259347915649414,3.931591749191284,1],[7,-0.3507258892059326,99.99939727783203,-0.0003937085857614875,0,99.96369934082031,0.35059043765068054,-2.6704399585723877,0,-2.6704225540161133,-0.00975949689745903,-99.96430206298828,0,-0.02688291296362877,-2.302424430847168,3.9315919876098633,1],[7,-1.1567193269729614,-98.94160461425781,14.464213371276855,0,-99.97740173339844,0.8864374160766602,-1.9316800832748413,0,1.783018708229065,-14.483277320861816,-98.92959594726562,0,-0.038610655814409256,0.4086688756942749,3.9759554862976074,1],[7,0.00004771369640366174,-100,0.0004779609153047204,0,-99.91960144042969,-0.000028514317818917334,4.008910179138184,0,-4.008910179138184,-0.0004794895357917994,-99.91960144042969,0,0.19575175642967224,-0.5326088070869446,3.935683250427246,1],[7,0.00010526889673201367,-100,0.0005192413809709251,0,-99.91699981689453,-0.00008403669198742136,4.072269916534424,0,-4.072269916534424,-0.0005230977549217641,-99.91699981689453,0,0.19824816286563873,-1.0784441232681274,3.935558795928955,1],[7,-7.440521717071533,-99.71019744873047,1.5839552879333496,0,-99.64820098876953,7.495441913604736,3.7486658096313477,0,-3.8565258979797363,-1.299461841583252,-99.91719818115234,0,0.05751936882734299,-1.7222250699996948,3.9638030529022217,1],[7,38.607574462890625,-82.42523956298828,41.41905212402344,0,-92.24641418457031,-34.3792724609375,17.5689640045166,0,-0.24169062077999115,-44.99053192138672,-89.30731964111328,0,0.7381647825241089,0.12855452299118042,4.291068077087402,1],[7,50.245643615722656,-75.81188201904297,41.568389892578125,0,-86.20063018798828,-47.648292541503906,17.294294357299805,0,6.695502281188965,-44.52183532714844,-89.29150390625,0,0.70294189453125,0.07716656476259232,4.293297290802002,1],[7,72.57662200927734,-47.98400115966797,49.29680633544922,0,-55.90106964111328,-82.90049743652344,1.606803059577942,0,40.09630584716797,-28.72359848022461,-86.98989868164062,0,-0.03975237160921097,-0.051963016390800476,4.35040283203125,1],[7,72.57661437988281,-47.9839973449707,49.29681396484375,0,-55.90106964111328,-82.90049743652344,1.606803059577942,0,40.0963134765625,-28.723602294921875,-86.9898910522461,0,-0.02422337606549263,-0.07947894930839539,4.35040283203125,1],[7,0.03863705322146416,-100,0.0004656464734580368,0,-99.92849731445312,-0.03859184309840202,3.7802300453186035,0,-3.7802298069000244,-0.001925883931107819,-99.92849731445312,0,0.1307978481054306,-2.1641366481781006,3.926299810409546,1],[7,-0.3164758086204529,-99.99949645996094,0.0003746485454030335,0,-99.92720031738281,0.3162613809108734,3.801409959793091,0,-3.8013923168182373,0.011656172573566437,-99.92769622802734,0,0.12369631230831146,-2.24269700050354,3.9262702465057373,1],[7,0.3044794797897339,-99.99949645996094,0.00031578788184560835,0,-99.92729949951172,-0.30424752831459045,3.799839973449707,0,-3.7998199462890625,-0.011885286308825016,-99.92780303955078,0,0.1377720981836319,-2.312300682067871,3.9262709617614746,1],[7,0.3044794797897339,-99.99949645996094,0.00031578788184560835,0,-99.92729949951172,-0.30424752831459045,3.799839973449707,0,-3.7998199462890625,-0.011885286308825016,-99.92780303955078,0,0.13796570897102356,-2.3760647773742676,3.9262709617614746,1],[7,0.029477201402187347,-100,0.0005976600223220885,0,-99.93199920654297,-0.02943509630858898,3.6880500316619873,0,-3.688049793243408,-0.0016843865159898996,-99.93199920654297,0,0.18375082314014435,-2.1703832149505615,3.936293363571167,1],[7,-0.045577049255371094,-100,0.0006561810150742531,0,-99.93190002441406,0.0455702543258667,3.6886401176452637,0,-3.6886403560638428,0.0010254399385303259,-99.93190002441406,0,0.18210886418819427,-2.249105453491211,3.936293601989746,1],[7,0.01580977439880371,-100,0.0006015180260874331,0,-99.93199920654297,-0.015776824206113815,3.6883199214935303,0,-3.6883199214935303,-0.0011842231033369899,-99.93199920654297,0,0.18348856270313263,-2.321077585220337,3.936292886734009,1],[7,0.0158098042011261,-100,0.0005977171822451055,0,-99.93199920654297,-0.015776995569467545,3.6883199214935303,0,-3.6883199214935303,-0.0011804259847849607,-99.93199920654297,0,0.18349847197532654,-2.3852055072784424,3.936292886734009,1],[7,0.000098109056125395,-100,0.0005799824721179903,0,-99.92310333251953,-0.00007529355207225308,3.9208199977874756,0,-3.9208199977874756,-0.0005833831964991987,-99.92310333251953,0,0.26007145643234253,-2.1942379474639893,3.933424711227417,1],[7,-0.013694418594241142,-100,0.0005864225095137954,0,-99.92310333251953,0.013706881552934647,3.921030044555664,0,-3.921030044555664,-0.00004900929343421012,-99.92310333251953,0,0.2597685158252716,-2.2555408477783203,3.933424472808838,1],[7,0.016811279579997063,-100,0.0005133425001986325,0,-99.92310333251953,-0.016778219491243362,3.9211299419403076,0,-3.9211299419403076,-0.0011721396585926414,-99.92310333251953,0,0.2604702413082123,-2.3134124279022217,3.933422327041626,1],[7,0.016811279579997063,-100,0.0005133425001986325,0,-99.92310333251953,-0.016778219491243362,3.9211299419403076,0,-3.9211299419403076,-0.0011721396585926414,-99.92310333251953,0,0.2604786157608032,-2.3613221645355225,3.933422327041626,1],[7,0.00010222205310128629,-100,0.0004708017804659903,0,-99.7394027709961,-0.00006799084803787991,7.214260101318359,0,-7.214260101318359,-0.0004769497609231621,-99.7394027709961,0,0.429510235786438,-2.171276807785034,3.9060938358306885,1],[7,-0.004338330123573542,-100,0.00040566764073446393,0,-99.739501953125,0.0043562897481024265,7.213860034942627,0,-7.213860034942627,-0.0000916497374419123,-99.739501953125,0,0.4293961226940155,-2.222551107406616,3.9060940742492676,1],[7,0.005877913441509008,-100,0.0003577822062652558,0,-99.739501953125,-0.005836786702275276,7.2139201164245605,0,-7.2139201164245605,-0.000780877482611686,-99.739501953125,0,0.4296281337738037,-2.2673468589782715,3.906092643737793,1],[7,0.0058779167011380196,-100,0.0003602256765589118,0,-99.739501953125,-0.005836613476276398,7.2139201164245605,0,-7.2139201164245605,-0.0007833148119971156,-99.739501953125,0,0.4296301007270813,-2.302025318145752,3.906092643737793,1],[7,-99.77999877929688,-6.629720211029053,0.018107101321220398,0,0.1667214184999466,-2.7822396755218506,-99.96109771728516,0,6.62764835357666,-99.74120330810547,2.787169933319092,0,0.3068826496601105,2.9026424884796143,-0.07381915301084518,1],[7,-99.7863998413086,6.499859809875488,0.6475250124931335,0,-0.03625715523958206,9.361759185791016,-99.56079864501953,0,-6.531932830810547,-99.34839630126953,-9.339409828186035,0,0.5170084238052368,1.5624475479125977,0.11735589802265167,1],[7,-99.10430145263672,4.7151570320129395,-12.493897438049316,0,3.6746621131896973,-80.318115234375,-59.46003723144531,0,-12.838494300842285,-59.38658142089844,79.42547607421875,0,0.5287570357322693,0.22683526575565338,-0.11660754680633545,1],[7,-97.40109252929688,-8.724329948425293,-20.90250015258789,0,9.488842010498047,-99.51270294189453,-2.6811277866363525,0,-20.566722869873047,-4.594852447509766,97.75430297851562,0,0.537644624710083,-0.22993385791778564,0.0809951201081276,1],[7,-97.40109252929688,-8.724329948425293,-20.90250015258789,0,9.488842010498047,-99.51270294189453,-2.6811277866363525,0,-20.566722869873047,-4.594852447509766,97.75430297851562,0,0.537644624710083,-0.41301393508911133,0.0809951052069664,1],[7,-99.77999877929688,6.629859924316406,0.011802899651229382,0,-0.18528445065021515,-2.6105802059173584,-99.9656982421875,0,-6.627284049987793,-99.74579620361328,2.6171200275421143,0,-0.30689865350723267,2.9032106399536133,-0.05101478844881058,1],[7,-99.78690338134766,-6.505990028381348,-0.48827099800109863,0,-0.023877322673797607,7.848011016845703,-99.69159698486328,0,6.524243354797363,-99.47900390625,-7.832849979400635,0,-0.51693195104599,1.5624186992645264,0.11381994187831879,1],[7,-99.0916976928711,-4.745855808258057,12.581896781921387,0,-3.7655301094055176,-80.02892303466797,-59.843048095703125,0,12.909217834472656,-59.77327346801758,79.12336730957031,0,-0.5288182497024536,0.22754965722560883,-0.11492191255092621,1],[7,-97.43621063232422,8.707551002502441,20.745399475097656,0,-9.466275215148926,-99.51460266113281,-2.6911773681640625,0,20.410356521606445,-4.585995674133301,97.7874984741211,0,-0.5373795032501221,-0.22632339596748352,0.08024271577596664,1],[7,-97.43621063232422,8.707551002502441,20.745399475097656,0,-9.466275215148926,-99.51460266113281,-2.6911773681640625,0,20.410356521606445,-4.585995674133301,97.7874984741211,0,-0.5373795032501221,-0.4097566306591034,0.08024272322654724,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[26,"T_CHR_Kisame_SC_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true}]]],0,0,[0],[6],[6]],[[[26,"T_CHR_KisameEye_BC_png1",[{}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_VERTEX_COLOR":true,"HAS_SECOND_UV":true}]]],0,0,[0],[6],[6]],[[[29],[50,"dr5_Idle (15)",[-3,-4],[[42,-2,[9,"9fNk+mxD1XY4S4KXztmcSm"],[38,39],40]],[0,"7cmiDpNgFdRp2JHBmSvbvO",-1,0]],[27,"mixamorig:LeftHand",[-5,-6,-7,-8,-9],[0,"0fMX6YVNZXEYoDAigiBAmV",1,0],[1,-9.849059345867772e-10,0.6972838044166565,7.406691704403556e-9],[3,0.011673394403683151,-0.07845213883654853,-0.0426457107688575,0.9959369142310601],[1,0.9524911414757803,-8.96662185374047,-4.978187242196617]],[27,"mixamorig:RightHand",[-10,-11,-12,-13,-14],[0,"1dOxHG4YdfjapLbTcwzjdL",1,0],[1,7.485261299677859e-10,0.6972748041152954,1.8509588528559107e-8],[3,0.007971842836410883,0.0013209685089404391,0.037219580557749446,0.9992744405753082],[1,0.9097690880993358,0.11758773886756317,4.267105439876917]],[2,"mixamorig:Hips",1,[-15,-16,-17],[0,"55nEzwAERVyoP48MWAOYj+",1,0],[1,-0.000021603331333608367,2.993596076965332,-0.016355205327272415],[3,-1.903374595600952e-7,-0.0000019035638841857475,0.000010685732376539561,0.9999999999410778],[1,-0.0000218087353318178,-0.00021813212016501862,0.0012244947739038523]],[51,"mixamorig:Spine2",[-18,-19,-20],[0,"5a+vqHdN5UbZxydQwt5tiJ",1,0],[1,-1.734723437202716e-20,0.28025439381599426,-1.2993677314665497e-11]],[97,"SK_CHR_Kisame",1,[[43,-21,[9,"16LbTcbhZSi5dTD4Ixcaby"],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],[21],1,36,37]],[0,"db250w4cFQJr6oWzeS/6lb",1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,100,100,100],[1,-90.00000000000003,0,0]],[2,"mixamorig:Spine",4,[-22],[0,"f4VF0DYkxbBrXDryR/ZY6G",1,0],[1,8.67361718601358e-21,0.21016480028629303,-0.003320744726806879],[3,-0.007899402422763203,0.0000019879104817675748,-0.000010670361622243397,0.9999687991750317],[1,-0.9052142512008908,0.000218131790908134,-0.001224494689656658]],[34,"mixamorig:Spine1",7,[5],[0,"6bNRki5rdeGYydtWYJAeCB",1,0],[1,-8.67361718601358e-21,0.24522285163402557,-2.3847687713463017e-11]],[2,"mixamorig:Neck",5,[-23],[0,"aeD5xDMqpTyJHzL6+qngUy",1,0],[1,-8.67361718601358e-21,0.3152865469455719,7.64433671918141e-9],[3,0.007899605438874616,-4.0835426703936876e-14,-2.2770340179331356e-13,0.999968797630161],[1,0.9052375181370746,-4.4731256828462805e-12,-2.612903902296909e-11]],[53,"mixamorig:Head",9,[[6,"mixamorig:HeadTop_End",-24,[0,"0fNJT04wFWUr6LInp71uUq",1,0],[1,-3.0357660958841095e-20,0.6173614263534546,0.07438115775585175]]],[0,"e8h33RzOxYAYpCP4swkxcq",1,0],[1,0,0.3335324227809906,0.04018476605415344]],[2,"mixamorig:LeftShoulder",5,[-25],[0,"7ft77dqMpf2YtH2rlhBGui",1,0],[1,0.17116546630859375,0.26411959528923035,0.0008108345209620893],[3,0.5371034706700203,0.4610797733081099,-0.5329135025879602,0.46360382138178347],[1,98.33461420842988,89.60939517254315,0.06724351498066625]],[2,"mixamorig:LeftArm",11,[-26],[0,"b8v97rOOdXr4r22M3BGJdB",1,0],[1,5.590980803327206e-12,0.36530232429504395,-5.719698492612224e-9],[3,-0.07219760651884276,0.07513107137662518,-0.008881724177420284,0.9945169393742809],[1,-8.18250896337901,8.523557369217997,-1.6339887076730966]],[2,"mixamorig:LeftForeArm",12,[2],[0,"ce2WVf7ehTcKj3gYui1F+q",1,0],[1,3.6509344436552738e-9,0.5466528534889221,-1.662582072015084e-8],[3,5.484085570955389e-8,0.0006415397919899259,-3.010427381668762e-7,0.9999997942132797],[1,0.000006306429031288201,0.07351504998615464,-0.00003449291797306221]],[2,"mixamorig:LeftHandThumb1",2,[-27],[0,"dcmgQcLVlbqZxzA/QAW+uX",1,0],[1,-0.07673896104097366,0.1774309277534485,0.04654398933053017],[3,0.22866249729916335,0.03688271075287521,0.22559406500067508,0.9462877183039529],[1,27.668799253099856,-2.133878351372333,26.347942301795285]],[2,"mixamorig:LeftHandThumb2",14,[-28],[0,"3eInEdI/pXTqkxNUdV/rt1",1,0],[1,-0.017180684953927994,0.15814068913459778,-7.275506863635428e-9],[3,-0.000036011042926625977,0.0005302281990906397,0.04046526222271365,0.9991808045166345],[1,-0.006603462813931648,0.06107691485516399,4.63824102522944]],[4,"mixamorig:LeftHandThumb3",15,[[6,"mixamorig:LeftHandThumb4",-29,[0,"65WAF/1yddlL8fgqnwgIlQ",1,0],[1,0.019324444234371185,0.03257029503583908,-6.14723494329894e-10]]],[0,"acrxgzPNdYgZ7zqfwzDGLB",1,0],[1,-0.0021437639370560646,0.07861201465129852,-5.490950805153716e-9],[3,-0.000008167329625102043,-0.00003121394509634844,0.27767672796767895,0.9606745722169124],[1,0.0001112652775137006,-0.003755434476168978,32.24318679436156]],[2,"mixamorig:LeftHandIndex1",2,[-30],[0,"fciLHf2RVXObq1QTJFYRVz",1,0],[1,-0.08353843539953232,0.3865307569503784,0.00866533163934946],[3,-0.00832074022498849,0.0007240643435121518,0.04308018357782647,0.9990367054297032],[1,-0.959748405672788,0.12442990840633102,4.9372877090074025]],[2,"mixamorig:LeftHandIndex2",17,[-31],[0,"e7M40SLL1Rx5xHNU2gd4CO",1,0],[1,-0.00005120712739881128,0.07393703609704971,-1.423983375659077e-9],[3,1.0379716547601678e-7,-0.000010045028173271378,0.0004335939411188314,0.999999905947686],[1,0.000012393381891762997,-0.0011510809207553074,0.049686207131985766]],[4,"mixamorig:LeftHandIndex3",18,[[6,"mixamorig:LeftHandIndex4",-32,[0,"3bp4vriSpVS41R8GRNFDyb",1,0],[1,0.000038064481486799195,0.060282815247774124,5.173712125383645e-9]]],[0,"22GggdzjpUk4vbAbgfU24y",1,0],[1,0.000013142318493919447,0.07316321134567261,-6.177282574348908e-10],[3,-3.1603001705744023e-7,0.00002537907064444283,0.00022642318211925962,0.9999999740441725],[1,-0.00003687286526766472,0.0029082356955143305,0.025946184732965897]],[2,"mixamorig:LeftHandMiddle1",2,[-33],[0,"3arNR3fLxYD7c/cEogQiNB",1,0],[1,-0.03453516960144043,0.396421879529953,-0.006591023411601782],[3,-0.008250783226634886,-0.0008570211969691591,0.0431140476493265,0.999035719574684],[1,-0.9438767373740204,-0.057563718676028,4.94268034183873]],[2,"mixamorig:LeftHandMiddle2",20,[-34],[0,"9bRQl5XyBfu4hz+JRWhHRx",1,0],[1,-0.000050575305067468435,0.07877437770366669,8.234530834982934e-10],[3,-1.7678734762944587e-7,0.000007841380238404307,0.00042089821597761416,0.9999999113915827],[1,-0.000020636543909293273,0.0008985647519221781,0.048231384023943585]],[4,"mixamorig:LeftHandMiddle3",21,[[6,"mixamorig:LeftHandMiddle4",-35,[0,"9czFwauHVfjIlzq1KGtfxM",1,0],[1,0.0000363943945558276,0.05613359808921814,-9.983870397078931e-10]]],[0,"3dRv3kTDFRD5nELrM4k4tr",1,0],[1,0.000014180594916979317,0.07205725461244583,1.3250474051318406e-9],[3,6.498379982606313e-8,0.0000049919998334636255,0.00022357700240985295,0.9999999749941995],[1,0.0000073187002572018415,0.0005720394215814355,0.02562003751883916]],[2,"mixamorig:LeftHandRing1",2,[-36],[0,"57aRxrjFFXTatsdio2FHTL",1,0],[1,0.03819255530834198,0.41644883155822754,-0.0009914840338751674],[3,-0.008388093863885868,0.002307147538723077,0.04379368300718819,0.9990027178542765],[1,-0.9756098999629963,0.30739008177196975,5.017574916236115]],[2,"mixamorig:LeftHandRing2",23,[-37],[0,"6eN9uAPPZbmZhCz0R3b909",1,0],[1,0.00004545060437521897,0.0587470680475235,-2.728957504416485e-9],[3,-3.256608909742247e-7,0.000010060243734283512,-0.00007992985748825304,0.9999999967549518],[1,-0.00003722584490567148,0.0011528160419402046,-0.009159287367034944]],[4,"mixamorig:LeftHandRing3",24,[[6,"mixamorig:LeftHandRing4",-38,[0,"b10Mu9OThdkKB3CEq179GT",1,0],[1,-0.00008445425919489935,0.04405561834573746,4.68592109559296e-10]]],[0,"c2bm17RclcE5gaaO3395zX",1,0],[1,0.00003900439332937822,0.06435392051935196,-2.4870836501378335e-9],[3,1.5448936118094532e-8,-0.00003771636272269239,-0.0012564363233167168,0.9999992099723085],[1,-0.0000036599839256417136,-0.004321984816164695,-0.14397703495147757]],[2,"mixamorig:LeftHandPinky1",2,[-39],[0,"26CR8Q1OJY46WsRC0hTtKH",1,0],[1,0.07988104969263077,0.3739359676837921,0.0028185120318084955],[3,-0.008136611303864972,-0.0035235506393901817,0.043797741886558904,0.9990010700459834],[1,-0.9173341301049935,-0.36392975197326394,5.023557201435919]],[2,"mixamorig:LeftHandPinky2",26,[-40],[0,"07rthTPm5UULxO/Pz4kStV",1,0],[1,0.00004166267899563536,0.06198485940694809,2.8599953516561527e-9],[3,-2.95542229535687e-8,-0.00007342182117213097,0.0006474111747741885,0.9999997877339806],[1,0.0000020603454472092254,-0.008413524059332236,0.07418786107955794]],[4,"mixamorig:LeftHandPinky3",27,[[6,"mixamorig:LeftHandPinky4",-41,[0,"86UExwfEpQkY/ARRY4ocEl",1,0],[1,-0.00015075373812578619,0.04307692497968674,9.209657342301725e-11]]],[0,"68jL5OMGFSNLhavBCtgxFW",1,0],[1,0.00010909179400186986,0.05526174604892731,4.355827698532266e-9],[3,6.333350890693217e-8,-0.00011983235853259828,-0.0027389831290185493,0.9999962417987484],[1,-0.000030354102133921554,-0.01373191146696331,-0.31386473795461134]],[2,"mixamorig:RightShoulder",5,[-42],[0,"21eSBTo6xRgLBiJW/ooVuO",1,0],[1,-0.17116546630859375,0.26417073607444763,-0.0024269577115774155],[3,0.5313714668765822,-0.464544915653266,0.5384994074322127,0.4602833624250228],[1,98.31844769703184,-90.66276679769125,0.11647147435409254]],[2,"mixamorig:RightArm",29,[-43],[0,"e0WJ+IUldRMZjvKPVqG6b3",1,0],[1,-2.827223732904116e-10,0.36530235409736633,3.4077425326017874e-9],[3,-0.07264973213181554,-0.02930456209608185,-0.003666011844358094,0.996920167023764],[1,-8.341188176171121,-3.3802091161822356,-0.17483863515402834]],[2,"mixamorig:RightForeArm",30,[3],[0,"abZYpthC5ZxrgNwteutAIU",1,0],[1,-5.331559638221961e-10,0.5458370447158813,8.238339788135818e-9],[3,2.0661971882035468e-7,-0.00031707834864806305,-2.861951911086787e-7,0.9999999497305968],[1,0.000023666475755123333,-0.03633450290708798,-0.00003280305891097328]],[2,"mixamorig:RightHandThumb1",3,[-44],[0,"26wJwWr1VZe6iNT/xTTn66",1,0],[1,0.08165786415338516,0.1757209450006485,0.04310141131281853],[3,0.21398807751196136,-0.03832635972847937,-0.23073371909626514,0.9484208684464424],[1,25.83133324765697,1.6754140970561167,-27.00499122619699]],[2,"mixamorig:RightHandThumb2",32,[-45],[0,"659GJ0EyhUq4bzobg8gmd4",1,0],[1,0.018193544819951057,0.15775690972805023,7.4042891817782674e-9],[3,0.00006383852486586546,0.0015641283330820738,-0.07416626107187238,0.997244661628138],[1,0.020817474565888255,0.1812791910778982,-8.50661619536191]],[4,"mixamorig:RightHandThumb3",33,[[6,"mixamorig:RightHandThumb4",-46,[0,"fdYjhDMXharp4FVJm3RF8b",1,0],[1,-0.015529224649071693,0.02751575969159603,2.0979371018192694e-10]]],[0,"f4NSCgvkVRTqZSN9uFACqU",1,0],[1,-0.002664322964847088,0.07914489507675171,-3.904573109281273e-9],[3,-0.023840404849097507,0.0849102206932395,-0.23685188394925993,0.9675345340545436],[1,-0.3819296479628746,9.937183754615493,-27.54036130330486]],[2,"mixamorig:RightHandIndex1",3,[-47],[0,"44ifATvOpWzqKIBhdtL4MO",1,0],[1,0.08553658425807953,0.3832702934741974,0.0036858462262898684],[3,-0.00791774872868765,0.00013776823409117727,-0.03742371482773481,0.9992681100903178],[1,-0.9086354292764337,-0.018230347030441987,-4.289433887848011]],[2,"mixamorig:RightHandIndex2",35,[-48],[0,"93dzlbj4dUO7w+HtlaFflv",1,0],[1,-0.000029792741770506836,0.07810370624065399,-1.6518811318810833e-10],[3,-5.126059504088422e-7,-0.00010593948099204698,0.0017755646745053401,0.9999984180720739],[1,-0.00003718550928251245,-0.012139723422775207,0.20346483619282785]],[4,"mixamorig:RightHandIndex3",36,[[6,"mixamorig:RightHandIndex4",-49,[0,"7fhX3toJFWnYAzkXqox8OT",1,0],[1,-0.0001936146873049438,0.06376402080059052,1.4015086313712288e-10]]],[0,"1c7pe91JdemocjsZMX4O8x",1,0],[1,0.00022340926807373762,0.07041261345148087,3.381634972043912e-9],[3,-3.07660715403051e-7,0.0000078513304015947,-0.0031047761692268526,0.999995180139985],[1,-0.00003246242166140602,0.0008995997385213406,-0.35578171352735266]],[2,"mixamorig:RightHandMiddle1",3,[-50],[0,"10AXvxtdVZ7YmeFVVrG9C3",1,0],[1,0.029370302334427834,0.39357757568359375,-0.006249678786844015],[3,-0.007899982797006716,0.0005990450110292451,-0.03738160031545041,0.9992696569869105],[1,-0.9046102430489054,0.034852300206234185,-4.285023036442811]],[2,"mixamorig:RightHandMiddle2",38,[-51],[0,"c23abHyiBd9Yc5QNriBEx+",1,0],[1,-0.000022651285689789802,0.07858701795339584,2.4864790226786226e-9],[3,3.1229930303812053e-7,-0.000002967841250858601,0.0003752708394477133,0.9999999295814433],[1,0.000035914497306535845,-0.00034010305749013686,0.04300287145230599]],[4,"mixamorig:RightHandMiddle3",39,[[6,"mixamorig:RightHandMiddle4",-52,[0,"1cZi3SokdRTpOTecSzwSJE",1,0],[1,-0.000009905175829771906,0.06412772834300995,1.8569500381815374e-9]]],[0,"401rVWIh5RSJhSp2dj7LdP",1,0],[1,0.00003255657429690473,0.0720822736620903,-1.7539707464209187e-9],[3,-2.7563712368468213e-7,0.0000015998773705967995,-0.0003069341221072586,0.9999999528944034],[1,-0.000031529421199152605,0.00018332277332751024,-0.035172060173336336]],[2,"mixamorig:RightHandRing1",3,[-53],[0,"86enURvExaC58pk2JhtGDB",1,0],[1,-0.03646187111735344,0.42239001393318176,-0.004312262404710054],[3,-0.007943330415718366,-0.0005636385235283347,-0.03722557836963274,0.9992751583665872],[1,-0.9145558067368708,-0.09869906842739695,-4.266072681552113]],[2,"mixamorig:RightHandRing2",41,[-54],[0,"2fUquiom9ZnqIozWtYGg9+",1,0],[1,4.1395759353690664e-7,0.06126736104488373,-8.974990195476096e-10],[3,3.451966881900635e-8,-0.0000010892850897574134,0.00006896257384109864,0.999999997621488],[1,0.000003964270802183753,-0.0001248231503424195,0.007902528852858814]],[4,"mixamorig:RightHandRing3",42,[[6,"mixamorig:RightHandRing4",-55,[0,"5bKhTQpcRU5aItR95Gd2Zq",1,0],[1,-0.000008352438271685969,0.047909706830978394,-7.803703239162019e-10]]],[0,"686Wbryr9craSt5EBnzz4b",1,0],[1,0.000007939524948596954,0.05794813111424446,-2.2432686264117763e-10],[3,-3.651616069232712e-7,-5.027645725654427e-7,-0.0001525282696540045,0.9999999883673704],[1,-0.000041853226841057135,-0.000057618960663914354,-0.017478452261946668]],[2,"mixamorig:RightHandPinky1",3,[-56],[0,"c1XZp+QJVZyJaCajlWNB1a",1,0],[1,-0.07844501733779907,0.40273842215538025,0.011268055066466331],[3,-0.00855673191644713,-0.017044376462149558,-0.03708944071101398,0.9991299439800965],[1,-1.0550553683648618,-1.993650693526696,-4.23357776947997]],[2,"mixamorig:RightHandPinky2",44,[-57],[0,"fdku4wcrVbQpxYgOO+/CUf",1,0],[1,-1.2615703326446237e-7,0.05125269293785095,3.928428249366789e-9],[3,-3.25611807657905e-7,0.000001989594692946737,0.000022202728354325944,0.9999999997514872],[1,-0.00003731742672122951,0.00022799158629997215,0.0025442451827240235]],[4,"mixamorig:RightHandPinky3",45,[[6,"mixamorig:RightHandPinky4",-58,[0,"83ytJwb39fopCAgVrdbz29",1,0],[1,-0.0000019805941064987564,0.03467840328812599,4.136575249003016e-10]]],[0,"0cXk6dTapSKYcGnQDY/LEY",1,0],[1,0.0000021056894183857366,0.044837724417448044,-6.821431752790375e-10],[3,-2.3968235009866657e-7,-3.164213633645663e-7,-0.00005108117686788422,0.9999999986952779],[1,-0.00002746742643986199,-0.00003626062045290501,-0.005853471688036519]],[2,"mixamorig:LeftUpLeg",4,[-59],[0,"47tCzw/qlTMImOjKEHwIUL",1,0],[1,0.49867716431617737,-0.11675811558961868,0.009896929375827312],[3,-0.00036971877220595044,0.013932419319594174,0.999352358171998,0.03317552133726077],[1,-178.3993614703801,179.90448462984062,3.801370573493914]],[2,"mixamorig:LeftLeg",47,[-60],[0,"16b+8bH+BRlI8tSLay+b9d",1,0],[1,-7.105427198782324e-17,1.2831716537475586,-1.5053613910964714e-10],[3,-0.06066415336442698,-0.003180742199577909,0.06572881208280565,0.9959866799499983],[1,-6.977245352528196,0.09471723686849493,7.545643032435721]],[2,"mixamorig:LeftFoot",48,[-61],[0,"7ftcNXmUBabr5fQYaHbNe7",1,0],[1,6.910332306375722e-9,1.310325264930725,5.865059549137186e-9],[3,0.4905172530184944,0.029868129298268153,0.021403653301695073,0.8706564207359602],[1,58.73340815015915,1.7810960621886618,3.817124647723673]],[4,"mixamorig:LeftToeBase",49,[[6,"mixamorig:LeftToe_End",-62,[0,"6ezb7DSu1Za6qAdagGqkS6",1,0],[1,-8.499682901952355e-11,0.18308007717132568,-2.686548483676887e-10]]],[0,"5f7+2WfF9SFrWCavom58v2",1,0],[1,1.1483449746663155e-9,0.46201640367507935,1.5448597956435606e-9],[3,0.2975997996112592,0.04686956592449647,-0.014629717335470391,0.9534272779987323],[1,34.67013507812923,5.628679323379236,2.1198847696188102e-7]],[2,"mixamorig:RightUpLeg",4,[-63],[0,"d4jR3UgX9XxISbEnhLfDVa",1,0],[1,-0.49867716431617737,-0.11675811558961868,-0.007867591455578804],[3,0.0004950671491842544,0.013077300758409655,0.9993645980696669,-0.033153268895311505],[1,-178.49704907535698,-179.89338946696145,-3.798711324681986]],[2,"mixamorig:RightLeg",51,[-64],[0,"9eR9VGdddfn79ZTofYEGPR",1,0],[1,2.8421708795129297e-16,1.2831684350967407,4.0817856039598865e-11],[3,-0.05226644510664218,0.0025293789850314953,-0.065713897467825,0.9964655059947899],[1,-6.011998367656892,-0.10567267965488163,-7.540540274796702]],[2,"mixamorig:RightFoot",52,[-65],[0,"a1RHajxEFX5K4S1Ecrkfgz",1,0],[1,-2.9305522453171307e-9,1.3085267543792725,5.149571324913893e-10],[3,0.48175299667389443,-0.030282633693244885,-0.02154638640582407,0.875518569491918],[1,57.58140027878832,-1.8531772234107886,-3.836298459858391]],[4,"mixamorig:RightToeBase",53,[[6,"mixamorig:RightToe_End",-66,[0,"2aqyH3B2VQUptGHejSrLd6",1,0],[1,-4.093109184921673e-10,0.18343323469161987,-4.63029961594863e-11]]],[0,"89cABxbvBTYb4MneHC+fjc",1,0],[1,-1.3530891962432179e-9,0.4590276777744293,-2.462967385596926e-9],[3,0.29991948250854167,-0.045622437654289624,0.014361429790154723,0.9527647382899261],[1,34.9468158865221,-5.482944548501971,6.879427657477372e-7]]],0,[0,3,1,0,7,1,0,-1,6,0,-2,4,0,-1,14,0,-2,17,0,-3,20,0,-4,23,0,-5,26,0,-1,32,0,-2,35,0,-3,38,0,-4,41,0,-5,44,0,-1,7,0,-2,47,0,-3,51,0,-1,9,0,-2,11,0,-3,29,0,7,6,0,-1,8,0,-1,10,0,0,10,0,-1,12,0,-1,13,0,-1,15,0,-1,16,0,0,16,0,-1,18,0,-1,19,0,0,19,0,-1,21,0,-1,22,0,0,22,0,-1,24,0,-1,25,0,0,25,0,-1,27,0,-1,28,0,0,28,0,-1,30,0,-1,31,0,-1,33,0,-1,34,0,0,34,0,-1,36,0,-1,37,0,0,37,0,-1,39,0,-1,40,0,0,40,0,-1,42,0,-1,43,0,0,43,0,-1,45,0,-1,46,0,0,46,0,-1,48,0,-1,49,0,-1,50,0,0,50,0,-1,52,0,-1,53,0,-1,54,0,0,54,0,12,1,2,0,13,3,0,31,5,0,8,66],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,14,15,-1,-2,16],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,108,109,110,111,35,18,35]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{},[{},"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[112,4]],[[[17,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{},{}],[[{"depthBias":1},[{},"mainColor",8,[4,4294967295],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[11,6],[113,4]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[11],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[56,"builtin-particle",[{"hash":585841727,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1223598056,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3735404623,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":2524517876,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":53,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[29],[95,"base02",[-2,-3],[0,"d3HR+wTY9d3ajwI/RUknzU",-1,0]],[35,"pCylinder5",1,[-4],[0,"ceWbf/CGhX+aajdnPtNhP1",1,0]],[52,"polySurface3",2,[[73,-5,[9,"3fiVjDW+ZZSJGoux7vnjVa"],[0],[21],1]],[0,"ecmbjnlWNU7Kez1hbjkPDz",1,0]],[115,"scene_5_water",1,[[73,-6,[9,"37XU08uu5ZmaWtIyZ24F7M"],[2],[21],3]],[0,"f1mlFV+TxaK61a2VYDsNZx",1,0],[1,0,0.39543023705482483,0],[1,43.68426513671875,42.35599136352539,61.73048782348633]]],0,[0,3,1,0,-1,2,0,-2,4,0,-1,3,0,7,3,0,7,4,0,12,1,6],[0,0,0,0],[-1,14,-1,14],[114,115,116,117]],[[[22,".bin",3719985447,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.21820469200611115,-0.002988903783261776,-0.21820469200611115],"maxPosition",8,[1,0.21820469200611115,-0.002988903783261776,0.21820469200611115]]],-1],0,0,[],[],[]],[[[54,"lambert2",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":0.800000011920929},"mainColor",8,[4,4286545791],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[6],[10]],[[[22,".bin",655233496,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":15552,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":15552,"count":324,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-10.586359977722168,-13.686452865600586,-14.591748237609863],"maxPosition",8,[1,10.586359977722168,0.7412571907043457,14.591748237609863]]],-1],0,0,[],[],[]],[[[54,"lambert4",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":0}],[[[{"transparencyFactor":0,"albedoScale":0.800000011920929},"mainColor",8,[4,4286545791],"emissiveColor",8,[4,4278190080]]],11]]],0,0,[0],[6],[10]],[[[39,"WarUnit_Near_0"],[1,["25MrXno3JXhbNggrPkHUh1"]],[99,"WarUnit_Near_0",[-6],[-5],[101,"c7SaKD0HlOLKVoAHVMWLTU",-4,0,[[18,["ani"],-3,-2,[1,["dcKEaeE1JP/Lm2YyB6reyr"]]]],[-1]],[1,-0.026,0,-1.535]],[49,0,{},[12,"83yUSPz3FcdI0CjesUc20L",-14,[74,"75ukZhWx9Orp9Flbg+b4HE",2,[[68,[1,["83yUSPz3FcdI0CjesUc20L"]],[-13]]],[[11,"dy9_Idle (8)",["_name"],-7],[10,["_lpos"],-8,[1,0,0,0]],[10,["_lrot"],-9,[3,0,0,0,1]],[10,["_euler"],-10,[1,0,0,0]],[10,["_lscale"],-11,[1,300,300,300]],[3,["_materials","0"],1,1],[40,["_skinningRoot"],1,-12],[11,8,["_materials","length"],1],[3,["_materials","6"],1,2],[3,["_materials","5"],1,3],[3,["_materials","4"],1,4],[3,["_materials","3"],1,5],[3,["_materials","2"],1,6],[3,["_materials","1"],1,7],[3,["_materials","7"],1,8],[3,["_materials","8"],1,9],[11,1,["_shadowCastingMode"],1],[11,false,["lightmapSettings","_castShadow"],1]],[[1,["621cm+QdtYmLkzM73OiANB"]]]],0]],[1,["83yUSPz3FcdI0CjesUc20L"]],[35,"body",2,[3],[0,"49BcnEttJBDoPTm4vkWj2i",2,0]],[69,3,[9,"dcKEaeE1JP/Lm2YyB6reyr"]],[67,2,[9,"a1FovwfF1Dwa6cwcFegpDj"],[154,1],5,6]],0,[0,-1,3,0,2,3,0,5,7,0,3,2,0,-1,7,0,-1,5,0,4,4,0,4,4,0,4,4,0,4,4,0,4,4,0,1,3,0,-1,6,0,3,3,0,12,2,3,0,5,14],[0,0,0,0,0,0,0,0,0,0,6],[8,1,1,1,1,1,1,1,1,1,20],[118,119,26,11,11,11,26,11,26,11,120]],[[[44,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"tintColor",8,[4,4294967295],"mainTexture",6,0]],11]]],0,0,[0,0],[11,6],[13,121]],[[[39,"WarUnit_Near_1"],[1,["00ulMVNgNeUrTrVMrGWZu3"]],[99,"WarUnit_Near_1",[-6],[-5],[101,"fcaHzUKCREm7/1Q1QQq0lc",-4,0,[[18,["ani"],-3,-2,[1,["97d9t4DIVPsLNCNM3T6DtJ"]]]],[-1]],[1,-3.306,0,-1.535]],[49,0,{},[12,"80lU7+iv5Q5Im2sVmcAxVz",-14,[74,"0af2rBfSREHJHz9t2sXsIv",2,[[68,[1,["80lU7+iv5Q5Im2sVmcAxVz"]],[-13]]],[[11,"dy10_Idle (9)",["_name"],-7],[10,["_lpos"],-8,[1,0,0,0]],[10,["_lrot"],-9,[3,0,0,0,1]],[10,["_euler"],-10,[1,0,0,0]],[10,["_lscale"],-11,[1,1.12,1.12,1.12]],[3,["_materials","0"],1,1],[40,["_skinningRoot"],1,-12],[3,["_materials","1"],1,2],[3,["_materials","2"],1,3],[3,["_materials","3"],1,4],[3,["_materials","4"],1,5],[3,["_materials","5"],1,6],[3,["_materials","6"],1,7],[3,["_materials","7"],1,8],[3,["_materials","8"],1,9],[3,["_materials","9"],1,10],[3,["_materials","10"],1,11],[3,["_materials","11"],1,12],[3,["_materials","12"],1,13],[3,["_materials","13"],1,14],[3,["_materials","14"],1,15],[3,["_materials","15"],1,16],[3,["_materials","16"],1,17],[3,["_materials","17"],1,18],[3,["_materials","18"],1,19],[3,["_materials","19"],1,20],[11,1,["_shadowCastingMode"],1]],[[1,["98ZgMaUV9SDIBKrfnoOnNs"]]]],0]],[1,["80lU7+iv5Q5Im2sVmcAxVz"]],[35,"body",2,[3],[0,"62+3DrZERH/LixsbsEkghZ",2,0]],[69,3,[9,"97d9t4DIVPsLNCNM3T6DtJ"]],[67,2,[9,"e0HdQr1GZAyo9SLRHiazdD"],[155,1,1],5,6]],0,[0,-1,3,0,2,3,0,5,7,0,3,2,0,-1,7,0,-1,5,0,4,4,0,4,4,0,4,4,0,4,4,0,4,4,0,1,3,0,-1,6,0,3,3,0,12,2,3,0,5,14],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6],[8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,20],[122,123,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,124]],[[[108,"Click",".wav",0.432688],-1],0,0,[],[],[]],[[[56,"dcc/imported-specular-glossiness",[{"hash":221290481,"name":"dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_NORMAL_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":10,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":14,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":15,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 14) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 15) in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(set = 1, binding = 0) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4  diffuseColor;\n    vec4  specularColor;\n    vec4  emissive;\n    float alphaThreshold;\n    float shininessExponent;\n    float glossiness;\n    float metallic;\n    float normalScale;\n    float transparencyFactor;\n    float diffuseFactor;\n    float specularFactor;\n  };\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  layout(location = 0) in float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  layout(set = 0, binding = 2) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n    layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = texture(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = texture(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  layout(location = 1) in highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    layout(location = 9) in vec3 v_luv;\n    layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  #endif\n  layout(location = 3) in vec3 v_position;\n  layout(location = 5) in vec2 v_uv;\n  layout(location = 6) in vec2 v_uv1;\n  layout(location = 4) in vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    layout(set = 1, binding = 1) uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    layout(set = 1, binding = 2) uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    layout(set = 1, binding = 3) uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    layout(location = 2) in vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    layout(set = 1, binding = 4) uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    layout(set = 1, binding = 5) uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    layout(location = 7) in vec3 v_tangent;\n    layout(location = 8) in vec3 v_bitangent;\n    layout(set = 1, binding = 6) uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    layout(set = 1, binding = 7) uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      layout(set = 2, binding = 1) uniform CCForwardLight {\n        highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n        vec4 cc_lightColor[LIGHTS_PER_PASS];\n        vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n        vec4 cc_lightDir[LIGHTS_PER_PASS];\n      };\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      layout(set = 1, binding = 8) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      layout(set = 1, binding = 9) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      layout(set = 1, binding = 10) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        fragColorX = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        fragColorX = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      layout(location = 0) out vec4 fragColor0;\n      layout(location = 1) out vec4 fragColor1;\n      layout(location = 2) out vec4 fragColor2;\n      void main () {\n        StandardSurface s; surf(s);\n        fragColor0 = s.albedo;\n        fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        fragColor2 = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  layout(std140) uniform Constants {\n    vec4 tilingOffset;\n    vec4 albedo;\n    vec4 albedoScaleAndCutoff;\n    vec4  diffuseColor;\n    vec4  specularColor;\n    vec4  emissive;\n    float alphaThreshold;\n    float shininessExponent;\n    float glossiness;\n    float metallic;\n    float normalScale;\n    float transparencyFactor;\n    float diffuseFactor;\n    float specularFactor;\n  };\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  in float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    highp vec4 cc_shadowInvProjDepthInfo;\n    highp vec4 cc_shadowProjDepthInfo;\n    highp vec4 cc_shadowProjInfo;\n    mediump vec4 cc_shadowNFLSInfo;\n    mediump vec4 cc_shadowWHPBInfo;\n    mediump vec4 cc_shadowLPNNInfo;\n    lowp vec4 cc_shadowColor;\n    mediump vec4 cc_planarNDInfo;\n  };\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        return textureLod(tex, coord, lod);\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = texture(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = texture(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  in highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    in vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n  #endif\n  in vec3 v_position;\n  in vec2 v_uv;\n  in vec2 v_uv1;\n  in vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    in vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    in vec3 v_tangent;\n    in vec3 v_bitangent;\n    uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      layout(std140) uniform CCForwardLight {\n        highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n        vec4 cc_lightColor[LIGHTS_PER_PASS];\n        vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n        vec4 cc_lightDir[LIGHTS_PER_PASS];\n      };\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        fragColorX = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      layout(location = 0) out vec4 fragColorX;\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        fragColorX = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      layout(location = 0) out vec4 fragColor0;\n      layout(location = 1) out vec4 fragColor1;\n      layout(location = 2) out vec4 fragColor2;\n      void main () {\n        StandardSurface s; surf(s);\n        fragColor0 = s.albedo;\n        fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        fragColor2 = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n  precision highp float;\n  uniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n             uniform vec4 albedo;\n           uniform vec4 albedoScaleAndCutoff;\n           uniform vec4 diffuseColor;\n           uniform vec4 specularColor;\n           uniform vec4 emissive;\n           uniform float shininessExponent;\n           uniform float glossiness;\n           uniform float metallic;\n           uniform float normalScale;\n           uniform float transparencyFactor;\n           uniform float diffuseFactor;\n           uniform float specularFactor;\n  float LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n  }\n  float ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogStart = cc_fogBase.x;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n  }\n  float LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n      if (wPos.y < _FogTop) {\n        fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n        fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n      } else {\n        fDeltaY = 0.;\n        fDensityIntegral = 0.;\n      }\n    } else {\n      if (wPos.y < _FogTop) {\n        float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n        fDeltaY = abs(fDeltaA - fDeltaB);\n        fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n      } else {\n        fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n        fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n      }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n      fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n      fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n  }\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n    #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      factor = LayeredFog(pos);\n    #else\n      factor = 1.0;\n    #endif\n  }\n  void CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n    color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n  }\n  #if !CC_USE_ACCURATE_FOG\n  varying float v_fog_factor;\n  #endif\n    void CC_APPLY_FOG(inout vec4 color) {\n  #if !CC_USE_ACCURATE_FOG\n      CC_APPLY_FOG_BASE(color, v_fog_factor);\n  #endif\n  }\n  void CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n  #if CC_USE_ACCURATE_FOG\n      float factor;\n      CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n  #else\n      float factor = v_fog_factor;\n  #endif\n      CC_APPLY_FOG_BASE(color, factor);\n  }\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183f\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  vec3 SRGBToLinear (vec3 gamma) {\n    return gamma * gamma;\n  }\n  uniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  float CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n    float dist = length(viewPos);\n    return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n  }\n  float CCGetLinearDepth(vec3 worldPos) {\n    vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n    return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n  }\n  #if CC_RECEIVE_SHADOW\n    uniform highp sampler2D cc_shadowMap;\n    uniform highp sampler2D cc_spotLightingMap;\n    vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias)\n    {\n      vec4 newShadowPos = shadowPos;\n      if(normalBias > EPSILON_LOWP)\n      {\n        vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n        if(viewNormal.z < 0.1)\n          newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      }\n      return newShadowPos;\n    }\n    vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      vec3 viewSpacePos;\n      viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n      viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n      viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n      vec4 clipSpacePos;\n      clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n      clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n        clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n      }\n      return clipSpacePos;\n    }\n    vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n    {\n      float coeffA = cc_shadowProjDepthInfo.x;\n      float coeffB = cc_shadowProjDepthInfo.y;\n      float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n      viewSpacePos_z += viewspaceDepthBias;\n      vec4 result = shadowPos;\n      result.z = viewSpacePos_z * coeffA + coeffB;\n      return result;\n    }\n    float CCGetShadowFactorHard (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(clipPos.z, closestDepth);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n    float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      float depth = clipPos.z;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n      } else {\n        closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n      }\n      shadow = step(depth, closestDepth);\n      return shadow;\n    }\n    float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos, float bias) {\n      vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, bias);\n      vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float depth = 0.0;\n      if (cc_shadowNFLSInfo.z > EPSILON) {\n        depth = CCGetLinearDepth(worldPos);\n      } else {\n        depth = clipPos.z;\n      }\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > EPSILON) {\n        block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      } else {\n        block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n        block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n        block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n        block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n        block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n        block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n        block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n        block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n        block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      return CCGetSpotLightShadowFactorSoft2X(shadowPos, worldPos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      return CCGetSpotLightShadowFactorSoft(shadowPos, worldPos, shadowBias.x);\n    }else {\n      return CCGetSpotLightShadowFactorHard(shadowPos, worldPos, shadowBias.x);\n    }\n  }\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    float realtimeShadow = 1.0;\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y);\n    float pcf = cc_shadowWHPBInfo.z;\n    if (pcf > 1.9) {\n      realtimeShadow =  CCGetShadowFactorSoft2X(pos, shadowBias.x);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetShadowFactorSoft(pos, shadowBias.x);\n    }else {\n      realtimeShadow = CCGetShadowFactorHard(pos, shadowBias.x);\n    }\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #endif\n  #if CC_USE_IBL\n    uniform samplerCube cc_environment;\n    vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n        #ifdef GL_EXT_shader_texture_lod\n          return texture2DLodEXT(tex, coord, lod);\n        #else\n          return texture2D(tex, coord, lod);\n        #endif\n    }\n    vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n        #ifdef GL_EXT_shader_texture_lod\n          return textureCubeLodEXT(tex, coord, lod);\n        #else\n          return textureCube(tex, coord, lod);\n        #endif\n    }\n    vec3 unpackRGBE (vec4 rgbe) {\n      return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n    }\n    #if CC_USE_DIFFUSEMAP\n      uniform samplerCube cc_diffuseMap;\n    #endif\n  #endif\n  float GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n    vec3 NxH = cross(N, H);\n    float OneMinusNoHSqr = dot(NxH, NxH);\n    float a = roughness * roughness;\n    float n = NoH * a;\n    float p = a / (OneMinusNoHSqr + n * n);\n    return p * p;\n  }\n  float CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n    return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n  }\n  vec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n    return specular * AB.x + AB.y;\n  }\n  #if USE_REFLECTION_DENOISE\n    vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n      #if CC_USE_IBL\n      \tfloat mip = roughness * mipCount;\n      \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n      \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n       \tvec4 filtered = textureCube(cc_environment, R);\n        #if CC_USE_IBL == 2\n        \tbiased.rgb = unpackRGBE(biased);\n        \tfiltered.rgb = unpackRGBE(filtered);\n        #else\n        \tbiased.rgb = SRGBToLinear(biased.rgb);\n        \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n        #endif\n        return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n      #else\n        return vec3(0.0, 0.0, 0.0);\n      #endif\n    }\n  #endif\n  struct StandardSurface {\n    vec4 albedo;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      vec3 position, position_fract_part;\n      #else\n      vec3 position;\n      #endif\n    vec3 normal;\n    vec3 emissive;\n    vec3 lightmap;\n    float lightmap_test;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float specularIntensity;\n    #if CC_RECEIVE_SHADOW\n      vec2 shadowBias;\n    #endif\n  };\n  vec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.0);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW\n      if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      }\n    #endif\n    dirlightContrib *= shadow;\n    finalColor *= dirlightContrib;\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      if (s.lightmap_test > EPSILON_LOWP) {\n        finalColor = diffuse * s.lightmap.rgb * shadow;\n      }\n    #endif\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n    #if CC_USE_IBL\n      #if CC_USE_DIFFUSEMAP\n        vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n        #if CC_USE_DIFFUSEMAP == 2\n          ambDiff = unpackRGBE(diffuseMap);\n        #else\n          ambDiff = SRGBToLinear(diffuseMap.rgb);\n        #endif\n      #endif\n      vec3 R = normalize(reflect(-V, N));\n      #if USE_REFLECTION_DENOISE\n        vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n        #if CC_USE_IBL == 2\n          vec3 env = unpackRGBE(envmap);\n        #else\n          vec3 env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n      finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n    #endif\n    finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.albedo.a);\n  }\n  vec3 ACESToneMap (vec3 color) {\n    color = min(color, vec3(8.0));\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n  }\n  vec4 CCFragOutput (vec4 color) {\n    #if CC_USE_HDR\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = sqrt(color.rgb);\n    return color;\n  }\n  varying highp vec4 v_shadowPos;\n    #if CC_RECEIVE_SHADOW\n  #endif\n  #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    varying vec3 v_luv;\n    uniform sampler2D cc_lightingMap;\n  #endif\n  varying vec3 v_position;\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec3 v_normal;\n  #define DCC_APP_AUTODESK 0\n  #define DCC_APP_BLENDER 1\n  #define DCC_APP_CINEMA4D 2\n  #if USE_SHININESS_MAP\n    uniform sampler2D shininessExponentMap;\n  #endif\n  #if USE_SPECULAR_MAP\n    uniform sampler2D specularMap;\n  #endif\n   #if USE_METALLIC_MAP\n    uniform sampler2D metallicMap;\n  #endif\n  #if USE_VERTEX_COLOR\n    varying vec4 v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    uniform sampler2D albedoMap;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    uniform sampler2D transparencyMap;\n  #endif\n  #if USE_NORMAL_MAP\n    varying vec3 v_tangent;\n    varying vec3 v_bitangent;\n    uniform sampler2D normalMap;\n  #endif\n  #if USE_EMISSIVE_MAP\n    uniform sampler2D emissiveMap;\n  #endif\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n  float d = max(max(diffuse.x, diffuse.y), diffuse.z);\n  vec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n  normalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n  float s = max(max(specular.x, specular.y), specular.z);\n  float delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n  float deltaSqrt = sqrt(max(0.0, delta));\n  float solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n  vec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n  bool isValidSolver = delta >= 0.0;\n  metallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n  albedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n  return isValidSolver;\n}\n  float discolor(vec3 srcColor) {\n    return dot(GRAY_VECTOR, srcColor);\n  }\n  float convertShininessExponent(float shininessExp)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    #else\n      float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n      float glossiness = pow(l2, 0.5);\n    #endif\n      return glossiness;\n  }\n  float getSpecularIntensityFromRoughness(float roughness)\n  {\n    #if DCC_APP_NAME == DCC_APP_BLENDER\n      float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n    #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n      float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n    #else\n      float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n    #endif\n      return specularIntensityMultiplier;\n  }\n  vec4 getSpecularColorAndFactor()\n  {\n    vec3 inSpecular = specularColor.rgb;\n    #if USE_SPECULAR_MAP\n        vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n        specularTex.rgb = SRGBToLinear(specularTex.rgb);\n        inSpecular = specularTex.rgb;\n    #endif\n    return vec4(inSpecular, specularFactor);\n  }\n  void surf (out StandardSurface s) {\n    vec4 baseColor = diffuseColor;\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(v_color.rgb);\n      baseColor.a *= v_color.a;\n    #endif\n    float diffuseScale = diffuseFactor;\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      baseColor = texColor;\n      diffuseScale = 1.0;\n    #endif\n    baseColor.rgb *= diffuseScale;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < albedoScaleAndCutoff.w) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = specularColorAndFactor.w;\n    #if HAS_EXPORTED_GLOSSINESS\n      inGlossiness = glossiness;\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec4 albedo = baseColor;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    s.normal = v_normal;\n    #if USE_NORMAL_MAP\n      vec3 nmmp = texture2D(normalMap, TEXTURE_UV).xyz - vec3(0.5);\n      s.normal =\n        (nmmp.x * normalScale) * normalize(v_tangent) +\n        (nmmp.y * normalScale) * normalize(v_bitangent) +\n        nmmp.z * normalize(s.normal);\n    #endif\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      packHighpData(s.position, s.position_fract_part, v_position);\n      #else\n      s.position = v_position;\n      #endif\n    s.albedo = albedo;\n    s.occlusion = 1.0;\n    s.roughness = 1.0 - inGlossiness;\n    s.metallic = inMetallic;\n    s.specularIntensity = inSpecularIntensity * 0.5;\n    s.emissive = vec3(0.0);\n  #if USE_EMISSIVE_MAP\n    s.emissive = texture2D(emissiveMap, TEXTURE_UV).xyz;\n  #endif\n    #if CC_USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n      s.lightmap = lightColor.xyz * v_luv.z;\n      s.lightmap_test = v_luv.z;\n    #endif\n  }\n    #if CC_FORWARD_ADD\n      #if CC_PIPELINE_TYPE == 0\n        #define LIGHTS_PER_PASS 1\n      #else\n        #define LIGHTS_PER_PASS 10\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n      #endif\n      float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n        float factor = distSqr * invSqrAttRadius;\n        float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n        return smoothFactor * smoothFactor;\n      }\n      float GetDistAtt (float distSqr, float invSqrAttRadius) {\n        float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n        attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n        return attenuation;\n      }\n      float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n        float cd = dot(litDir, L);\n        float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n        return (attenuation * attenuation);\n      }\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n      vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.0);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n        for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n          if (i >= numLights) break;\n          vec3 SLU = cc_lightPos[i].xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.0);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = cc_lightSizeRangeAngle[i].x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = litRadiusSqr / max(litRadiusSqr, distSqr);\n          float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (cc_lightPos[i].w > 0.0) {\n            float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n            float cosOuter = cc_lightSizeRangeAngle[i].z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = cc_lightColor[i].rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n      readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n      readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n      readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n      struct CCLight\n      {\n        vec4 cc_lightPos;\n        vec4 cc_lightColor;\n        vec4 cc_lightSizeRangeAngle;\n        vec4 cc_lightDir;\n      };\n      struct Cluster\n      {\n        vec3 minBounds;\n        vec3 maxBounds;\n      };\n      struct LightGrid\n      {\n        uint offset;\n        uint ccLights;\n      };\n      CCLight getCCLight(uint i)\n      {\n        CCLight light;\n        light.cc_lightPos = b_ccLights[4u * i + 0u];\n        light.cc_lightColor = b_ccLights[4u * i + 1u];\n        light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n        light.cc_lightDir = b_ccLights[4u * i + 3u];\n        return light;\n      }\n      LightGrid getLightGrid(uint cluster)\n      {\n        uvec4 gridvec = b_clusterLightGrid[cluster];\n        LightGrid grid;\n        grid.offset = gridvec.x;\n        grid.ccLights = gridvec.y;\n        return grid;\n      }\n      uint getGridLightIndex(uint start, uint offset)\n      {\n        return b_clusterLightIndices[start + offset];\n      }\n      uint getClusterZIndex(vec4 worldPos)\n      {\n        float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n        float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n        float eyeDepth = -(cc_matView * worldPos).z;\n        uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n        return zIndex;\n      }\n      uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n      {\n        uint zIndex = getClusterZIndex(worldPos);\n        float clusterSizeX = ceil(cc_viewPort.z / float(16));\n        float clusterSizeY = ceil(cc_viewPort.w / float(8));\n        uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n        uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n        return cluster;\n      }\n      vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n        vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n        vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n        vec3 diffuseContrib = diffuse / PI;\n        vec3 position;\n          #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n          position = unpackHighpData(s.position, s.position_fract_part);\n          #else\n          position = s.position;\n          #endif\n        vec3 N = normalize(s.normal);\n        vec3 V = normalize(cc_cameraPos.xyz - position);\n        float NV = max(abs(dot(N, V)), 0.001);\n        specular = BRDFApprox(specular, s.roughness, NV);\n        vec3 finalColor = vec3(0.0);\n        uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n        LightGrid grid = getLightGrid(cluster);\n        uint numLights = grid.ccLights;\n        for (uint i = 0u; i < 100u; i++) {\n          if (i >= numLights) break;\n          uint lightIndex = getGridLightIndex(grid.offset, i);\n          CCLight light = getCCLight(lightIndex);\n          vec3 SLU = light.cc_lightPos.xyz - position;\n          vec3 SL = normalize(SLU);\n          vec3 SH = normalize(SL + V);\n          float SNL = max(dot(N, SL), 0.001);\n          float SNH = max(dot(N, SH), 0.0);\n          float distSqr = dot(SLU, SLU);\n          float litRadius = light.cc_lightSizeRangeAngle.x;\n          float litRadiusSqr = litRadius * litRadius;\n          float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n          float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n          attRadiusSqrInv *= attRadiusSqrInv;\n          float att = GetDistAtt(distSqr, attRadiusSqrInv);\n          vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n          if (light.cc_lightPos.w > 0.0) {\n            float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n            float cosOuter = light.cc_lightSizeRangeAngle.z;\n            float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n            float litAngleOffset = -cosOuter * litAngleScale;\n            att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n          }\n          vec3 lightColor = light.cc_lightColor.rgb;\n          float shadow = 1.0;\n          #if CC_RECEIVE_SHADOW\n            if (light.cc_lightPos.w > 0.0) {\n              shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n            }\n          #endif\n          lightColor *= shadow;\n          finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n        }\n        return vec4(finalColor, 0.0);\n      }\n      #endif\n      void main () {\n        StandardSurface s; surf(s);\n        #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n        vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n        #else\n        vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n        #endif\n        gl_FragData[0] = CCFragOutput(color);\n      }\n    #elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n      void main () {\n        StandardSurface s; surf(s);\n        vec4 color = CCStandardShadingBase(s, v_shadowPos);\n        CC_APPLY_FOG(color, s.position.xyz);\n        gl_FragData[0] = CCFragOutput(color);\n      }\n    #elif CC_PIPELINE_TYPE == 1\n      vec2 signNotZero(vec2 v) {\n        return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n      }\n      vec2 float32x3_to_oct(in vec3 v) {\n        vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n        return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n      }\n      void main () {\n        StandardSurface s; surf(s);\n        gl_FragData[0] = s.albedo;\n        gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n        gl_FragData[2] = vec4(s.emissive, s.occlusion);\n      }\n    #endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":231,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":83}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":[],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","defines":[],"range":[0,2]},{"name":"USE_SHININESS_MAP","type":"boolean","defines":[]},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","defines":["USE_SHININESS_MAP"],"options":["r","g","b","a"]},{"name":"USE_SPECULAR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_MAP","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean","defines":[]},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean","defines":["!HAS_EXPORTED_GLOSSINESS","USE_SHININESS_MAP"]},{"name":"HAS_EXPORTED_METALLIC","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":1243567465,"name":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_TRANSPARENCY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  layout(set = 1, binding = 2) uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  #endif\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedoScaleAndCutoff;\n   uniform vec4 diffuseColor;\n   uniform float transparencyFactor;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\nvec4 frag () {\n  vec4 baseColor = diffuseColor;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n    baseColor *= texColor;\n  #endif\n  #if USE_TRANSPARENCY_MAP\n    baseColor.a = texture2D(transparencyMap, TEXTURE_UV).a * transparencyFactor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.a < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":192,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":83}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"TEXTURE_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"USE_TRANSPARENCY_MAP","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"name":"opaque","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"DiffuseMap"},"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"DiffuseColor","type":"color"},"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"diffuseFactor"},"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"shininessExponent":{"type":13,"value":[100],"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0],"editor":{"displayName":"SpecularColor","type":"color"}},"specularMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"specularFactor":{"type":13,"value":[1],"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"transparencyMap":{"value":"grey","type":28,"editor":{"displayName":"TransparencyMap"}},"transparencyFactor":{"type":13,"value":[0],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"editor":{"displayName":"bumpFactor","parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_GLOSSINESS","slide":true,"step":0.001,"range":[0,1]}},"metallic":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_METALLIC","slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28,"editor":{"parent":"HAS_EXPORTED_METALLIC"}},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"diffuseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"diffuseFactor":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]},"normalScale":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"DiffuseMap"},"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"DiffuseColor","type":"color"},"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"editor":{"displayName":"diffuseFactor"},"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"shininessExponent":{"type":13,"value":[100],"editor":{"parent":"!HAS_EXPORTED_GLOSSINESS"}},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0],"editor":{"displayName":"SpecularColor","type":"color"}},"specularMap":{"value":"grey","type":28,"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"specularFactor":{"type":13,"value":[1],"editor":{"parent":"!HAS_EXPORTED_METALLIC"}},"transparencyMap":{"value":"grey","type":28,"editor":{"displayName":"TransparencyMap"}},"transparencyFactor":{"type":13,"value":[0],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"editor":{"displayName":"bumpFactor","parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,5]},"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_GLOSSINESS","slide":true,"step":0.001,"range":[0,1]}},"metallic":{"type":13,"value":[0],"editor":{"parent":"HAS_EXPORTED_METALLIC","slide":true,"step":0.001,"range":[0,1]}},"metallicMap":{"value":"grey","type":28,"editor":{"parent":"HAS_EXPORTED_METALLIC"}},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}},"diffuseColor":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"diffuseFactor":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0,0,0,0.5]},"normalScale":{"type":13,"editor":{"visible":false,"deprecated":true},"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"dcc/imported-specular-glossiness|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]]]]
